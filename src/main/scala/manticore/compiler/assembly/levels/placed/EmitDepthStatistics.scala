package manticore.compiler.assembly.levels.placed

import com.google.ortools.Loader
import com.google.ortools.linearsolver.MPSolver
import com.google.ortools.linearsolver.MPVariable
import manticore.compiler.AssemblyContext
import manticore.compiler.Color
import manticore.compiler.CyclicColorGenerator
import manticore.compiler.assembly.BinaryOperator
import manticore.compiler.assembly.BinaryOperator.AND
import manticore.compiler.assembly.BinaryOperator.BinaryOperator
import manticore.compiler.assembly.BinaryOperator.OR
import manticore.compiler.assembly.BinaryOperator.XOR
import manticore.compiler.assembly.DependenceGraphBuilder
import manticore.compiler.assembly.levels.AssemblyTransformer
import manticore.compiler.assembly.levels.CanCollectProgramStatistics
import manticore.compiler.assembly.levels.ConstType
import manticore.compiler.assembly.levels.UInt16
import org.jgrapht.Graph
import org.jgrapht.GraphMapping
import org.jgrapht.Graphs
import org.jgrapht.alg.util.UnionFind
import org.jgrapht.graph.AsSubgraph
import org.jgrapht.graph.AsUnmodifiableGraph
import org.jgrapht.graph.DefaultEdge
import org.jgrapht.graph.DirectedAcyclicGraph
import org.jgrapht.nio.Attribute
import org.jgrapht.nio.DefaultAttribute
import org.jgrapht.traverse.TopologicalOrderIterator

import java.io.StringWriter
import java.nio.file.Files
import java.nio.file.Paths
import java.util.function.Function
import scala.collection.immutable.{BitSet => Cut}
import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.LinkedHashMap
import scala.collection.mutable.Queue
import scala.collection.mutable.{HashMap => MHashMap}
import scala.collection.mutable.{HashSet => MHashSet}
import scala.jdk.CollectionConverters._
import manticore.compiler.assembly.levels.DeadCodeElimination
import manticore.compiler.assembly.levels.placed.Helpers.DeadCode

trait EmitDepthStatistics extends DependenceGraphBuilder with PlacedIRTransformer with CanCollectProgramStatistics {

  val flavor = PlacedIR
  import flavor._

  // We want vertices for every element that could be used as a primary input. The highest-level names are not generated
  // by instructions, so we store `Name` directly for those. For all other vertices we store the `Instruction`.
  type DepVertex = Either[Name, Instruction]
  type DepGraph  = Graph[DepVertex, DefaultEdge]

  // We want vertices for every element that could be used as a primary input. The highest-level names are not generated
  // by instructions, so we store `Name` directly for those. For all other vertices we store the `Instruction`.
  def createDependenceGraph(
      proc: DefProcess
  )(implicit
      ctx: AssemblyContext
  ): DepGraph = {
    val g: DepGraph = new DirectedAcyclicGraph(classOf[DefaultEdge])

    val instrRegDefs = proc.body.flatMap { instr =>
      val regDefs = NameDependence.regDef(instr)
      regDefs.map { regDef =>
        regDef -> instr
      }
    }.toMap

    proc.body.foreach { instr =>
      // Add a vertex for every instruction.
      g.addVertex(Right(instr))

      // Add a vertex for every register that is read. Note that we may read names that
      // are not generated by any instruction (primary inputs for example). We therefore
      // need to be careful here and possibly create a `Name` for the vertex instead of
      // a `Instruction`.
      val regUses = NameDependence.regUses(instr)
      regUses.foreach { rs =>
        instrRegDefs.get(rs) match {
          case None =>
            // rs is not generated by an instruction, so we create a `Name` for it.
            g.addVertex(Left(rs))
            // Use Left(rs) here as it is a `Name`.
            g.addEdge(Left(rs), Right(instr))

          case Some(rsInstr) =>
            // rs is generated by an instruction. The program is ordered, so we must
            // have already seen rs and created a vertex for it beforehand. There is
            // nothing to do.
            // Use Right(rsInstr) here as rs is generated by an `Instruction`, not a `Name`.
            g.addEdge(Right(rsInstr), Right(instr))
        }
      }
    }

    g
  }

  def onProcess(
      proc: DefProcess
  )(implicit ctx: AssemblyContext): Unit = {
    val g = createDependenceGraph(proc)

    ctx.logger.dumpArtifact(
      s"dependence_graph_${ctx.logger.countProgress()}_${transformId}.dot",
      forceDump = false
    ) {
      // All vertices should use the string representation of the instruction
      // that generates them, or the name itself (if a primary input).
      val nameMap = g
        .vertexSet()
        .asScala
        .map { v =>
          v match {
            case Left(name)   => v -> name
            case Right(instr) => v -> instr.toString()
          }
        }
        .toMap

      // val clusters = depth
      //   .groupMap { case (v, d) => d } { case (v, d) => v }
      //   .map { case (d, vs) => d -> vs.toSet }

      dumpGraph(
        g,
        // clusters = clusters,
        vNameMap = nameMap
      )
    }

    val sources = g.vertexSet().asScala.filter(v => !Graphs.vertexHasPredecessors(g, v))

    val depth = MHashMap.empty[DepVertex, Int]
    g.vertexSet().asScala.foreach(v => depth += v -> 0)

    val visited = MHashSet.empty[DepVertex]
    val queue   = Queue() ++ sources

    while (!queue.isEmpty) {
      val curr      = queue.dequeue()
      val currDepth = depth(curr)

      if (visited.contains(curr)) {
        assert(false, s"Already visited vertex ${curr}")
      }

      visited += curr

      val succs = Graphs.successorListOf(g, curr).asScala
      succs.foreach { succ =>
        val succDepth = math.max(depth(succ), currDepth + 1)
        depth += succ -> succDepth
        queue.enqueue(succ)
      }
    }

    val numInstrs = g.vertexSet().size()
    val maxDepth  = depth.values.max

    ctx.logger.info(s"numInstrs = ${numInstrs}, max depth = ${maxDepth}")

  }

  override def transform(
      program: DefProgram
  )(implicit ctx: AssemblyContext): DefProgram = {

    val newProcesses = program.processes.map(proc => onProcess(proc))

    // Does not change the program, just prints statistics, so we can
    // return the original program.
    program
  }

  // Helper method to dump a graph of clusters in DOT format.
  def dumpGraph[V](
      g: Graph[V, DefaultEdge],
      vNameMap: Map[V, String] = Map.empty[V, String]
  ): String = {
    // The jgrapht library does not support emitting graphviz `subgraph`s.
    // The scala-graph library does support emitting graphviz `subgraphs`s, so we use it instead.
    import scalax.collection.{Graph => SGraph}
    import scalax.collection.mutable.{Graph => MSGraph}
    import scalax.collection.GraphEdge.DiEdge
    import scalax.collection.io.dot._
    import scalax.collection.io.dot.implicits._

    // Converts a jgrapht Graph to a scala-graph graph.
    // Note that a mutable graph (MSGraph) is constructed, but we return a graph of the
    // "interface" type (SGraph) as the DOT exporter only supports this parent interface.
    def jg2sc[V](
        jg: Graph[V, DefaultEdge]
    ): (
        SGraph[Int, DiEdge],
        Map[V, Int],
        Map[Int, V]
    ) = {
      val sg    = MSGraph.empty[Int, DiEdge]
      val vToId = MHashMap.empty[V, Int]
      val idToV = MHashMap.empty[Int, V]

      jg.vertexSet().asScala.zipWithIndex.foreach { case (v, idx) =>
        vToId += v   -> idx
        idToV += idx -> v
        sg += idx
      }

      jg.edgeSet().asScala.foreach { e =>
        val src   = jg.getEdgeSource(e)
        val dst   = jg.getEdgeTarget(e)
        val srcId = vToId(src)
        val dstId = vToId(dst)
        sg += DiEdge(srcId, dstId)
      }

      (sg, vToId.toMap, idToV.toMap)
    }

    def escape(s: String): String = s.replaceAll("\"", "\\\\\"")
    def quote(s: String): String  = s"\"${s}\""

    // Some vertices have quotes in them when represented as strings. These vertices
    // cannot be used as graphviz identifiers, so we assign an index to all vertices
    // instead.
    val (sg, vToId, idToV) = jg2sc(g)

    val dotRoot = DotRootGraph(
      directed = true,
      id = Some("dependence graph")
    )

    def edgeTransform(
        iedge: scalax.collection.Graph[Int, DiEdge]#EdgeT
    ): Option[
      (
          DotGraph,   // The graph/subgraph to which this edge belongs.
          DotEdgeStmt // Statements to modify the edge's representation.
      )
    ] = {
      iedge.edge match {
        case DiEdge(source, target) =>
          Some(
            (
              dotRoot, // All edges are part of the root graph.
              DotEdgeStmt(
                NodeId(source.toOuter),
                NodeId(target.toOuter)
              )
            )
          )
        case e @ _ =>
          assert(
            false,
            s"Edge ${e} in the dependence graph could not be serialized!"
          )
          None
      }
    }

    def nodeTransformer(
        inode: scalax.collection.Graph[Int, DiEdge]#NodeT
    ): Option[
      (
          DotGraph,   // The graph/subgraph to which this node belongs.
          DotNodeStmt // Statements to modify the node's representation.
      )
    ] = {
      // If the vertex is part of a cluster, select the corresponding subgraph.
      // Otherwise add the vertex to the root graph.
      val dotGraph = dotRoot

      val vId    = inode.toOuter
      val v      = idToV(vId)
      val vName  = vNameMap.getOrElse(v, v.toString())
      val vLabel = escape(vName)

      Some(
        (
          dotGraph,
          DotNodeStmt(
            NodeId(vId),
            Seq(
              DotAttr("label", quote(vLabel)),
            )
          )
        )
      )
    }

    val dotExport: String = sg.toDot(
      dotRoot = dotRoot,
      edgeTransformer = edgeTransform,
      cNodeTransformer = Some(nodeTransformer)
    )

    dotExport
  }

}

object EmitDepthStatistics extends EmitDepthStatistics
