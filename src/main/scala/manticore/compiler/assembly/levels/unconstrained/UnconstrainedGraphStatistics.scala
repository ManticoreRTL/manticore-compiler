package manticore.compiler.assembly.levels.unconstrained

import manticore.compiler.assembly.levels.CanCollectProgramStatistics
import manticore.compiler.AssemblyContext

import collection.mutable.{HashMap => MHashMap}
import org.jgrapht.Graph
import org.jgrapht.graph.DirectedAcyclicGraph
import manticore.compiler.assembly.DependenceGraphBuilder
import org.jgrapht.graph.DefaultEdge

import scala.jdk.CollectionConverters._
import org.jgrapht.alg.cycle.CycleDetector
import org.jgrapht.traverse.TopologicalOrderIterator
import org.jgrapht.Graphs

trait UnconstrainedGraphStatistics
    extends DependenceGraphBuilder
    with UnconstrainedIRTransformer
    with CanCollectProgramStatistics {

  val flavor = UnconstrainedIR
  import flavor._

  // We want vertices for every element that could be used as a primary input. The highest-level names are not generated
  // by instructions, so we store `Name` directly for those. For all other vertices we store the `Instruction`.
  type DepVertex = Either[Name, Instruction]
  type DepGraph  = Graph[DepVertex, DefaultEdge]

  def createDependenceGraph(
      proc: DefProcess
  )(implicit
      ctx: AssemblyContext
  ): DepGraph = {
    val g: DepGraph = new DirectedAcyclicGraph(classOf[DefaultEdge])

    val instrRegDefs = proc.body.flatMap { instr =>
      val regDefs = NameDependence.regDef(instr)
      regDefs.map { regDef =>
        regDef -> instr
      }
    }.toMap

    proc.body.foreach { instr =>
      // Add a vertex for every instruction.
      g.addVertex(Right(instr))

      // Add a vertex for every register that is read. Note that we may read names that
      // are not generated by any instruction (primary inputs for example). We therefore
      // need to be careful here and possibly create a `Name` for the vertex instead of
      // a `Instruction`.
      val regUses = NameDependence.regUses(instr)
      regUses.foreach { rs =>
        instrRegDefs.get(rs) match {
          case None =>
            // rs is not generated by an instruction, so we create a `Name` for it.
            g.addVertex(Left(rs))
            // Use Left(rs) here as it is a `Name`.
            g.addEdge(Left(rs), Right(instr))

          case Some(rsInstr) =>
            // rs is generated by an instruction. The program is ordered, so we must
            // have already seen rs and created a vertex for it beforehand. There is
            // nothing to do.
            // Use Right(rsInstr) here as rs is generated by an `Instruction`, not a `Name`.
            g.addEdge(Right(rsInstr), Right(instr))
        }
      }
    }

    g
  }

  // Helper method to dump a graph of clusters in DOT format.
  def dumpGraph[V](
      g: Graph[V, DefaultEdge],
      clusters: Map[
        Int,   // Cluster ID
        Set[V] // Vertices in cluster
      ] = Map.empty[Int, Set[V]],
      clusterColorMap: Map[
        Int,   // Cluster ID
        String // Color to be assigned to cluster
      ] = Map.empty[Int, String],
      vNameMap: Map[V, String] = Map.empty[V, String]
  ): String = {
    // The jgrapht library does not support emitting graphviz `subgraph`s.
    // The scala-graph library does support emitting graphviz `subgraphs`s, so we use it instead.
    import scalax.collection.{Graph => SGraph}
    import scalax.collection.mutable.{Graph => MSGraph}
    import scalax.collection.GraphEdge.DiEdge
    import scalax.collection.io.dot._
    import scalax.collection.io.dot.implicits._

    // Converts a jgrapht Graph to a scala-graph graph.
    // Note that a mutable graph (MSGraph) is constructed, but we return a graph of the
    // "interface" type (SGraph) as the DOT exporter only supports this parent interface.
    def jg2sc[V](
        jg: Graph[V, DefaultEdge]
    ): (
        SGraph[Int, DiEdge],
        Map[V, Int],
        Map[Int, V]
    ) = {
      val sg    = MSGraph.empty[Int, DiEdge]
      val vToId = MHashMap.empty[V, Int]
      val idToV = MHashMap.empty[Int, V]

      jg.vertexSet().asScala.zipWithIndex.foreach { case (v, idx) =>
        vToId += v   -> idx
        idToV += idx -> v
        sg += idx
      }

      jg.edgeSet().asScala.foreach { e =>
        val src   = jg.getEdgeSource(e)
        val dst   = jg.getEdgeTarget(e)
        val srcId = vToId(src)
        val dstId = vToId(dst)
        sg += DiEdge(srcId, dstId)
      }

      (sg, vToId.toMap, idToV.toMap)
    }

    def escape(s: String): String = s.replaceAll("\"", "\\\\\"")
    def quote(s: String): String  = s"\"${s}\""

    // Some vertices have quotes in them when represented as strings. These vertices
    // cannot be used as graphviz identifiers, so we assign an index to all vertices
    // instead.
    val (sg, vToId, idToV) = jg2sc(g)

    val dotRoot = DotRootGraph(
      directed = true,
      id = Some("program graph with custom functions")
    )

    val dotSubgraphs = clusters.map { case (clusterId, vertices) =>
      val dotSub = DotSubGraph(
        dotRoot,
        Id(s"cluster_${clusterId}")
      )
      clusterId -> dotSub
    }

    def edgeTransform(
        iedge: scalax.collection.Graph[Int, DiEdge]#EdgeT
    ): Option[
      (
          DotGraph,   // The graph/subgraph to which this edge belongs.
          DotEdgeStmt // Statements to modify the edge's representation.
      )
    ] = {
      iedge.edge match {
        case DiEdge(source, target) =>
          Some(
            (
              dotRoot, // All edges are part of the root graph.
              DotEdgeStmt(
                NodeId(source.toOuter),
                NodeId(target.toOuter)
              )
            )
          )
        case e @ _ =>
          assert(
            false,
            s"Edge ${e} in the dependence graph could not be serialized!"
          )
          None
      }
    }

    def nodeTransformer(
        inode: scalax.collection.Graph[Int, DiEdge]#NodeT
    ): Option[
      (
          DotGraph,   // The graph/subgraph to which this node belongs.
          DotNodeStmt // Statements to modify the node's representation.
      )
    ] = {
      val clusterId = clusters
        .find { case (clusterId, vertices) =>
          val vId = inode.toOuter
          val v   = idToV(vId)
          vertices.contains(v)
        }
        .map { case (clusterId, vertices) =>
          clusterId
        }

      // If the vertex is part of a cluster, select the corresponding subgraph.
      // Otherwise add the vertex to the root graph.
      val dotGraph = clusterId
        .map(id => dotSubgraphs(id))
        .getOrElse(dotRoot)

      val vId    = inode.toOuter
      val v      = idToV(vId)
      val vName  = vNameMap.getOrElse(v, v.toString())
      val vLabel = escape(vName)

      // If the vertex is part of a cluster, select its corresponding color.
      // Otherwise use white as the default color.
      val vColor = clusterId
        .map(id => clusterColorMap(id))
        .getOrElse("white")

      Some(
        (
          dotGraph,
          DotNodeStmt(
            NodeId(vId),
            Seq(
              DotAttr("label", quote(vLabel)),
              DotAttr("style", quote("filled")),
              DotAttr("fillcolor", quote(vColor))
            )
          )
        )
      )
    }

    val dotExport: String = sg.toDot(
      dotRoot = dotRoot,
      edgeTransformer = edgeTransform,
      cNodeTransformer = Some(nodeTransformer)
    )

    dotExport
  }

  def onProcess(
      proc: DefProcess
  )(implicit ctx: AssemblyContext): Unit = {
    val dependenceGraph = createDependenceGraph(proc)

    ctx.logger.dumpArtifact(
      s"dependence_graph_${ctx.logger.countProgress()}_${transformId}_${proc.id}.dot",
      forceDump = false
    ) {
      dumpGraph(
        dependenceGraph
      )
    }

    val cycleDetector = new CycleDetector(dependenceGraph)
    if (cycleDetector.detectCycles()) {
      ctx.logger.fail("Found a cycle!")
    } else {

      val schedule = MHashMap.empty[DepVertex, Int].withDefaultValue(0)

      // Assign schedule of 0 to all primary inputs.
      dependenceGraph.vertexSet().asScala.foreach { v =>
        val noPreds = !Graphs.vertexHasPredecessors(dependenceGraph, v)
        if (noPreds) {
          schedule += v -> 0
        }
      }

      val iterator = new TopologicalOrderIterator(dependenceGraph)

      while (iterator.hasNext()) {
        val v     = iterator.next()
        val succs = Graphs.successorListOf(dependenceGraph, v).asScala

        val vTime = schedule(v)
        succs.foreach { succ =>
          schedule += succ -> (vTime + 1)
        }
      }

      // Count how many vertices are found at each scheduled time slot.
      val histWidth = schedule
        .groupBy { case (v, vTime) => vTime }
        .map { case (vTime, map) => vTime -> map.size }
      val depth = schedule.values.max
      val numVertices = dependenceGraph.vertexSet().size()

      ctx.logger.dumpArtifact(
        s"asap_stats.txt",
        forceDump = false
      ) {
        Seq(
          s"numVertices -> ${numVertices}",
          s"depth -> ${depth}",
          histWidth.toSeq.sorted.map { case (vTime, numVertices) =>
            s"time ${vTime} -> ${numVertices} vertices"
          }.mkString("\n")
        ).mkString("\n")
      }
    }
  }

  def transform(
      program: DefProgram
  )(implicit ctx: AssemblyContext): DefProgram = {
    if (program.processes.size > 1) {
      ctx.logger.error("More than one process! Cannot determine program parallelism.")
    }
    program.processes.foreach(proc => onProcess(proc))
    // Does not modify program, simply computes statistics on it.
    program
  }

}

object UnconstrainedGraphStatistics extends UnconstrainedGraphStatistics
