package manticore.assembly.levels

/** RemoveAliases.scala
  *
  * @author
  *   Sahand Kashani <sahand.kashani@epfl.ch>
  */

import manticore.assembly.levels.AssemblyTransformer
import manticore.compiler.AssemblyContext
import manticore.assembly.levels.ConstType
import manticore.assembly.BinaryOperator
import manticore.assembly.ManticoreAssemblyIR
import java.lang.Character.Subset

/** This transform identifies and removes aliases from the design. Processing
  * the following input program:
  *
  * ```
  *   .const c_0 4 0
  *   .const c_1 4 0
  *   .wire c 4
  *   .wire d 4
  *   .wire e 4
  *   .wire f 4
  *   .wire g 4
  *   .wire h 4
  *   add c, d, e
  *   add f, c, c_0
  *   add g, d, c_1
  *   add h, f, g
  * ```
  *
  * Will result in the following output:
  *
  * ```
  *   .const c_0 4 0
  *   .const c_1 4 0
  *   .wire c 4
  *   .wire d 4
  *   .wire e 4
  *   .wire f 4
  *   .wire g 4
  *   .wire h 4
  *   add c, d, e
  *   add f, c, c_0
  *   add g, d, c_0     <<< "c_1" was replaced with "c_0"
  *   add h, c, d       <<< "f" was replaced with "c"; "g" was replaced with "d".
  * ```
  */
trait RemoveAliases extends Flavored {

  import flavor._
  val Zero: Constant

  def removeAliases(
      proc: DefProcess
  ): DefProcess = {

    /** Finds all aliases in the instruction sequence.
      *
      * @param body
      *   Target instructions.
      * @param consts
      *   Constants referenced in `body`. Each constant is defined by a width
      *   and a value.
      * @return
      *   Map of aliases in `body` and `consts`.
      */
    def findAliases(
        body: Seq[Instruction],
        consts: Map[Name, (Int, Constant)]
    ): Map[Name, Name] = {

      def findBodyAliases(
          body: Seq[Instruction],
          consts: Map[Name, (Int, Constant)],
          aliases: Map[Name, Name] = Map.empty
      ): Map[Name, Name] = {
        body match {
          case Nil =>
            // End of instruction stream. We return all aliases we have found so far.
            aliases

          case head +: tail =>
            val newAliases = collection.mutable.Map[Name, Name]()
            // Must use capital letter for first char, otherwise the pattern match below will not work!


            head match {
              case BinaryArithmetic(operator, rd, rs1, rs2, annons) =>
                operator match {
                  case BinaryOperator.ADD =>
                    // If rs1 is 0, then rd is an alias of rs2.
                    consts.get(rs1) match {
                      // We don't care about the width of the 0.
                      case Some((width, Zero)) => newAliases += rd -> rs2
                      case _                   =>
                    }
                    // if rs2 is 0, then rd is an alias of rs1.
                    consts.get(rs2) match {
                      // We don't care about the width of the 0.
                      case Some((width, Zero)) => newAliases += rd -> rs1
                      case _                   =>
                    }

                  // Handle aliases generated by
                  // ADD, ADDC, SUB, OR, AND, XOR, MUL, SEQ, SLL, SRL, SLTU, SLTS, SGTU, SGTS
                  case _ =>
                }
              case Mov(rd, rs, _) =>
                newAliases += rd -> rs
              // Handle aliases in MUX, LOADs, STOREs, ...
              case _ =>
            }

            findBodyAliases(tail, consts, aliases ++ newAliases)
        }
      }

      def findConstAliases(
          consts: Map[Name, (Int, Constant)]
      ): Map[Name, Name] = {
        val constAliases = consts
          .groupBy { case (name, (width, value)) =>
            (width, value)
          }
          .flatMap { case ((width, value), names) =>
            // All these names are aliases of one another. We use the first element from the set as the representative
            // and mark all others as being aliases of this one.

            // We sort to ensure the order is deterministic.
            val group = names.keys.toSeq.sortBy(name => name.toString())
            val (representative, aliases) = (group.head, group.tail)
            val aliasMap = aliases.map { alias =>
              alias -> representative
            }.toMap
            aliasMap
          }

        constAliases
      }

      val bodyAliases = findBodyAliases(body, consts)
      val constAliases = findConstAliases(consts)
      val allAliases = bodyAliases ++ constAliases

      allAliases
    }

    /** Backtracks along alias chains and finds the root of every alias.
      *
      * If we have the following input aliases:
      *
      * ```
      * a -> b
      * b -> c
      * c -> d
      * ```
      *
      * Then the output aliases will be:
      *
      * ```
      * a -> d
      * b -> d
      * c -> d
      * ```
      *
      * @param aliases
      *   Aliases to resolve.
      * @return
      *   Resolved aliases.
      */
    def resolveAliases(
        aliases: Map[Name, Name]
    ): Map[Name, Name] = {
      // Cache of backtracking results to avoid exponential lookup if we end up
      // going up the same tree multiple times.
      val aliasCache = collection.mutable.Map() ++ aliases

      def resolve(name: Name): Name = {
        aliasCache.get(name) match {
          case Some(alias) =>
            val root = resolve(alias)
            // Keep backtracking result to prevent exponential lookups later.
            aliasCache += name -> root
            root
          case None =>
            name
        }
      }

      aliases.map { case (name, alias) =>
        name -> resolve(alias)
      }
    }

    /** Replaces aliased names in the input instruction using the given alias
      * table.
      *
      * @param instr
      *   Target instruction.
      * @param aliases
      *   Map of all known aliases.
      * @return
      *   Instruction with aliases replaced.
      */
    def replaceAliases(
        instr: Instruction,
        aliases: Map[Name, Name]
    ): Instruction = {
      def replaceName(name: Name): Name = {
        aliases.get(name) match {
          case Some(rootName) =>
            // `name` is an alias of rootName, so we return `rootName`.
            rootName
          case None =>
            // Original name unchanged.
            name
        }
      }

      // The @unchecked is to remove warnings saying that this is not an exhaustive match.
      // It is exhaustive, but the compiler can't see it.
      (instr match {
        case i @ BinaryArithmetic(operator, rd, rs1, rs2, annons) =>
          i.copy(
            rs1 = replaceName(rs1),
            rs2 = replaceName(rs2)
          )

        case i @ CustomInstruction(func, rd, rs1, rs2, rs3, rs4, annons) =>
          i.copy(
            rs1 = replaceName(rs1),
            rs2 = replaceName(rs2),
            rs3 = replaceName(rs3),
            rs4 = replaceName(rs4)
          )

        case i @ LocalLoad(rd, base, offset, annons) =>
          i.copy(base = replaceName(base))

        case i @ LocalStore(rs, base, offset, predicate, annons) =>
          val newPredicate = predicate.map(replaceName)
          i.copy(base = replaceName(base), predicate = newPredicate)

        case i @ GlobalLoad(rd, base, annons) =>
          val newBase =
            (replaceName(base._1), replaceName(base._2), replaceName(base._3))
          i.copy(base = newBase)

        case i @ GlobalStore(rs, base, predicate, annons) =>
          val newBase =
            (replaceName(base._1), replaceName(base._2), replaceName(base._3))
          val newPredicate = predicate.map(replaceName)
          i.copy(base = newBase, predicate = newPredicate)

        case i @ SetValue(rd, value, annons) =>
          i
        case i @ Send(rd, rs, dest_id, annons) =>
          i.copy(rs = replaceName(rs))

        case i @ Expect(ref, got, error_id, annons) =>
          i.copy(ref = replaceName(ref), got = replaceName(got))

        case i @ Predicate(rs, annons) =>
          i.copy(rs = replaceName(rs))

        case i @ Mux(rd, sel, rfalse, rtrue, annons) =>
          i.copy(
            sel = replaceName(sel),
            rfalse = replaceName(rfalse),
            rtrue = replaceName(rtrue)
          )

        case Nop =>
          Nop

        case i @ PadZero(rd, rs, width, annons) =>
          i.copy(rs = replaceName(rs))

        case i @ Mov(rd, rs, annons) => i.copy(rs = replaceName(rs))

        case i @ AddC(rd, co, rs1, rs2, ci, annons) =>
          i.copy(
            rs1 = replaceName(rs1),
            rs2 = replaceName(rs2),
            ci = replaceName(ci)
          )
        case i @(_:SetCarry | _:ClearCarry)  => i

      }).setPos(instr.pos)
    }

    val consts = proc.registers
      .filter { reg =>
        reg.variable.varType == ConstType
      }
      .map { reg =>
        reg.variable.name -> (reg.variable.width, reg.value.get)
      }
      .toMap

    val aliases = findAliases(proc.body, consts)
    val resolvedAliases = resolveAliases(aliases)
    // Note that we do not map on the registers of the assembly program as "resolvedAliases" already
    // contains constant-to-constant aliases as well and these are automatically replaced in the body.
    val newBody = proc.body.map(instr => replaceAliases(instr, resolvedAliases))

    proc.copy(body = newBody)
  }

  def do_transform(
      asm: DefProgram,
      context: AssemblyContext
  ): DefProgram = {
    implicit val ctx = context

    val out = asm
      .copy(
        processes = asm.processes.map(process => removeAliases(process))
      )
      .setPos(asm.pos)

    out
  }

  // // Note that we use `T#` for the method signature instead of `flavor._` as flavor is private to
  // // this instance and cannot escape it (as the return value for example).
  // override def transform(
  //     asm: T#DefProgram,
  //     context: AssemblyContext
  // ): T#DefProgram = {
  //   val asmIn = asm.asInstanceOf[flavor.DefProgram]
  //   val asmOut = Impl(asmIn, context)
  //   asmOut
  // }
}
