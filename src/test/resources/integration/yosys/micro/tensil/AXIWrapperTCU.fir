;buildInfoPackage: chisel3, version: 3.4.3, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit AXIWrapperTCU : 
  module Queue : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}, count : UInt<2>}
    
    cmem ram : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.arguments <= io.enq.bits.arguments @[Decoupled.scala 230:24]
      MPORT.flags <= io.enq.bits.flags @[Decoupled.scala 230:24]
      MPORT.opcode <= io.enq.bits.opcode @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.arguments <= io_deq_bits_MPORT.arguments @[Decoupled.scala 242:15]
    io.deq.bits.flags <= io_deq_bits_MPORT.flags @[Decoupled.scala 242:15]
    io.deq.bits.opcode <= io_deq_bits_MPORT.opcode @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}}, count : UInt<1>}
    
    cmem ram : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT.bits.arguments <= io.enq.bits.bits.arguments @[Decoupled.scala 230:24]
      MPORT.bits.flags <= io.enq.bits.bits.flags @[Decoupled.scala 230:24]
      MPORT.bits.opcode <= io.enq.bits.bits.opcode @[Decoupled.scala 230:24]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits.bits.arguments <= io_deq_bits_MPORT.bits.arguments @[Decoupled.scala 242:15]
    io.deq.bits.bits.flags <= io_deq_bits_MPORT.bits.flags @[Decoupled.scala 242:15]
    io.deq.bits.bits.opcode <= io_deq_bits_MPORT.bits.opcode @[Decoupled.scala 242:15]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits.bits.arguments <= io.enq.bits.bits.arguments @[Decoupled.scala 247:19]
      io.deq.bits.bits.flags <= io.enq.bits.bits.flags @[Decoupled.scala 247:19]
      io.deq.bits.bits.opcode <= io.enq.bits.bits.opcode @[Decoupled.scala 247:19]
      io.deq.bits.last <= io.enq.bits.last @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Counter : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip resetValue : UInt<1>}
    
    reg value : UInt<20>, clock with : (reset => (reset, UInt<20>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<20>("h0fffff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module CountBy : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip step : UInt<20>, flip resetValue : UInt<1>}
    
    reg value : UInt<20>, clock with : (reset => (reset, UInt<20>("h00"))) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<21>("h0100000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h00") @[CountBy.scala 23:13]
        skip @[CountBy.scala 22:36]
      else : @[CountBy.scala 24:17]
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
        skip @[CountBy.scala 24:17]
      skip @[CountBy.scala 21:24]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h00") @[CountBy.scala 29:11]
      skip @[CountBy.scala 28:23]
    
  module SizeAndStrideHandler : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    node stride = dshl(UInt<1>("h01"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    inst addressCounter of CountBy @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h00") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h00") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h00") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
      skip @[SizeAndStrideHandler.scala 45:25]
    else : @[SizeAndStrideHandler.scala 47:15]
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
      skip @[SizeAndStrideHandler.scala 47:15]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
      skip @[SizeAndStrideHandler.scala 53:52]
    else : @[SizeAndStrideHandler.scala 57:15]
      io.in.ready <= UInt<1>("h00") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]
      skip @[SizeAndStrideHandler.scala 57:15]
    
  module StrideHandler : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    inst handler of SizeAndStrideHandler @[StrideHandler.scala 27:23]
    handler.clock <= clock
    handler.reset <= reset
    handler.io.in.valid <= UInt<1>("h00") @[StrideHandler.scala 37:23]
    wire _handler_io_in_bits_WIRE : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _handler_io_in_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.size <= UInt<20>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.address <= UInt<20>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    handler.io.in.bits.reverse <= _handler_io_in_bits_WIRE.reverse @[StrideHandler.scala 38:22]
    handler.io.in.bits.stride <= _handler_io_in_bits_WIRE.stride @[StrideHandler.scala 38:22]
    handler.io.in.bits.size <= _handler_io_in_bits_WIRE.size @[StrideHandler.scala 38:22]
    handler.io.in.bits.address <= _handler_io_in_bits_WIRE.address @[StrideHandler.scala 38:22]
    handler.io.in.bits.write <= _handler_io_in_bits_WIRE.write @[StrideHandler.scala 38:22]
    handler.io.out.ready <= UInt<1>("h00") @[StrideHandler.scala 39:24]
    node _T = eq(io.in.bits.stride, UInt<1>("h00")) @[StrideHandler.scala 41:23]
    when _T : @[StrideHandler.scala 41:32]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 44:36]
      io.out.bits.write <= io.in.bits.write @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 47:25]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 48:22]
      io.in.ready <= io.out.ready @[StrideHandler.scala 49:14]
      io.out.valid <= io.in.valid @[StrideHandler.scala 50:18]
      skip @[StrideHandler.scala 41:32]
    else : @[StrideHandler.scala 51:15]
      handler.io.in.bits.reverse <= io.in.bits.reverse @[StrideHandler.scala 52:19]
      handler.io.in.bits.stride <= io.in.bits.stride @[StrideHandler.scala 52:19]
      handler.io.in.bits.size <= io.in.bits.size @[StrideHandler.scala 52:19]
      handler.io.in.bits.address <= io.in.bits.address @[StrideHandler.scala 52:19]
      handler.io.in.bits.write <= io.in.bits.write @[StrideHandler.scala 52:19]
      handler.io.in.valid <= io.in.valid @[StrideHandler.scala 52:19]
      io.in.ready <= handler.io.in.ready @[StrideHandler.scala 52:19]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 55:36]
      io.out.bits.write <= handler.io.out.bits.write @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 58:25]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 59:22]
      handler.io.out.ready <= io.out.ready @[StrideHandler.scala 60:26]
      io.out.valid <= handler.io.out.valid @[StrideHandler.scala 61:18]
      skip @[StrideHandler.scala 51:15]
    
  module Counter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip resetValue : UInt<1>}
    
    reg value : UInt<20>, clock with : (reset => (reset, UInt<20>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<20>("h0fffff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module CountBy_1 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<20>}, flip step : UInt<20>, flip resetValue : UInt<1>}
    
    reg value : UInt<20>, clock with : (reset => (reset, UInt<20>("h00"))) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<21>("h0100000"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h00") @[CountBy.scala 23:13]
        skip @[CountBy.scala 22:36]
      else : @[CountBy.scala 24:17]
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
        skip @[CountBy.scala 24:17]
      skip @[CountBy.scala 21:24]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h00") @[CountBy.scala 29:11]
      skip @[CountBy.scala 28:23]
    
  module SizeAndStrideHandler_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    node stride = dshl(UInt<1>("h01"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_1 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    inst addressCounter of CountBy_1 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h00") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h00") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h00") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
      skip @[SizeAndStrideHandler.scala 45:25]
    else : @[SizeAndStrideHandler.scala 47:15]
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
      skip @[SizeAndStrideHandler.scala 47:15]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
      skip @[SizeAndStrideHandler.scala 53:52]
    else : @[SizeAndStrideHandler.scala 57:15]
      io.in.ready <= UInt<1>("h00") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]
      skip @[SizeAndStrideHandler.scala 57:15]
    
  module StrideHandler_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    inst handler of SizeAndStrideHandler_1 @[StrideHandler.scala 27:23]
    handler.clock <= clock
    handler.reset <= reset
    handler.io.in.valid <= UInt<1>("h00") @[StrideHandler.scala 37:23]
    wire _handler_io_in_bits_WIRE : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _handler_io_in_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.size <= UInt<20>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.address <= UInt<20>("h00") @[package.scala 80:57]
    _handler_io_in_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    handler.io.in.bits.reverse <= _handler_io_in_bits_WIRE.reverse @[StrideHandler.scala 38:22]
    handler.io.in.bits.stride <= _handler_io_in_bits_WIRE.stride @[StrideHandler.scala 38:22]
    handler.io.in.bits.size <= _handler_io_in_bits_WIRE.size @[StrideHandler.scala 38:22]
    handler.io.in.bits.address <= _handler_io_in_bits_WIRE.address @[StrideHandler.scala 38:22]
    handler.io.in.bits.write <= _handler_io_in_bits_WIRE.write @[StrideHandler.scala 38:22]
    handler.io.out.ready <= UInt<1>("h00") @[StrideHandler.scala 39:24]
    node _T = eq(io.in.bits.stride, UInt<1>("h00")) @[StrideHandler.scala 41:23]
    when _T : @[StrideHandler.scala 41:32]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 44:36]
      io.out.bits.write <= io.in.bits.write @[StrideHandler.scala 44:36]
      io.out.bits.address <= io.in.bits.address @[StrideHandler.scala 47:25]
      io.out.bits.size <= io.in.bits.size @[StrideHandler.scala 48:22]
      io.in.ready <= io.out.ready @[StrideHandler.scala 49:14]
      io.out.valid <= io.in.valid @[StrideHandler.scala 50:18]
      skip @[StrideHandler.scala 41:32]
    else : @[StrideHandler.scala 51:15]
      handler.io.in.bits.reverse <= io.in.bits.reverse @[StrideHandler.scala 52:19]
      handler.io.in.bits.stride <= io.in.bits.stride @[StrideHandler.scala 52:19]
      handler.io.in.bits.size <= io.in.bits.size @[StrideHandler.scala 52:19]
      handler.io.in.bits.address <= io.in.bits.address @[StrideHandler.scala 52:19]
      handler.io.in.bits.write <= io.in.bits.write @[StrideHandler.scala 52:19]
      handler.io.in.valid <= io.in.valid @[StrideHandler.scala 52:19]
      io.in.ready <= handler.io.in.ready @[StrideHandler.scala 52:19]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 55:36]
      io.out.bits.write <= handler.io.out.bits.write @[StrideHandler.scala 55:36]
      io.out.bits.address <= handler.io.out.bits.address @[StrideHandler.scala 58:25]
      io.out.bits.size <= handler.io.out.bits.size @[StrideHandler.scala 59:22]
      handler.io.out.ready <= io.out.ready @[StrideHandler.scala 60:26]
      io.out.valid <= handler.io.out.valid @[StrideHandler.scala 61:18]
      skip @[StrideHandler.scala 51:15]
    
  module Counter_2 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module CountBy_2 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip step : UInt<6>, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<7>("h040"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h00") @[CountBy.scala 23:13]
        skip @[CountBy.scala 22:36]
      else : @[CountBy.scala 24:17]
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
        skip @[CountBy.scala 24:17]
      skip @[CountBy.scala 21:24]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h00") @[CountBy.scala 29:11]
      skip @[CountBy.scala 28:23]
    
  module SizeAndStrideHandler_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}}
    
    node stride = dshl(UInt<1>("h01"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_2 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    inst addressCounter of CountBy_2 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h00") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h00") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h00") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
      skip @[SizeAndStrideHandler.scala 45:25]
    else : @[SizeAndStrideHandler.scala 47:15]
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
      skip @[SizeAndStrideHandler.scala 47:15]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
      skip @[SizeAndStrideHandler.scala 53:52]
    else : @[SizeAndStrideHandler.scala 57:15]
      io.in.ready <= UInt<1>("h00") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]
      skip @[SizeAndStrideHandler.scala 57:15]
    
  module Counter_3 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module CountBy_3 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip step : UInt<6>, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<7>("h040"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h00") @[CountBy.scala 23:13]
        skip @[CountBy.scala 22:36]
      else : @[CountBy.scala 24:17]
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
        skip @[CountBy.scala 24:17]
      skip @[CountBy.scala 21:24]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h00") @[CountBy.scala 29:11]
      skip @[CountBy.scala 28:23]
    
  module SizeAndStrideHandler_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}}
    
    node stride = dshl(UInt<1>("h01"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_3 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    inst addressCounter of CountBy_3 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h00") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h00") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.size <= io.in.bits.size @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.size <= UInt<1>("h00") @[SizeAndStrideHandler.scala 43:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
      skip @[SizeAndStrideHandler.scala 45:25]
    else : @[SizeAndStrideHandler.scala 47:15]
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
      skip @[SizeAndStrideHandler.scala 47:15]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
      skip @[SizeAndStrideHandler.scala 53:52]
    else : @[SizeAndStrideHandler.scala 57:15]
      io.in.ready <= UInt<1>("h00") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]
      skip @[SizeAndStrideHandler.scala 57:15]
    
  module Queue_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.reverse <= io.enq.bits.reverse @[Decoupled.scala 230:24]
      MPORT.stride <= io.enq.bits.stride @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.reverse <= io_deq_bits_MPORT.reverse @[Decoupled.scala 242:15]
    io.deq.bits.stride <= io_deq_bits_MPORT.stride @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.reverse <= io.enq.bits.reverse @[Decoupled.scala 230:24]
      MPORT.stride <= io.enq.bits.stride @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.reverse <= io_deq_bits_MPORT.reverse @[Decoupled.scala 242:15]
    io.deq.bits.stride <= io_deq_bits_MPORT.stride @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Counter_4 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module CountBy_4 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip step : UInt<6>, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[CountBy.scala 17:22]
    io.value.bits <= value @[CountBy.scala 19:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[CountBy.scala 20:21]
    io.value.valid <= _io_value_valid_T @[CountBy.scala 20:18]
    when io.value.ready : @[CountBy.scala 21:24]
      node _T = sub(UInt<7>("h040"), io.step) @[CountBy.scala 22:24]
      node _T_1 = tail(_T, 1) @[CountBy.scala 22:24]
      node _T_2 = geq(value, _T_1) @[CountBy.scala 22:16]
      when _T_2 : @[CountBy.scala 22:36]
        value <= UInt<1>("h00") @[CountBy.scala 23:13]
        skip @[CountBy.scala 22:36]
      else : @[CountBy.scala 24:17]
        node _value_T = add(value, io.step) @[CountBy.scala 25:22]
        node _value_T_1 = tail(_value_T, 1) @[CountBy.scala 25:22]
        value <= _value_T_1 @[CountBy.scala 25:13]
        skip @[CountBy.scala 24:17]
      skip @[CountBy.scala 21:24]
    when io.resetValue : @[CountBy.scala 28:23]
      value <= UInt<1>("h00") @[CountBy.scala 29:11]
      skip @[CountBy.scala 28:23]
    
  module SizeAndStrideHandler_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>}}}
    
    node stride = dshl(UInt<1>("h01"), io.in.bits.stride) @[SizeAndStrideHandler.scala 30:20]
    inst sizeCounter of Counter_4 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    inst addressCounter of CountBy_4 @[CountBy.scala 35:19]
    addressCounter.clock <= clock
    addressCounter.reset <= reset
    addressCounter.io.step <= stride @[CountBy.scala 36:15]
    addressCounter.io.resetValue <= UInt<1>("h00") @[CountBy.scala 37:21]
    addressCounter.io.value.ready <= UInt<1>("h00") @[CountBy.scala 38:22]
    io.out.valid <= io.in.valid @[SizeAndStrideHandler.scala 35:16]
    io.out.bits.accumulate <= io.in.bits.accumulate @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.write <= io.in.bits.write @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.read <= io.in.bits.read @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.altAddress <= io.in.bits.altAddress @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.address <= io.in.bits.address @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.instruction.dest <= io.in.bits.instruction.dest @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.instruction.sourceRight <= io.in.bits.instruction.sourceRight @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.instruction.sourceLeft <= io.in.bits.instruction.sourceLeft @[SizeAndStrideHandler.scala 38:34]
    io.out.bits.instruction.op <= io.in.bits.instruction.op @[SizeAndStrideHandler.scala 38:34]
    when io.in.bits.reverse : @[SizeAndStrideHandler.scala 45:25]
      node _io_out_bits_address_T = sub(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 46:44]
      node _io_out_bits_address_T_1 = tail(_io_out_bits_address_T, 1) @[SizeAndStrideHandler.scala 46:44]
      io.out.bits.address <= _io_out_bits_address_T_1 @[SizeAndStrideHandler.scala 46:25]
      skip @[SizeAndStrideHandler.scala 45:25]
    else : @[SizeAndStrideHandler.scala 47:15]
      node _io_out_bits_address_T_2 = add(io.in.bits.address, addressCounter.io.value.bits) @[SizeAndStrideHandler.scala 48:44]
      node _io_out_bits_address_T_3 = tail(_io_out_bits_address_T_2, 1) @[SizeAndStrideHandler.scala 48:44]
      io.out.bits.address <= _io_out_bits_address_T_3 @[SizeAndStrideHandler.scala 48:25]
      skip @[SizeAndStrideHandler.scala 47:15]
    node fire = and(io.in.valid, io.out.ready) @[SizeAndStrideHandler.scala 51:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeAndStrideHandler.scala 53:34]
    when _T : @[SizeAndStrideHandler.scala 53:52]
      io.in.ready <= io.out.ready @[SizeAndStrideHandler.scala 54:14]
      sizeCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 55:31]
      addressCounter.io.resetValue <= fire @[SizeAndStrideHandler.scala 56:34]
      skip @[SizeAndStrideHandler.scala 53:52]
    else : @[SizeAndStrideHandler.scala 57:15]
      io.in.ready <= UInt<1>("h00") @[SizeAndStrideHandler.scala 58:14]
      sizeCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 59:32]
      addressCounter.io.value.ready <= fire @[SizeAndStrideHandler.scala 60:35]
      skip @[SizeAndStrideHandler.scala 57:15]
    
  module Counter_5 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module SizeHandler : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>}}}
    
    inst sizeCounter of Counter_5 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.zeroes <= io.in.bits.zeroes @[SizeHandler.scala 28:34]
    io.out.bits.load <= io.in.bits.load @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
      skip @[SizeHandler.scala 34:52]
    else : @[SizeHandler.scala 37:15]
      io.in.ready <= UInt<1>("h00") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]
      skip @[SizeHandler.scala 37:15]
    
  module Counter_6 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module SizeHandler_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>, size : UInt<6>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>}}}
    
    inst sizeCounter of Counter_6 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.kind <= io.in.bits.kind @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
      skip @[SizeHandler.scala 34:52]
    else : @[SizeHandler.scala 37:15]
      io.in.ready <= UInt<1>("h00") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]
      skip @[SizeHandler.scala 37:15]
    
  module MultiEnqueue : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[1]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node allEnqueued = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[3]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[4]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_3 = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module Validator : 
    input clock : Clock
    input reset : Reset
    output io : {flip instruction : {valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}, error : UInt<1>}
    
    when io.instruction.valid : @[Validator.scala 33:27]
      node _T = eq(io.instruction.bits.opcode, UInt<1>("h01")) @[Validator.scala 34:34]
      when _T : @[Validator.scala 34:53]
        wire flags : {_unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Validator.scala 35:23]
        wire args : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Validator.scala 36:23]
        wire _flags_WIRE : {_unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Validator.scala 38:47]
        wire _flags_WIRE_1 : UInt<4>
        _flags_WIRE_1 <= io.instruction.bits.flags
        node _flags_T = bits(_flags_WIRE_1, 0, 0) @[Validator.scala 38:47]
        _flags_WIRE.accumulate <= _flags_T @[Validator.scala 38:47]
        node _flags_T_1 = bits(_flags_WIRE_1, 1, 1) @[Validator.scala 38:47]
        _flags_WIRE.zeroes <= _flags_T_1 @[Validator.scala 38:47]
        node _flags_T_2 = bits(_flags_WIRE_1, 3, 2) @[Validator.scala 38:47]
        _flags_WIRE._unused <= _flags_T_2 @[Validator.scala 38:47]
        flags.accumulate <= _flags_WIRE.accumulate @[Validator.scala 38:13]
        flags.zeroes <= _flags_WIRE.zeroes @[Validator.scala 38:13]
        flags._unused <= _flags_WIRE._unused @[Validator.scala 38:13]
        wire _args_WIRE : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Validator.scala 39:50]
        wire _args_WIRE_1 : UInt<48>
        _args_WIRE_1 <= io.instruction.bits.arguments
        node _args_T = bits(_args_WIRE_1, 5, 0) @[Validator.scala 39:50]
        _args_WIRE.memAddress <= _args_T @[Validator.scala 39:50]
        node _args_T_1 = bits(_args_WIRE_1, 8, 6) @[Validator.scala 39:50]
        _args_WIRE.memStride <= _args_T_1 @[Validator.scala 39:50]
        node _args_T_2 = bits(_args_WIRE_1, 15, 9) @[Validator.scala 39:50]
        _args_WIRE._unused0 <= _args_T_2 @[Validator.scala 39:50]
        node _args_T_3 = bits(_args_WIRE_1, 35, 16) @[Validator.scala 39:50]
        _args_WIRE.accAddress <= _args_T_3 @[Validator.scala 39:50]
        node _args_T_4 = bits(_args_WIRE_1, 38, 36) @[Validator.scala 39:50]
        _args_WIRE.accStride <= _args_T_4 @[Validator.scala 39:50]
        node _args_T_5 = bits(_args_WIRE_1, 39, 39) @[Validator.scala 39:50]
        _args_WIRE._unused1 <= _args_T_5 @[Validator.scala 39:50]
        node _args_T_6 = bits(_args_WIRE_1, 47, 40) @[Validator.scala 39:50]
        _args_WIRE.size <= _args_T_6 @[Validator.scala 39:50]
        args.memAddress <= _args_WIRE.memAddress @[Validator.scala 39:12]
        args.memStride <= _args_WIRE.memStride @[Validator.scala 39:12]
        args._unused0 <= _args_WIRE._unused0 @[Validator.scala 39:12]
        args.accAddress <= _args_WIRE.accAddress @[Validator.scala 39:12]
        args.accStride <= _args_WIRE.accStride @[Validator.scala 39:12]
        args._unused1 <= _args_WIRE._unused1 @[Validator.scala 39:12]
        args.size <= _args_WIRE.size @[Validator.scala 39:12]
        node _T_1 = geq(args.size, UInt<7>("h040")) @[Validator.scala 41:22]
        when _T_1 : @[Validator.scala 41:57]
          io.error <= UInt<1>("h01") @[Validator.scala 42:18]
          skip @[Validator.scala 41:57]
        else : @[Validator.scala 43:69]
          node _T_2 = geq(args.accAddress, UInt<7>("h040")) @[Validator.scala 43:34]
          when _T_2 : @[Validator.scala 43:69]
            io.error <= UInt<1>("h01") @[Validator.scala 44:18]
            skip @[Validator.scala 43:69]
          else : @[Validator.scala 45:63]
            node _T_3 = geq(args.memAddress, UInt<7>("h040")) @[Validator.scala 45:34]
            when _T_3 : @[Validator.scala 45:63]
              io.error <= UInt<1>("h01") @[Validator.scala 46:18]
              skip @[Validator.scala 45:63]
            else : @[Validator.scala 49:9]
              node _T_4 = add(args.accAddress, args.size) @[Validator.scala 48:25]
              node _T_5 = tail(_T_4, 1) @[Validator.scala 48:25]
              node _T_6 = geq(_T_5, UInt<7>("h040")) @[Validator.scala 48:37]
              when _T_6 : @[Validator.scala 49:9]
                io.error <= UInt<1>("h01") @[Validator.scala 50:18]
                skip @[Validator.scala 49:9]
              else : @[Validator.scala 51:75]
                node _T_7 = add(args.memAddress, args.size) @[Validator.scala 51:34]
                node _T_8 = tail(_T_7, 1) @[Validator.scala 51:34]
                node _T_9 = geq(_T_8, UInt<7>("h040")) @[Validator.scala 51:46]
                when _T_9 : @[Validator.scala 51:75]
                  io.error <= UInt<1>("h01") @[Validator.scala 52:18]
                  skip @[Validator.scala 51:75]
                else : @[Validator.scala 53:41]
                  node _T_10 = neq(flags._unused, UInt<1>("h00")) @[Validator.scala 53:32]
                  when _T_10 : @[Validator.scala 53:41]
                    io.error <= UInt<1>("h01") @[Validator.scala 54:18]
                    skip @[Validator.scala 53:41]
                  else : @[Validator.scala 55:19]
                    io.error <= UInt<1>("h00") @[Validator.scala 56:18]
                    skip @[Validator.scala 55:19]
        skip @[Validator.scala 34:53]
      else : @[Validator.scala 58:64]
        node _T_11 = eq(io.instruction.bits.opcode, UInt<2>("h03")) @[Validator.scala 58:40]
        when _T_11 : @[Validator.scala 58:64]
          wire flags_1 : {_unused : UInt<3>, zeroes : UInt<1>} @[Validator.scala 59:23]
          wire args_1 : {size : UInt<24>, _unused : UInt<7>, stride : UInt<3>, address : UInt<6>} @[Validator.scala 60:23]
          wire _flags_WIRE_2 : {_unused : UInt<3>, zeroes : UInt<1>} @[Validator.scala 62:47]
          wire _flags_WIRE_3 : UInt<4>
          _flags_WIRE_3 <= io.instruction.bits.flags
          node _flags_T_3 = bits(_flags_WIRE_3, 0, 0) @[Validator.scala 62:47]
          _flags_WIRE_2.zeroes <= _flags_T_3 @[Validator.scala 62:47]
          node _flags_T_4 = bits(_flags_WIRE_3, 3, 1) @[Validator.scala 62:47]
          _flags_WIRE_2._unused <= _flags_T_4 @[Validator.scala 62:47]
          flags_1.zeroes <= _flags_WIRE_2.zeroes @[Validator.scala 62:13]
          flags_1._unused <= _flags_WIRE_2._unused @[Validator.scala 62:13]
          wire _args_WIRE_2 : {size : UInt<24>, _unused : UInt<7>, stride : UInt<3>, address : UInt<6>} @[Validator.scala 63:50]
          wire _args_WIRE_3 : UInt<40>
          _args_WIRE_3 <= io.instruction.bits.arguments
          node _args_T_7 = bits(_args_WIRE_3, 5, 0) @[Validator.scala 63:50]
          _args_WIRE_2.address <= _args_T_7 @[Validator.scala 63:50]
          node _args_T_8 = bits(_args_WIRE_3, 8, 6) @[Validator.scala 63:50]
          _args_WIRE_2.stride <= _args_T_8 @[Validator.scala 63:50]
          node _args_T_9 = bits(_args_WIRE_3, 15, 9) @[Validator.scala 63:50]
          _args_WIRE_2._unused <= _args_T_9 @[Validator.scala 63:50]
          node _args_T_10 = bits(_args_WIRE_3, 39, 16) @[Validator.scala 63:50]
          _args_WIRE_2.size <= _args_T_10 @[Validator.scala 63:50]
          args_1.address <= _args_WIRE_2.address @[Validator.scala 63:12]
          args_1.stride <= _args_WIRE_2.stride @[Validator.scala 63:12]
          args_1._unused <= _args_WIRE_2._unused @[Validator.scala 63:12]
          args_1.size <= _args_WIRE_2.size @[Validator.scala 63:12]
          node _T_12 = gt(args_1.size, UInt<4>("h09")) @[Validator.scala 65:22]
          when _T_12 : @[Validator.scala 65:55]
            io.error <= UInt<1>("h01") @[Validator.scala 66:18]
            skip @[Validator.scala 65:55]
          else : @[Validator.scala 67:60]
            node _T_13 = geq(args_1.address, UInt<7>("h040")) @[Validator.scala 67:31]
            when _T_13 : @[Validator.scala 67:60]
              io.error <= UInt<1>("h01") @[Validator.scala 68:18]
              skip @[Validator.scala 67:60]
            else : @[Validator.scala 69:72]
              node _T_14 = add(args_1.address, args_1.size) @[Validator.scala 69:31]
              node _T_15 = tail(_T_14, 1) @[Validator.scala 69:31]
              node _T_16 = geq(_T_15, UInt<7>("h040")) @[Validator.scala 69:43]
              when _T_16 : @[Validator.scala 69:72]
                io.error <= UInt<1>("h01") @[Validator.scala 70:18]
                skip @[Validator.scala 69:72]
              else : @[Validator.scala 71:41]
                node _T_17 = neq(flags_1._unused, UInt<1>("h00")) @[Validator.scala 71:32]
                when _T_17 : @[Validator.scala 71:41]
                  io.error <= UInt<1>("h01") @[Validator.scala 72:18]
                  skip @[Validator.scala 71:41]
                else : @[Validator.scala 73:19]
                  io.error <= UInt<1>("h00") @[Validator.scala 74:18]
                  skip @[Validator.scala 73:19]
          skip @[Validator.scala 58:64]
        else : @[Validator.scala 76:61]
          node _T_18 = eq(io.instruction.bits.opcode, UInt<2>("h02")) @[Validator.scala 76:40]
          when _T_18 : @[Validator.scala 76:61]
            wire args_2 : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Validator.scala 77:23]
            wire flags_2 : {kind : UInt<4>} @[Validator.scala 78:23]
            wire _args_WIRE_4 : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Validator.scala 80:50]
            wire _args_WIRE_5 : UInt<48>
            _args_WIRE_5 <= io.instruction.bits.arguments
            node _args_T_11 = bits(_args_WIRE_5, 5, 0) @[Validator.scala 80:50]
            _args_WIRE_4.memAddress <= _args_T_11 @[Validator.scala 80:50]
            node _args_T_12 = bits(_args_WIRE_5, 8, 6) @[Validator.scala 80:50]
            _args_WIRE_4.memStride <= _args_T_12 @[Validator.scala 80:50]
            node _args_T_13 = bits(_args_WIRE_5, 15, 9) @[Validator.scala 80:50]
            _args_WIRE_4._unused0 <= _args_T_13 @[Validator.scala 80:50]
            node _args_T_14 = bits(_args_WIRE_5, 35, 16) @[Validator.scala 80:50]
            _args_WIRE_4.accAddress <= _args_T_14 @[Validator.scala 80:50]
            node _args_T_15 = bits(_args_WIRE_5, 38, 36) @[Validator.scala 80:50]
            _args_WIRE_4.accStride <= _args_T_15 @[Validator.scala 80:50]
            node _args_T_16 = bits(_args_WIRE_5, 39, 39) @[Validator.scala 80:50]
            _args_WIRE_4._unused1 <= _args_T_16 @[Validator.scala 80:50]
            node _args_T_17 = bits(_args_WIRE_5, 47, 40) @[Validator.scala 80:50]
            _args_WIRE_4.size <= _args_T_17 @[Validator.scala 80:50]
            args_2.memAddress <= _args_WIRE_4.memAddress @[Validator.scala 80:12]
            args_2.memStride <= _args_WIRE_4.memStride @[Validator.scala 80:12]
            args_2._unused0 <= _args_WIRE_4._unused0 @[Validator.scala 80:12]
            args_2.accAddress <= _args_WIRE_4.accAddress @[Validator.scala 80:12]
            args_2.accStride <= _args_WIRE_4.accStride @[Validator.scala 80:12]
            args_2._unused1 <= _args_WIRE_4._unused1 @[Validator.scala 80:12]
            args_2.size <= _args_WIRE_4.size @[Validator.scala 80:12]
            wire _flags_WIRE_4 : {kind : UInt<4>} @[Validator.scala 81:47]
            wire _flags_WIRE_5 : UInt<4>
            _flags_WIRE_5 <= io.instruction.bits.flags
            node _flags_T_5 = bits(_flags_WIRE_5, 3, 0) @[Validator.scala 81:47]
            _flags_WIRE_4.kind <= _flags_T_5 @[Validator.scala 81:47]
            flags_2.kind <= _flags_WIRE_4.kind @[Validator.scala 81:13]
            node _T_19 = eq(flags_2.kind, UInt<1>("h00")) @[Validator.scala 84:20]
            node _T_20 = eq(flags_2.kind, UInt<1>("h01")) @[Validator.scala 85:22]
            node _T_21 = or(_T_19, _T_20) @[Validator.scala 84:51]
            node _T_22 = eq(flags_2.kind, UInt<2>("h02")) @[Validator.scala 86:22]
            node _T_23 = or(_T_21, _T_22) @[Validator.scala 85:53]
            node _T_24 = eq(flags_2.kind, UInt<2>("h03")) @[Validator.scala 87:22]
            node _T_25 = or(_T_23, _T_24) @[Validator.scala 86:53]
            when _T_25 : @[Validator.scala 88:9]
              node _T_26 = geq(args_2.size, UInt<7>("h040")) @[Validator.scala 89:24]
              when _T_26 : @[Validator.scala 89:53]
                io.error <= UInt<1>("h01") @[Validator.scala 90:20]
                skip @[Validator.scala 89:53]
              else : @[Validator.scala 91:65]
                node _T_27 = geq(args_2.memAddress, UInt<7>("h040")) @[Validator.scala 91:36]
                when _T_27 : @[Validator.scala 91:65]
                  io.error <= UInt<1>("h01") @[Validator.scala 92:20]
                  skip @[Validator.scala 91:65]
                else : @[Validator.scala 93:77]
                  node _T_28 = add(args_2.memAddress, args_2.size) @[Validator.scala 93:36]
                  node _T_29 = tail(_T_28, 1) @[Validator.scala 93:36]
                  node _T_30 = geq(_T_29, UInt<7>("h040")) @[Validator.scala 93:48]
                  when _T_30 : @[Validator.scala 93:77]
                    io.error <= UInt<1>("h01") @[Validator.scala 94:20]
                    skip @[Validator.scala 93:77]
                  else : @[Validator.scala 95:21]
                    io.error <= UInt<1>("h00") @[Validator.scala 96:20]
                    skip @[Validator.scala 95:21]
              skip @[Validator.scala 88:9]
            else : @[Validator.scala 102:9]
              node _T_31 = eq(flags_2.kind, UInt<4>("h0c")) @[Validator.scala 99:20]
              node _T_32 = eq(flags_2.kind, UInt<4>("h0d")) @[Validator.scala 100:22]
              node _T_33 = or(_T_31, _T_32) @[Validator.scala 99:57]
              node _T_34 = eq(flags_2.kind, UInt<4>("h0f")) @[Validator.scala 101:22]
              node _T_35 = or(_T_33, _T_34) @[Validator.scala 100:59]
              when _T_35 : @[Validator.scala 102:9]
                node _T_36 = geq(args_2.size, UInt<7>("h040")) @[Validator.scala 103:24]
                when _T_36 : @[Validator.scala 103:59]
                  io.error <= UInt<1>("h01") @[Validator.scala 104:20]
                  skip @[Validator.scala 103:59]
                else : @[Validator.scala 105:71]
                  node _T_37 = geq(args_2.accAddress, UInt<7>("h040")) @[Validator.scala 105:36]
                  when _T_37 : @[Validator.scala 105:71]
                    io.error <= UInt<1>("h01") @[Validator.scala 106:20]
                    skip @[Validator.scala 105:71]
                  else : @[Validator.scala 107:65]
                    node _T_38 = geq(args_2.memAddress, UInt<7>("h040")) @[Validator.scala 107:36]
                    when _T_38 : @[Validator.scala 107:65]
                      io.error <= UInt<1>("h01") @[Validator.scala 108:20]
                      skip @[Validator.scala 107:65]
                    else : @[Validator.scala 111:11]
                      node _T_39 = add(args_2.accAddress, args_2.size) @[Validator.scala 110:27]
                      node _T_40 = tail(_T_39, 1) @[Validator.scala 110:27]
                      node _T_41 = geq(_T_40, UInt<7>("h040")) @[Validator.scala 110:39]
                      when _T_41 : @[Validator.scala 111:11]
                        io.error <= UInt<1>("h01") @[Validator.scala 112:20]
                        skip @[Validator.scala 111:11]
                      else : @[Validator.scala 113:77]
                        node _T_42 = add(args_2.memAddress, args_2.size) @[Validator.scala 113:36]
                        node _T_43 = tail(_T_42, 1) @[Validator.scala 113:36]
                        node _T_44 = geq(_T_43, UInt<7>("h040")) @[Validator.scala 113:48]
                        when _T_44 : @[Validator.scala 113:77]
                          io.error <= UInt<1>("h01") @[Validator.scala 114:20]
                          skip @[Validator.scala 113:77]
                        else : @[Validator.scala 115:21]
                          io.error <= UInt<1>("h00") @[Validator.scala 116:20]
                          skip @[Validator.scala 115:21]
                skip @[Validator.scala 102:9]
              else : @[Validator.scala 118:19]
                io.error <= UInt<1>("h01") @[Validator.scala 119:18]
                skip @[Validator.scala 118:19]
            skip @[Validator.scala 76:61]
          else : @[Validator.scala 122:57]
            node _T_45 = eq(io.instruction.bits.opcode, UInt<3>("h04")) @[Validator.scala 122:40]
            when _T_45 : @[Validator.scala 122:57]
              wire flags_3 : {_unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Validator.scala 123:23]
              wire args_3 : {_unused : UInt<1>, instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Validator.scala 125:13]
              wire _flags_WIRE_6 : {_unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Validator.scala 126:47]
              wire _flags_WIRE_7 : UInt<4>
              _flags_WIRE_7 <= io.instruction.bits.flags
              node _flags_T_6 = bits(_flags_WIRE_7, 0, 0) @[Validator.scala 126:47]
              _flags_WIRE_6.read <= _flags_T_6 @[Validator.scala 126:47]
              node _flags_T_7 = bits(_flags_WIRE_7, 1, 1) @[Validator.scala 126:47]
              _flags_WIRE_6.write <= _flags_T_7 @[Validator.scala 126:47]
              node _flags_T_8 = bits(_flags_WIRE_7, 2, 2) @[Validator.scala 126:47]
              _flags_WIRE_6.accumulate <= _flags_T_8 @[Validator.scala 126:47]
              node _flags_T_9 = bits(_flags_WIRE_7, 3, 3) @[Validator.scala 126:47]
              _flags_WIRE_6._unused <= _flags_T_9 @[Validator.scala 126:47]
              flags_3.read <= _flags_WIRE_6.read @[Validator.scala 126:13]
              flags_3.write <= _flags_WIRE_6.write @[Validator.scala 126:13]
              flags_3.accumulate <= _flags_WIRE_6.accumulate @[Validator.scala 126:13]
              flags_3._unused <= _flags_WIRE_6._unused @[Validator.scala 126:13]
              wire _args_WIRE_6 : {_unused : UInt<1>, instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Validator.scala 127:50]
              wire _args_WIRE_7 : UInt<48>
              _args_WIRE_7 <= io.instruction.bits.arguments
              node _args_T_18 = bits(_args_WIRE_7, 15, 0) @[Validator.scala 127:50]
              _args_WIRE_6.accWriteAddress <= _args_T_18 @[Validator.scala 127:50]
              node _args_T_19 = bits(_args_WIRE_7, 39, 16) @[Validator.scala 127:50]
              _args_WIRE_6.accReadAddress <= _args_T_19 @[Validator.scala 127:50]
              node _args_T_20 = bits(_args_WIRE_7, 40, 40) @[Validator.scala 127:50]
              _args_WIRE_6.instruction.dest <= _args_T_20 @[Validator.scala 127:50]
              node _args_T_21 = bits(_args_WIRE_7, 41, 41) @[Validator.scala 127:50]
              _args_WIRE_6.instruction.sourceRight <= _args_T_21 @[Validator.scala 127:50]
              node _args_T_22 = bits(_args_WIRE_7, 42, 42) @[Validator.scala 127:50]
              _args_WIRE_6.instruction.sourceLeft <= _args_T_22 @[Validator.scala 127:50]
              node _args_T_23 = bits(_args_WIRE_7, 46, 43) @[Validator.scala 127:50]
              _args_WIRE_6.instruction.op <= _args_T_23 @[Validator.scala 127:50]
              node _args_T_24 = bits(_args_WIRE_7, 47, 47) @[Validator.scala 127:50]
              _args_WIRE_6._unused <= _args_T_24 @[Validator.scala 127:50]
              args_3.accWriteAddress <= _args_WIRE_6.accWriteAddress @[Validator.scala 127:12]
              args_3.accReadAddress <= _args_WIRE_6.accReadAddress @[Validator.scala 127:12]
              args_3.instruction.dest <= _args_WIRE_6.instruction.dest @[Validator.scala 127:12]
              args_3.instruction.sourceRight <= _args_WIRE_6.instruction.sourceRight @[Validator.scala 127:12]
              args_3.instruction.sourceLeft <= _args_WIRE_6.instruction.sourceLeft @[Validator.scala 127:12]
              args_3.instruction.op <= _args_WIRE_6.instruction.op @[Validator.scala 127:12]
              args_3._unused <= _args_WIRE_6._unused @[Validator.scala 127:12]
              node _T_46 = geq(args_3.accReadAddress, UInt<7>("h040")) @[Validator.scala 129:32]
              when _T_46 : @[Validator.scala 129:67]
                io.error <= UInt<1>("h01") @[Validator.scala 130:18]
                skip @[Validator.scala 129:67]
              else : @[Validator.scala 131:74]
                node _T_47 = geq(args_3.accWriteAddress, UInt<7>("h040")) @[Validator.scala 131:39]
                when _T_47 : @[Validator.scala 131:74]
                  io.error <= UInt<1>("h01") @[Validator.scala 132:18]
                  skip @[Validator.scala 131:74]
                else : @[Validator.scala 133:59]
                  node _T_48 = geq(args_3.instruction.op, UInt<5>("h010")) @[Validator.scala 133:38]
                  when _T_48 : @[Validator.scala 133:59]
                    io.error <= UInt<1>("h01") @[Validator.scala 134:18]
                    skip @[Validator.scala 133:59]
                  else : @[Validator.scala 137:9]
                    node _T_49 = gt(args_3.instruction.sourceLeft, UInt<1>("h01")) @[Validator.scala 136:37]
                    when _T_49 : @[Validator.scala 137:9]
                      io.error <= UInt<1>("h01") @[Validator.scala 138:18]
                      skip @[Validator.scala 137:9]
                    else : @[Validator.scala 141:9]
                      node _T_50 = gt(args_3.instruction.sourceRight, UInt<1>("h01")) @[Validator.scala 140:38]
                      when _T_50 : @[Validator.scala 141:9]
                        io.error <= UInt<1>("h01") @[Validator.scala 142:18]
                        skip @[Validator.scala 141:9]
                      else : @[Validator.scala 143:76]
                        node _T_51 = gt(args_3.instruction.dest, UInt<1>("h01")) @[Validator.scala 143:40]
                        when _T_51 : @[Validator.scala 143:76]
                          io.error <= UInt<1>("h01") @[Validator.scala 144:18]
                          skip @[Validator.scala 143:76]
                        else : @[Validator.scala 145:41]
                          node _T_52 = neq(flags_3._unused, UInt<1>("h00")) @[Validator.scala 145:32]
                          when _T_52 : @[Validator.scala 145:41]
                            io.error <= UInt<1>("h01") @[Validator.scala 146:18]
                            skip @[Validator.scala 145:41]
                          else : @[Validator.scala 149:9]
                            node _T_53 = eq(args_3.instruction.sourceLeft, UInt<1>("h00")) @[Validator.scala 148:53]
                            node _T_54 = eq(args_3.instruction.sourceRight, UInt<1>("h00")) @[Validator.scala 148:93]
                            node _T_55 = or(_T_53, _T_54) @[Validator.scala 148:61]
                            node _T_56 = eq(_T_55, UInt<1>("h00")) @[Validator.scala 148:23]
                            node _T_57 = and(flags_3.read, _T_56) @[Validator.scala 148:20]
                            when _T_57 : @[Validator.scala 149:9]
                              io.error <= UInt<1>("h01") @[Validator.scala 152:18]
                              skip @[Validator.scala 149:9]
                            else : @[Validator.scala 155:9]
                              node _T_58 = eq(flags_3.read, UInt<1>("h00")) @[Validator.scala 154:9]
                              node _T_59 = eq(args_3.instruction.sourceLeft, UInt<1>("h00")) @[Validator.scala 154:53]
                              node _T_60 = eq(args_3.instruction.sourceRight, UInt<1>("h00")) @[Validator.scala 154:93]
                              node _T_61 = or(_T_59, _T_60) @[Validator.scala 154:61]
                              node _T_62 = and(_T_58, _T_61) @[Validator.scala 154:21]
                              when _T_62 : @[Validator.scala 155:9]
                                io.error <= UInt<1>("h01") @[Validator.scala 159:18]
                                skip @[Validator.scala 155:9]
                              else : @[Validator.scala 160:19]
                                io.error <= UInt<1>("h00") @[Validator.scala 161:18]
                                skip @[Validator.scala 160:19]
              skip @[Validator.scala 122:57]
            else : @[Validator.scala 163:62]
              node _T_63 = eq(io.instruction.bits.opcode, UInt<4>("h0f")) @[Validator.scala 163:40]
              when _T_63 : @[Validator.scala 163:62]
                io.error <= UInt<1>("h00") @[Validator.scala 164:16]
                skip @[Validator.scala 163:62]
              else : @[Validator.scala 165:57]
                node _T_64 = eq(io.instruction.bits.opcode, UInt<1>("h00")) @[Validator.scala 165:40]
                when _T_64 : @[Validator.scala 165:57]
                  io.error <= UInt<1>("h00") @[Validator.scala 166:16]
                  skip @[Validator.scala 165:57]
                else : @[Validator.scala 167:17]
                  io.error <= UInt<1>("h01") @[Validator.scala 168:16]
                  skip @[Validator.scala 167:17]
      skip @[Validator.scala 33:27]
    else : @[Validator.scala 170:15]
      io.error <= UInt<1>("h00") @[Validator.scala 171:14]
      skip @[Validator.scala 170:15]
    
  module Decoder : 
    input clock : Clock
    input reset : Reset
    output io : {flip instruction : {flip ready : UInt<1>, valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}, memPortA : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, memPortB : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, dram0 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dram1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataflow : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}}, hostDataflow : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>}}, acc : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, array : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>}}, config : {dram0AddressOffset : UInt<32>, dram0CacheBehaviour : UInt<4>, dram1AddressOffset : UInt<32>, dram1CacheBehaviour : UInt<4>}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}}, timeout : UInt<1>, error : UInt<1>, tracepoint : UInt<1>, programCounter : UInt<32>, sample : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {flags : {instruction : {ready : UInt<1>, valid : UInt<1>}, memPortA : {ready : UInt<1>, valid : UInt<1>}, memPortB : {ready : UInt<1>, valid : UInt<1>}, dram0 : {ready : UInt<1>, valid : UInt<1>}, dram1 : {ready : UInt<1>, valid : UInt<1>}, dataflow : {ready : UInt<1>, valid : UInt<1>}, acc : {ready : UInt<1>, valid : UInt<1>}, array : {ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}, skipped : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, nooped : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}}
    
    inst instruction of Queue @[Decoupled.scala 296:21]
    instruction.clock <= clock
    instruction.reset <= reset
    instruction.io.enq.valid <= io.instruction.valid @[Decoupled.scala 297:22]
    instruction.io.enq.bits.arguments <= io.instruction.bits.arguments @[Decoupled.scala 298:21]
    instruction.io.enq.bits.flags <= io.instruction.bits.flags @[Decoupled.scala 298:21]
    instruction.io.enq.bits.opcode <= io.instruction.bits.opcode @[Decoupled.scala 298:21]
    io.instruction.ready <= instruction.io.enq.ready @[Decoupled.scala 299:17]
    inst status of Queue_1 @[Decoder.scala 78:23]
    status.clock <= clock
    status.reset <= reset
    node _status_io_enq_valid_T = and(instruction.io.deq.valid, instruction.io.deq.ready) @[Decoder.scala 85:44]
    status.io.enq.valid <= _status_io_enq_valid_T @[Decoder.scala 85:23]
    status.io.enq.bits.bits.arguments <= instruction.io.deq.bits.arguments @[Decoder.scala 86:27]
    status.io.enq.bits.bits.flags <= instruction.io.deq.bits.flags @[Decoder.scala 86:27]
    status.io.enq.bits.bits.opcode <= instruction.io.deq.bits.opcode @[Decoder.scala 86:27]
    status.io.enq.bits.last <= UInt<1>("h01") @[Decoder.scala 87:27]
    io.status.bits.bits.arguments <= status.io.deq.bits.bits.arguments @[Decoder.scala 88:13]
    io.status.bits.bits.flags <= status.io.deq.bits.bits.flags @[Decoder.scala 88:13]
    io.status.bits.bits.opcode <= status.io.deq.bits.bits.opcode @[Decoder.scala 88:13]
    io.status.bits.last <= status.io.deq.bits.last @[Decoder.scala 88:13]
    io.status.valid <= status.io.deq.valid @[Decoder.scala 88:13]
    status.io.deq.ready <= io.status.ready @[Decoder.scala 88:13]
    reg timeout : UInt<16>, clock with : (reset => (reset, UInt<16>("h064"))) @[Decoder.scala 91:24]
    reg timer : UInt<16>, clock with : (reset => (reset, UInt<16>("h00"))) @[Decoder.scala 92:24]
    when instruction.io.deq.ready : @[Decoder.scala 93:27]
      timer <= UInt<1>("h00") @[Decoder.scala 94:11]
      skip @[Decoder.scala 93:27]
    else : @[Decoder.scala 95:15]
      node _T = lt(timer, timeout) @[Decoder.scala 96:16]
      when _T : @[Decoder.scala 96:27]
        node _timer_T = add(timer, UInt<1>("h01")) @[Decoder.scala 97:22]
        node _timer_T_1 = tail(_timer_T, 1) @[Decoder.scala 97:22]
        timer <= _timer_T_1 @[Decoder.scala 97:13]
        skip @[Decoder.scala 96:27]
      skip @[Decoder.scala 95:15]
    node _io_timeout_T = eq(timer, timeout) @[Decoder.scala 100:23]
    io.timeout <= _io_timeout_T @[Decoder.scala 100:14]
    reg tracepoint : UInt<32>, clock with : (reset => (reset, UInt<32>("h0ffffffff"))) @[Decoder.scala 103:31]
    reg programCounter : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Decoder.scala 104:31]
    node _T_1 = and(instruction.io.deq.ready, instruction.io.deq.valid) @[Decoder.scala 105:26]
    when _T_1 : @[Decoder.scala 105:48]
      node _programCounter_T = add(programCounter, UInt<1>("h01")) @[Decoder.scala 106:38]
      node _programCounter_T_1 = tail(_programCounter_T, 1) @[Decoder.scala 106:38]
      programCounter <= _programCounter_T_1 @[Decoder.scala 106:20]
      skip @[Decoder.scala 105:48]
    node _io_tracepoint_T = eq(programCounter, tracepoint) @[Decoder.scala 108:35]
    io.tracepoint <= _io_tracepoint_T @[Decoder.scala 108:17]
    io.programCounter <= programCounter @[Decoder.scala 109:21]
    reg sampleInterval : UInt<16>, clock with : (reset => (reset, UInt<16>("h00"))) @[Decoder.scala 112:31]
    io.nooped.bits <= UInt<1>("h01") @[Decoder.scala 114:18]
    io.nooped.valid <= UInt<1>("h00") @[Decoder.scala 115:19]
    io.skipped.bits <= UInt<1>("h01") @[Decoder.scala 116:19]
    io.skipped.valid <= UInt<1>("h00") @[Decoder.scala 117:20]
    reg dram0AddressOffset : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Decoder.scala 121:36]
    reg dram0CacheBehaviour : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Decoder.scala 122:36]
    reg dram1AddressOffset : UInt<32>, clock with : (reset => (reset, UInt<32>("h00"))) @[Decoder.scala 123:36]
    reg dram1CacheBehaviour : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Decoder.scala 124:36]
    io.config.dram0AddressOffset <= dram0AddressOffset @[Decoder.scala 126:32]
    io.config.dram0CacheBehaviour <= dram0CacheBehaviour @[Decoder.scala 127:33]
    io.config.dram1AddressOffset <= dram1AddressOffset @[Decoder.scala 128:32]
    io.config.dram1CacheBehaviour <= dram1CacheBehaviour @[Decoder.scala 129:33]
    inst dram0Handler of StrideHandler @[Decoder.scala 135:28]
    dram0Handler.clock <= clock
    dram0Handler.reset <= reset
    inst dram1Handler of StrideHandler_1 @[Decoder.scala 144:28]
    dram1Handler.clock <= clock
    dram1Handler.reset <= reset
    io.dram0.bits.size <= dram0Handler.io.out.bits.size @[Decoder.scala 153:12]
    io.dram0.bits.address <= dram0Handler.io.out.bits.address @[Decoder.scala 153:12]
    io.dram0.bits.write <= dram0Handler.io.out.bits.write @[Decoder.scala 153:12]
    io.dram0.valid <= dram0Handler.io.out.valid @[Decoder.scala 153:12]
    dram0Handler.io.out.ready <= io.dram0.ready @[Decoder.scala 153:12]
    io.dram1.bits.size <= dram1Handler.io.out.bits.size @[Decoder.scala 154:12]
    io.dram1.bits.address <= dram1Handler.io.out.bits.address @[Decoder.scala 154:12]
    io.dram1.bits.write <= dram1Handler.io.out.bits.write @[Decoder.scala 154:12]
    io.dram1.valid <= dram1Handler.io.out.valid @[Decoder.scala 154:12]
    dram1Handler.io.out.ready <= io.dram1.ready @[Decoder.scala 154:12]
    inst memPortAHandler of SizeAndStrideHandler_2 @[Decoder.scala 160:31]
    memPortAHandler.clock <= clock
    memPortAHandler.reset <= reset
    inst memPortBHandler of SizeAndStrideHandler_3 @[Decoder.scala 169:31]
    memPortBHandler.clock <= clock
    memPortBHandler.reset <= reset
    io.memPortA.bits.size <= memPortAHandler.io.out.bits.size @[Decoder.scala 178:15]
    io.memPortA.bits.address <= memPortAHandler.io.out.bits.address @[Decoder.scala 178:15]
    io.memPortA.bits.write <= memPortAHandler.io.out.bits.write @[Decoder.scala 178:15]
    io.memPortA.valid <= memPortAHandler.io.out.valid @[Decoder.scala 178:15]
    memPortAHandler.io.out.ready <= io.memPortA.ready @[Decoder.scala 178:15]
    io.memPortB.bits.size <= memPortBHandler.io.out.bits.size @[Decoder.scala 179:15]
    io.memPortB.bits.address <= memPortBHandler.io.out.bits.address @[Decoder.scala 179:15]
    io.memPortB.bits.write <= memPortBHandler.io.out.bits.write @[Decoder.scala 179:15]
    io.memPortB.valid <= memPortBHandler.io.out.valid @[Decoder.scala 179:15]
    memPortBHandler.io.out.ready <= io.memPortB.ready @[Decoder.scala 179:15]
    inst memPortA of Queue_2 @[Mem.scala 23:19]
    memPortA.clock <= clock
    memPortA.reset <= reset
    memPortAHandler.io.in.bits.reverse <= memPortA.io.deq.bits.reverse @[Mem.scala 24:7]
    memPortAHandler.io.in.bits.stride <= memPortA.io.deq.bits.stride @[Mem.scala 24:7]
    memPortAHandler.io.in.bits.size <= memPortA.io.deq.bits.size @[Mem.scala 24:7]
    memPortAHandler.io.in.bits.address <= memPortA.io.deq.bits.address @[Mem.scala 24:7]
    memPortAHandler.io.in.bits.write <= memPortA.io.deq.bits.write @[Mem.scala 24:7]
    memPortAHandler.io.in.valid <= memPortA.io.deq.valid @[Mem.scala 24:7]
    memPortA.io.deq.ready <= memPortAHandler.io.in.ready @[Mem.scala 24:7]
    inst memPortB of Queue_3 @[Mem.scala 23:19]
    memPortB.clock <= clock
    memPortB.reset <= reset
    memPortBHandler.io.in.bits.reverse <= memPortB.io.deq.bits.reverse @[Mem.scala 24:7]
    memPortBHandler.io.in.bits.stride <= memPortB.io.deq.bits.stride @[Mem.scala 24:7]
    memPortBHandler.io.in.bits.size <= memPortB.io.deq.bits.size @[Mem.scala 24:7]
    memPortBHandler.io.in.bits.address <= memPortB.io.deq.bits.address @[Mem.scala 24:7]
    memPortBHandler.io.in.bits.write <= memPortB.io.deq.bits.write @[Mem.scala 24:7]
    memPortBHandler.io.in.valid <= memPortB.io.deq.valid @[Mem.scala 24:7]
    memPortB.io.deq.ready <= memPortBHandler.io.in.ready @[Mem.scala 24:7]
    inst accHandler of SizeAndStrideHandler_4 @[Decoder.scala 185:26]
    accHandler.clock <= clock
    accHandler.reset <= reset
    wire io_acc_bits_w : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[AccumulatorWithALUArrayControl.scala 96:17]
    node io_acc_bits_isMemControl = eq(accHandler.io.out.bits.instruction.op, UInt<1>("h00")) @[AccumulatorWithALUArrayControl.scala 101:39]
    io_acc_bits_w.instruction.dest <= accHandler.io.out.bits.instruction.dest @[AccumulatorWithALUArrayControl.scala 102:19]
    io_acc_bits_w.instruction.sourceRight <= accHandler.io.out.bits.instruction.sourceRight @[AccumulatorWithALUArrayControl.scala 102:19]
    io_acc_bits_w.instruction.sourceLeft <= accHandler.io.out.bits.instruction.sourceLeft @[AccumulatorWithALUArrayControl.scala 102:19]
    io_acc_bits_w.instruction.op <= accHandler.io.out.bits.instruction.op @[AccumulatorWithALUArrayControl.scala 102:19]
    io_acc_bits_w.read <= accHandler.io.out.bits.read @[AccumulatorWithALUArrayControl.scala 103:12]
    io_acc_bits_w.write <= accHandler.io.out.bits.write @[AccumulatorWithALUArrayControl.scala 104:13]
    io_acc_bits_w.accumulate <= accHandler.io.out.bits.accumulate @[AccumulatorWithALUArrayControl.scala 105:18]
    when io_acc_bits_isMemControl : @[AccumulatorWithALUArrayControl.scala 106:24]
      when accHandler.io.out.bits.read : @[AccumulatorWithALUArrayControl.scala 107:18]
        io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 108:23]
        io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 109:24]
        skip @[AccumulatorWithALUArrayControl.scala 107:18]
      else : @[AccumulatorWithALUArrayControl.scala 110:19]
        when accHandler.io.out.bits.write : @[AccumulatorWithALUArrayControl.scala 111:21]
          io_acc_bits_w.readAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 112:25]
          io_acc_bits_w.writeAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 113:26]
          skip @[AccumulatorWithALUArrayControl.scala 111:21]
        else : @[AccumulatorWithALUArrayControl.scala 114:21]
          io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 115:25]
          io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 116:26]
          skip @[AccumulatorWithALUArrayControl.scala 114:21]
        skip @[AccumulatorWithALUArrayControl.scala 110:19]
      skip @[AccumulatorWithALUArrayControl.scala 106:24]
    else : @[AccumulatorWithALUArrayControl.scala 119:17]
      io_acc_bits_w.readAddress <= accHandler.io.out.bits.address @[AccumulatorWithALUArrayControl.scala 120:21]
      io_acc_bits_w.writeAddress <= accHandler.io.out.bits.altAddress @[AccumulatorWithALUArrayControl.scala 121:22]
      skip @[AccumulatorWithALUArrayControl.scala 119:17]
    io.acc.bits.read <= io_acc_bits_w.read @[Decoder.scala 195:15]
    io.acc.bits.write <= io_acc_bits_w.write @[Decoder.scala 195:15]
    io.acc.bits.accumulate <= io_acc_bits_w.accumulate @[Decoder.scala 195:15]
    io.acc.bits.writeAddress <= io_acc_bits_w.writeAddress @[Decoder.scala 195:15]
    io.acc.bits.readAddress <= io_acc_bits_w.readAddress @[Decoder.scala 195:15]
    io.acc.bits.instruction.dest <= io_acc_bits_w.instruction.dest @[Decoder.scala 195:15]
    io.acc.bits.instruction.sourceRight <= io_acc_bits_w.instruction.sourceRight @[Decoder.scala 195:15]
    io.acc.bits.instruction.sourceLeft <= io_acc_bits_w.instruction.sourceLeft @[Decoder.scala 195:15]
    io.acc.bits.instruction.op <= io_acc_bits_w.instruction.op @[Decoder.scala 195:15]
    io.acc.valid <= accHandler.io.out.valid @[Decoder.scala 196:16]
    accHandler.io.out.ready <= io.acc.ready @[Decoder.scala 197:27]
    inst arrayHandler of SizeHandler @[Decoder.scala 202:28]
    arrayHandler.clock <= clock
    arrayHandler.reset <= reset
    io.array.bits.zeroes <= arrayHandler.io.out.bits.zeroes @[Decoder.scala 211:12]
    io.array.bits.load <= arrayHandler.io.out.bits.load @[Decoder.scala 211:12]
    io.array.valid <= arrayHandler.io.out.valid @[Decoder.scala 211:12]
    arrayHandler.io.out.ready <= io.array.ready @[Decoder.scala 211:12]
    inst hostDataflowHandler of SizeHandler_1 @[Decoder.scala 216:35]
    hostDataflowHandler.clock <= clock
    hostDataflowHandler.reset <= reset
    io.hostDataflow.bits.kind <= hostDataflowHandler.io.out.bits.kind @[Decoder.scala 223:19]
    io.hostDataflow.valid <= hostDataflowHandler.io.out.valid @[Decoder.scala 223:19]
    hostDataflowHandler.io.out.ready <= io.hostDataflow.ready @[Decoder.scala 223:19]
    wire _memPortA_io_enq_bits_WIRE : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _memPortA_io_enq_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _memPortA_io_enq_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _memPortA_io_enq_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _memPortA_io_enq_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    _memPortA_io_enq_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    memPortA.io.enq.bits.reverse <= _memPortA_io_enq_bits_WIRE.reverse @[Decoder.scala 609:15]
    memPortA.io.enq.bits.stride <= _memPortA_io_enq_bits_WIRE.stride @[Decoder.scala 609:15]
    memPortA.io.enq.bits.size <= _memPortA_io_enq_bits_WIRE.size @[Decoder.scala 609:15]
    memPortA.io.enq.bits.address <= _memPortA_io_enq_bits_WIRE.address @[Decoder.scala 609:15]
    memPortA.io.enq.bits.write <= _memPortA_io_enq_bits_WIRE.write @[Decoder.scala 609:15]
    memPortA.io.enq.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _memPortB_io_enq_bits_WIRE : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _memPortB_io_enq_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _memPortB_io_enq_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _memPortB_io_enq_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _memPortB_io_enq_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    _memPortB_io_enq_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    memPortB.io.enq.bits.reverse <= _memPortB_io_enq_bits_WIRE.reverse @[Decoder.scala 609:15]
    memPortB.io.enq.bits.stride <= _memPortB_io_enq_bits_WIRE.stride @[Decoder.scala 609:15]
    memPortB.io.enq.bits.size <= _memPortB_io_enq_bits_WIRE.size @[Decoder.scala 609:15]
    memPortB.io.enq.bits.address <= _memPortB_io_enq_bits_WIRE.address @[Decoder.scala 609:15]
    memPortB.io.enq.bits.write <= _memPortB_io_enq_bits_WIRE.write @[Decoder.scala 609:15]
    memPortB.io.enq.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _io_dataflow_bits_WIRE : {kind : UInt<4>, size : UInt<6>} @[package.scala 80:57]
    _io_dataflow_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _io_dataflow_bits_WIRE.kind <= UInt<4>("h00") @[package.scala 80:57]
    io.dataflow.bits.size <= _io_dataflow_bits_WIRE.size @[Decoder.scala 609:15]
    io.dataflow.bits.kind <= _io_dataflow_bits_WIRE.kind @[Decoder.scala 609:15]
    io.dataflow.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _hostDataflowHandler_io_in_bits_WIRE : {kind : UInt<2>, size : UInt<6>} @[package.scala 80:57]
    _hostDataflowHandler_io_in_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _hostDataflowHandler_io_in_bits_WIRE.kind <= UInt<2>("h00") @[package.scala 80:57]
    hostDataflowHandler.io.in.bits.size <= _hostDataflowHandler_io_in_bits_WIRE.size @[Decoder.scala 609:15]
    hostDataflowHandler.io.in.bits.kind <= _hostDataflowHandler_io_in_bits_WIRE.kind @[Decoder.scala 609:15]
    hostDataflowHandler.io.in.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _accHandler_io_in_bits_WIRE : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.accumulate <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.read <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.altAddress <= UInt<6>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.instruction.dest <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.instruction.sourceRight <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.instruction.sourceLeft <= UInt<1>("h00") @[package.scala 80:57]
    _accHandler_io_in_bits_WIRE.instruction.op <= UInt<4>("h00") @[package.scala 80:57]
    accHandler.io.in.bits.reverse <= _accHandler_io_in_bits_WIRE.reverse @[Decoder.scala 609:15]
    accHandler.io.in.bits.stride <= _accHandler_io_in_bits_WIRE.stride @[Decoder.scala 609:15]
    accHandler.io.in.bits.size <= _accHandler_io_in_bits_WIRE.size @[Decoder.scala 609:15]
    accHandler.io.in.bits.accumulate <= _accHandler_io_in_bits_WIRE.accumulate @[Decoder.scala 609:15]
    accHandler.io.in.bits.write <= _accHandler_io_in_bits_WIRE.write @[Decoder.scala 609:15]
    accHandler.io.in.bits.read <= _accHandler_io_in_bits_WIRE.read @[Decoder.scala 609:15]
    accHandler.io.in.bits.altAddress <= _accHandler_io_in_bits_WIRE.altAddress @[Decoder.scala 609:15]
    accHandler.io.in.bits.address <= _accHandler_io_in_bits_WIRE.address @[Decoder.scala 609:15]
    accHandler.io.in.bits.instruction.dest <= _accHandler_io_in_bits_WIRE.instruction.dest @[Decoder.scala 609:15]
    accHandler.io.in.bits.instruction.sourceRight <= _accHandler_io_in_bits_WIRE.instruction.sourceRight @[Decoder.scala 609:15]
    accHandler.io.in.bits.instruction.sourceLeft <= _accHandler_io_in_bits_WIRE.instruction.sourceLeft @[Decoder.scala 609:15]
    accHandler.io.in.bits.instruction.op <= _accHandler_io_in_bits_WIRE.instruction.op @[Decoder.scala 609:15]
    accHandler.io.in.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _arrayHandler_io_in_bits_WIRE : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>} @[package.scala 80:57]
    _arrayHandler_io_in_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _arrayHandler_io_in_bits_WIRE.zeroes <= UInt<1>("h00") @[package.scala 80:57]
    _arrayHandler_io_in_bits_WIRE.load <= UInt<1>("h00") @[package.scala 80:57]
    arrayHandler.io.in.bits.size <= _arrayHandler_io_in_bits_WIRE.size @[Decoder.scala 609:15]
    arrayHandler.io.in.bits.zeroes <= _arrayHandler_io_in_bits_WIRE.zeroes @[Decoder.scala 609:15]
    arrayHandler.io.in.bits.load <= _arrayHandler_io_in_bits_WIRE.load @[Decoder.scala 609:15]
    arrayHandler.io.in.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _dram0Handler_io_in_bits_WIRE : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _dram0Handler_io_in_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _dram0Handler_io_in_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _dram0Handler_io_in_bits_WIRE.size <= UInt<20>("h00") @[package.scala 80:57]
    _dram0Handler_io_in_bits_WIRE.address <= UInt<20>("h00") @[package.scala 80:57]
    _dram0Handler_io_in_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    dram0Handler.io.in.bits.reverse <= _dram0Handler_io_in_bits_WIRE.reverse @[Decoder.scala 609:15]
    dram0Handler.io.in.bits.stride <= _dram0Handler_io_in_bits_WIRE.stride @[Decoder.scala 609:15]
    dram0Handler.io.in.bits.size <= _dram0Handler_io_in_bits_WIRE.size @[Decoder.scala 609:15]
    dram0Handler.io.in.bits.address <= _dram0Handler_io_in_bits_WIRE.address @[Decoder.scala 609:15]
    dram0Handler.io.in.bits.write <= _dram0Handler_io_in_bits_WIRE.write @[Decoder.scala 609:15]
    dram0Handler.io.in.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    wire _dram1Handler_io_in_bits_WIRE : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[package.scala 80:57]
    _dram1Handler_io_in_bits_WIRE.reverse <= UInt<1>("h00") @[package.scala 80:57]
    _dram1Handler_io_in_bits_WIRE.stride <= UInt<3>("h00") @[package.scala 80:57]
    _dram1Handler_io_in_bits_WIRE.size <= UInt<20>("h00") @[package.scala 80:57]
    _dram1Handler_io_in_bits_WIRE.address <= UInt<20>("h00") @[package.scala 80:57]
    _dram1Handler_io_in_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    dram1Handler.io.in.bits.reverse <= _dram1Handler_io_in_bits_WIRE.reverse @[Decoder.scala 609:15]
    dram1Handler.io.in.bits.stride <= _dram1Handler_io_in_bits_WIRE.stride @[Decoder.scala 609:15]
    dram1Handler.io.in.bits.size <= _dram1Handler_io_in_bits_WIRE.size @[Decoder.scala 609:15]
    dram1Handler.io.in.bits.address <= _dram1Handler_io_in_bits_WIRE.address @[Decoder.scala 609:15]
    dram1Handler.io.in.bits.write <= _dram1Handler_io_in_bits_WIRE.write @[Decoder.scala 609:15]
    dram1Handler.io.in.valid <= UInt<1>("h00") @[Decoder.scala 610:16]
    inst enqueuer1 of MultiEnqueue @[MultiEnqueue.scala 160:43]
    enqueuer1.clock <= clock
    enqueuer1.reset <= reset
    inst enqueuer2 of MultiEnqueue_1 @[MultiEnqueue.scala 160:43]
    enqueuer2.clock <= clock
    enqueuer2.reset <= reset
    inst enqueuer3 of MultiEnqueue_2 @[MultiEnqueue.scala 160:43]
    enqueuer3.clock <= clock
    enqueuer3.reset <= reset
    inst enqueuer4 of MultiEnqueue_3 @[MultiEnqueue.scala 160:43]
    enqueuer4.clock <= clock
    enqueuer4.reset <= reset
    enqueuer1.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer1.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer2.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer3.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer3.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer4.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer4.io.out[3].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    node _T_2 = eq(instruction.io.deq.bits.opcode, UInt<1>("h01")) @[Decoder.scala 244:32]
    when _T_2 : @[Decoder.scala 244:51]
      wire flags : {_unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Decoder.scala 245:21]
      wire args : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Decoder.scala 246:20]
      wire _flags_WIRE : {_unused : UInt<2>, zeroes : UInt<1>, accumulate : UInt<1>} @[Decoder.scala 250:45]
      wire _flags_WIRE_1 : UInt<4>
      _flags_WIRE_1 <= instruction.io.deq.bits.flags
      node _flags_T = bits(_flags_WIRE_1, 0, 0) @[Decoder.scala 250:45]
      _flags_WIRE.accumulate <= _flags_T @[Decoder.scala 250:45]
      node _flags_T_1 = bits(_flags_WIRE_1, 1, 1) @[Decoder.scala 250:45]
      _flags_WIRE.zeroes <= _flags_T_1 @[Decoder.scala 250:45]
      node _flags_T_2 = bits(_flags_WIRE_1, 3, 2) @[Decoder.scala 250:45]
      _flags_WIRE._unused <= _flags_T_2 @[Decoder.scala 250:45]
      flags.accumulate <= _flags_WIRE.accumulate @[Decoder.scala 250:11]
      flags.zeroes <= _flags_WIRE.zeroes @[Decoder.scala 250:11]
      flags._unused <= _flags_WIRE._unused @[Decoder.scala 250:11]
      wire _args_WIRE : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Decoder.scala 251:48]
      wire _args_WIRE_1 : UInt<48>
      _args_WIRE_1 <= instruction.io.deq.bits.arguments
      node _args_T = bits(_args_WIRE_1, 5, 0) @[Decoder.scala 251:48]
      _args_WIRE.memAddress <= _args_T @[Decoder.scala 251:48]
      node _args_T_1 = bits(_args_WIRE_1, 8, 6) @[Decoder.scala 251:48]
      _args_WIRE.memStride <= _args_T_1 @[Decoder.scala 251:48]
      node _args_T_2 = bits(_args_WIRE_1, 15, 9) @[Decoder.scala 251:48]
      _args_WIRE._unused0 <= _args_T_2 @[Decoder.scala 251:48]
      node _args_T_3 = bits(_args_WIRE_1, 35, 16) @[Decoder.scala 251:48]
      _args_WIRE.accAddress <= _args_T_3 @[Decoder.scala 251:48]
      node _args_T_4 = bits(_args_WIRE_1, 38, 36) @[Decoder.scala 251:48]
      _args_WIRE.accStride <= _args_T_4 @[Decoder.scala 251:48]
      node _args_T_5 = bits(_args_WIRE_1, 39, 39) @[Decoder.scala 251:48]
      _args_WIRE._unused1 <= _args_T_5 @[Decoder.scala 251:48]
      node _args_T_6 = bits(_args_WIRE_1, 47, 40) @[Decoder.scala 251:48]
      _args_WIRE.size <= _args_T_6 @[Decoder.scala 251:48]
      args.memAddress <= _args_WIRE.memAddress @[Decoder.scala 251:10]
      args.memStride <= _args_WIRE.memStride @[Decoder.scala 251:10]
      args._unused0 <= _args_WIRE._unused0 @[Decoder.scala 251:10]
      args.accAddress <= _args_WIRE.accAddress @[Decoder.scala 251:10]
      args.accStride <= _args_WIRE.accStride @[Decoder.scala 251:10]
      args._unused1 <= _args_WIRE._unused1 @[Decoder.scala 251:10]
      args.size <= _args_WIRE.size @[Decoder.scala 251:10]
      when flags.zeroes : @[Decoder.scala 253:24]
        wire instruction_io_deq_ready_w : {kind : UInt<4>, size : UInt<6>} @[Decoder.scala 673:17]
        instruction_io_deq_ready_w.kind <= UInt<2>("h03") @[Decoder.scala 674:12]
        instruction_io_deq_ready_w.size <= args.size @[Decoder.scala 675:12]
        wire instruction_io_deq_ready_w_1 : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>} @[Decoder.scala 684:17]
        instruction_io_deq_ready_w_1.load <= UInt<1>("h00") @[Decoder.scala 685:12]
        instruction_io_deq_ready_w_1.zeroes <= flags.zeroes @[Decoder.scala 686:14]
        instruction_io_deq_ready_w_1.size <= args.size @[Decoder.scala 687:12]
        wire instruction_io_deq_ready_w_2 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
        instruction_io_deq_ready_w_2.instruction.dest <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_2.instruction.sourceRight <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_2.instruction.sourceLeft <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_2.instruction.op <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_2.address <= args.accAddress @[Decoder.scala 658:15]
        instruction_io_deq_ready_w_2.altAddress <= UInt<1>("h00") @[Decoder.scala 659:18]
        instruction_io_deq_ready_w_2.accumulate <= flags.accumulate @[Decoder.scala 660:18]
        instruction_io_deq_ready_w_2.write <= UInt<1>("h01") @[Decoder.scala 661:13]
        instruction_io_deq_ready_w_2.read <= UInt<1>("h00") @[Decoder.scala 662:12]
        instruction_io_deq_ready_w_2.size <= args.size @[Decoder.scala 663:12]
        instruction_io_deq_ready_w_2.stride <= args.accStride @[Decoder.scala 664:14]
        instruction_io_deq_ready_w_2.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
        enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
        wire instruction_io_deq_ready_io_dataflow_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_io_dataflow_w.bits.size <= instruction_io_deq_ready_w.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_io_dataflow_w.bits.kind <= instruction_io_deq_ready_w.kind @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_io_dataflow_w.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w.ready @[ReadyValid.scala 19:11]
        io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w.bits.size @[MultiEnqueue.scala 115:10]
        io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w.bits.kind @[MultiEnqueue.scala 115:10]
        io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w.valid @[MultiEnqueue.scala 115:10]
        instruction_io_deq_ready_io_dataflow_w.ready <= io.dataflow.ready @[MultiEnqueue.scala 115:10]
        wire instruction_io_deq_ready_arrayHandler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_arrayHandler_io_in_w.bits.size <= instruction_io_deq_ready_w_1.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w.bits.zeroes <= instruction_io_deq_ready_w_1.zeroes @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w.bits.load <= instruction_io_deq_ready_w_1.load @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[1].ready <= instruction_io_deq_ready_arrayHandler_io_in_w.ready @[ReadyValid.scala 19:11]
        arrayHandler.io.in.bits.size <= instruction_io_deq_ready_arrayHandler_io_in_w.bits.size @[MultiEnqueue.scala 116:10]
        arrayHandler.io.in.bits.zeroes <= instruction_io_deq_ready_arrayHandler_io_in_w.bits.zeroes @[MultiEnqueue.scala 116:10]
        arrayHandler.io.in.bits.load <= instruction_io_deq_ready_arrayHandler_io_in_w.bits.load @[MultiEnqueue.scala 116:10]
        arrayHandler.io.in.valid <= instruction_io_deq_ready_arrayHandler_io_in_w.valid @[MultiEnqueue.scala 116:10]
        instruction_io_deq_ready_arrayHandler_io_in_w.ready <= arrayHandler.io.in.ready @[MultiEnqueue.scala 116:10]
        wire instruction_io_deq_ready_accHandler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_accHandler_io_in_w.bits.reverse <= instruction_io_deq_ready_w_2.reverse @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.stride <= instruction_io_deq_ready_w_2.stride @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.size <= instruction_io_deq_ready_w_2.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.accumulate <= instruction_io_deq_ready_w_2.accumulate @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.write <= instruction_io_deq_ready_w_2.write @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.read <= instruction_io_deq_ready_w_2.read @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.altAddress <= instruction_io_deq_ready_w_2.altAddress @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.address <= instruction_io_deq_ready_w_2.address @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.dest <= instruction_io_deq_ready_w_2.instruction.dest @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.sourceRight <= instruction_io_deq_ready_w_2.instruction.sourceRight @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_2.instruction.sourceLeft @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.op <= instruction_io_deq_ready_w_2.instruction.op @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
        enqueuer3.io.out[2].ready <= instruction_io_deq_ready_accHandler_io_in_w.ready @[ReadyValid.scala 19:11]
        accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w.bits.reverse @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w.bits.stride @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w.bits.size @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w.bits.accumulate @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w.bits.write @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w.bits.read @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w.bits.altAddress @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w.bits.address @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.dest @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.sourceRight @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.sourceLeft @[MultiEnqueue.scala 117:10]
        accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w.bits.instruction.op @[MultiEnqueue.scala 117:10]
        accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w.valid @[MultiEnqueue.scala 117:10]
        instruction_io_deq_ready_accHandler_io_in_w.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 117:10]
        instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 254:25]
        skip @[Decoder.scala 253:24]
      else : @[Decoder.scala 268:17]
        wire instruction_io_deq_ready_w_3 : {kind : UInt<4>, size : UInt<6>} @[Decoder.scala 673:17]
        instruction_io_deq_ready_w_3.kind <= UInt<2>("h02") @[Decoder.scala 674:12]
        instruction_io_deq_ready_w_3.size <= args.size @[Decoder.scala 675:12]
        wire instruction_io_deq_ready_w_4 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
        instruction_io_deq_ready_w_4.address <= args.memAddress @[MemControl.scala 40:17]
        instruction_io_deq_ready_w_4.size <= args.size @[MemControl.scala 41:14]
        instruction_io_deq_ready_w_4.stride <= args.memStride @[MemControl.scala 42:16]
        instruction_io_deq_ready_w_4.write <= UInt<1>("h00") @[MemControl.scala 43:15]
        instruction_io_deq_ready_w_4.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
        wire instruction_io_deq_ready_w_5 : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>} @[Decoder.scala 684:17]
        instruction_io_deq_ready_w_5.load <= UInt<1>("h00") @[Decoder.scala 685:12]
        instruction_io_deq_ready_w_5.zeroes <= flags.zeroes @[Decoder.scala 686:14]
        instruction_io_deq_ready_w_5.size <= args.size @[Decoder.scala 687:12]
        wire instruction_io_deq_ready_w_6 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
        instruction_io_deq_ready_w_6.instruction.dest <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_6.instruction.sourceRight <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_6.instruction.sourceLeft <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_6.instruction.op <= UInt<1>("h00") @[Decoder.scala 657:19]
        instruction_io_deq_ready_w_6.address <= args.accAddress @[Decoder.scala 658:15]
        instruction_io_deq_ready_w_6.altAddress <= UInt<1>("h00") @[Decoder.scala 659:18]
        instruction_io_deq_ready_w_6.accumulate <= flags.accumulate @[Decoder.scala 660:18]
        instruction_io_deq_ready_w_6.write <= UInt<1>("h01") @[Decoder.scala 661:13]
        instruction_io_deq_ready_w_6.read <= UInt<1>("h00") @[Decoder.scala 662:12]
        instruction_io_deq_ready_w_6.size <= args.size @[Decoder.scala 663:12]
        instruction_io_deq_ready_w_6.stride <= args.accStride @[Decoder.scala 664:14]
        instruction_io_deq_ready_w_6.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
        enqueuer4.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 150:17]
        wire instruction_io_deq_ready_io_dataflow_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_io_dataflow_w_1.bits.size <= instruction_io_deq_ready_w_3.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_io_dataflow_w_1.bits.kind <= instruction_io_deq_ready_w_3.kind @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_io_dataflow_w_1.valid <= enqueuer4.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer4.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w_1.ready @[ReadyValid.scala 19:11]
        io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w_1.bits.size @[MultiEnqueue.scala 151:10]
        io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w_1.bits.kind @[MultiEnqueue.scala 151:10]
        io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w_1.valid @[MultiEnqueue.scala 151:10]
        instruction_io_deq_ready_io_dataflow_w_1.ready <= io.dataflow.ready @[MultiEnqueue.scala 151:10]
        wire instruction_io_deq_ready_memPortA_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_memPortA_io_enq_w.bits.reverse <= instruction_io_deq_ready_w_4.reverse @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_memPortA_io_enq_w.bits.stride <= instruction_io_deq_ready_w_4.stride @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_memPortA_io_enq_w.bits.size <= instruction_io_deq_ready_w_4.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_memPortA_io_enq_w.bits.address <= instruction_io_deq_ready_w_4.address @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_memPortA_io_enq_w.bits.write <= instruction_io_deq_ready_w_4.write @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_memPortA_io_enq_w.valid <= enqueuer4.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer4.io.out[1].ready <= instruction_io_deq_ready_memPortA_io_enq_w.ready @[ReadyValid.scala 19:11]
        memPortA.io.enq.bits.reverse <= instruction_io_deq_ready_memPortA_io_enq_w.bits.reverse @[MultiEnqueue.scala 152:10]
        memPortA.io.enq.bits.stride <= instruction_io_deq_ready_memPortA_io_enq_w.bits.stride @[MultiEnqueue.scala 152:10]
        memPortA.io.enq.bits.size <= instruction_io_deq_ready_memPortA_io_enq_w.bits.size @[MultiEnqueue.scala 152:10]
        memPortA.io.enq.bits.address <= instruction_io_deq_ready_memPortA_io_enq_w.bits.address @[MultiEnqueue.scala 152:10]
        memPortA.io.enq.bits.write <= instruction_io_deq_ready_memPortA_io_enq_w.bits.write @[MultiEnqueue.scala 152:10]
        memPortA.io.enq.valid <= instruction_io_deq_ready_memPortA_io_enq_w.valid @[MultiEnqueue.scala 152:10]
        instruction_io_deq_ready_memPortA_io_enq_w.ready <= memPortA.io.enq.ready @[MultiEnqueue.scala 152:10]
        wire instruction_io_deq_ready_arrayHandler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.size <= instruction_io_deq_ready_w_5.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.zeroes <= instruction_io_deq_ready_w_5.zeroes @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.load <= instruction_io_deq_ready_w_5.load @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_arrayHandler_io_in_w_1.valid <= enqueuer4.io.out[2].valid @[ReadyValid.scala 18:13]
        enqueuer4.io.out[2].ready <= instruction_io_deq_ready_arrayHandler_io_in_w_1.ready @[ReadyValid.scala 19:11]
        arrayHandler.io.in.bits.size <= instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.size @[MultiEnqueue.scala 153:10]
        arrayHandler.io.in.bits.zeroes <= instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.zeroes @[MultiEnqueue.scala 153:10]
        arrayHandler.io.in.bits.load <= instruction_io_deq_ready_arrayHandler_io_in_w_1.bits.load @[MultiEnqueue.scala 153:10]
        arrayHandler.io.in.valid <= instruction_io_deq_ready_arrayHandler_io_in_w_1.valid @[MultiEnqueue.scala 153:10]
        instruction_io_deq_ready_arrayHandler_io_in_w_1.ready <= arrayHandler.io.in.ready @[MultiEnqueue.scala 153:10]
        wire instruction_io_deq_ready_accHandler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.reverse <= instruction_io_deq_ready_w_6.reverse @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.stride <= instruction_io_deq_ready_w_6.stride @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.size <= instruction_io_deq_ready_w_6.size @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.accumulate <= instruction_io_deq_ready_w_6.accumulate @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.write <= instruction_io_deq_ready_w_6.write @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.read <= instruction_io_deq_ready_w_6.read @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.altAddress <= instruction_io_deq_ready_w_6.altAddress @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.address <= instruction_io_deq_ready_w_6.address @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.dest <= instruction_io_deq_ready_w_6.instruction.dest @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.sourceRight <= instruction_io_deq_ready_w_6.instruction.sourceRight @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_6.instruction.sourceLeft @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.op <= instruction_io_deq_ready_w_6.instruction.op @[ReadyValid.scala 17:12]
        instruction_io_deq_ready_accHandler_io_in_w_1.valid <= enqueuer4.io.out[3].valid @[ReadyValid.scala 18:13]
        enqueuer4.io.out[3].ready <= instruction_io_deq_ready_accHandler_io_in_w_1.ready @[ReadyValid.scala 19:11]
        accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.reverse @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.stride @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.size @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.accumulate @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.write @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.read @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.altAddress @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.address @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.dest @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.sourceRight @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.sourceLeft @[MultiEnqueue.scala 154:10]
        accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w_1.bits.instruction.op @[MultiEnqueue.scala 154:10]
        accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w_1.valid @[MultiEnqueue.scala 154:10]
        instruction_io_deq_ready_accHandler_io_in_w_1.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 154:10]
        instruction.io.deq.ready <= enqueuer4.io.in.ready @[Decoder.scala 269:25]
        skip @[Decoder.scala 268:17]
      skip @[Decoder.scala 244:51]
    else : @[Decoder.scala 292:62]
      node _T_3 = eq(instruction.io.deq.bits.opcode, UInt<2>("h03")) @[Decoder.scala 292:38]
      when _T_3 : @[Decoder.scala 292:62]
        wire flags_1 : {_unused : UInt<3>, zeroes : UInt<1>} @[Decoder.scala 293:21]
        wire args_1 : {size : UInt<24>, _unused : UInt<7>, stride : UInt<3>, address : UInt<6>} @[Decoder.scala 295:11]
        wire _flags_WIRE_2 : {_unused : UInt<3>, zeroes : UInt<1>} @[Decoder.scala 299:45]
        wire _flags_WIRE_3 : UInt<4>
        _flags_WIRE_3 <= instruction.io.deq.bits.flags
        node _flags_T_3 = bits(_flags_WIRE_3, 0, 0) @[Decoder.scala 299:45]
        _flags_WIRE_2.zeroes <= _flags_T_3 @[Decoder.scala 299:45]
        node _flags_T_4 = bits(_flags_WIRE_3, 3, 1) @[Decoder.scala 299:45]
        _flags_WIRE_2._unused <= _flags_T_4 @[Decoder.scala 299:45]
        flags_1.zeroes <= _flags_WIRE_2.zeroes @[Decoder.scala 299:11]
        flags_1._unused <= _flags_WIRE_2._unused @[Decoder.scala 299:11]
        wire _args_WIRE_2 : {size : UInt<24>, _unused : UInt<7>, stride : UInt<3>, address : UInt<6>} @[Decoder.scala 300:48]
        wire _args_WIRE_3 : UInt<40>
        _args_WIRE_3 <= instruction.io.deq.bits.arguments
        node _args_T_7 = bits(_args_WIRE_3, 5, 0) @[Decoder.scala 300:48]
        _args_WIRE_2.address <= _args_T_7 @[Decoder.scala 300:48]
        node _args_T_8 = bits(_args_WIRE_3, 8, 6) @[Decoder.scala 300:48]
        _args_WIRE_2.stride <= _args_T_8 @[Decoder.scala 300:48]
        node _args_T_9 = bits(_args_WIRE_3, 15, 9) @[Decoder.scala 300:48]
        _args_WIRE_2._unused <= _args_T_9 @[Decoder.scala 300:48]
        node _args_T_10 = bits(_args_WIRE_3, 39, 16) @[Decoder.scala 300:48]
        _args_WIRE_2.size <= _args_T_10 @[Decoder.scala 300:48]
        args_1.address <= _args_WIRE_2.address @[Decoder.scala 300:10]
        args_1.stride <= _args_WIRE_2.stride @[Decoder.scala 300:10]
        args_1._unused <= _args_WIRE_2._unused @[Decoder.scala 300:10]
        args_1.size <= _args_WIRE_2.size @[Decoder.scala 300:10]
        when flags_1.zeroes : @[Decoder.scala 302:24]
          wire instruction_io_deq_ready_w_7 : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>} @[Decoder.scala 684:17]
          instruction_io_deq_ready_w_7.load <= UInt<1>("h01") @[Decoder.scala 685:12]
          instruction_io_deq_ready_w_7.zeroes <= flags_1.zeroes @[Decoder.scala 686:14]
          instruction_io_deq_ready_w_7.size <= args_1.size @[Decoder.scala 687:12]
          enqueuer1.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 60:17]
          wire instruction_io_deq_ready_arrayHandler_io_in_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.size <= instruction_io_deq_ready_w_7.size @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.zeroes <= instruction_io_deq_ready_w_7.zeroes @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.load <= instruction_io_deq_ready_w_7.load @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_2.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer1.io.out[0].ready <= instruction_io_deq_ready_arrayHandler_io_in_w_2.ready @[ReadyValid.scala 19:11]
          arrayHandler.io.in.bits.size <= instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.size @[MultiEnqueue.scala 61:10]
          arrayHandler.io.in.bits.zeroes <= instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.zeroes @[MultiEnqueue.scala 61:10]
          arrayHandler.io.in.bits.load <= instruction_io_deq_ready_arrayHandler_io_in_w_2.bits.load @[MultiEnqueue.scala 61:10]
          arrayHandler.io.in.valid <= instruction_io_deq_ready_arrayHandler_io_in_w_2.valid @[MultiEnqueue.scala 61:10]
          instruction_io_deq_ready_arrayHandler_io_in_w_2.ready <= arrayHandler.io.in.ready @[MultiEnqueue.scala 61:10]
          instruction.io.deq.ready <= enqueuer1.io.in.ready @[Decoder.scala 303:25]
          skip @[Decoder.scala 302:24]
        else : @[Decoder.scala 308:17]
          node stride = dshl(UInt<1>("h01"), args_1.stride) @[Decoder.scala 309:24]
          wire instruction_io_deq_ready_w_8 : {kind : UInt<4>, size : UInt<6>} @[LocalDataFlowControl.scala 28:19]
          instruction_io_deq_ready_w_8.kind <= UInt<1>("h01") @[LocalDataFlowControl.scala 29:14]
          instruction_io_deq_ready_w_8.size <= args_1.size @[LocalDataFlowControl.scala 30:14]
          wire instruction_io_deq_ready_w_9 : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>} @[Decoder.scala 684:17]
          instruction_io_deq_ready_w_9.load <= UInt<1>("h01") @[Decoder.scala 685:12]
          instruction_io_deq_ready_w_9.zeroes <= flags_1.zeroes @[Decoder.scala 686:14]
          instruction_io_deq_ready_w_9.size <= args_1.size @[Decoder.scala 687:12]
          node _instruction_io_deq_ready_T = mul(args_1.size, stride) @[Decoder.scala 321:37]
          node _instruction_io_deq_ready_T_1 = add(args_1.address, _instruction_io_deq_ready_T) @[Decoder.scala 321:24]
          node _instruction_io_deq_ready_T_2 = tail(_instruction_io_deq_ready_T_1, 1) @[Decoder.scala 321:24]
          wire instruction_io_deq_ready_w_10 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
          instruction_io_deq_ready_w_10.address <= _instruction_io_deq_ready_T_2 @[MemControl.scala 40:17]
          instruction_io_deq_ready_w_10.size <= args_1.size @[MemControl.scala 41:14]
          instruction_io_deq_ready_w_10.stride <= args_1.stride @[MemControl.scala 42:16]
          instruction_io_deq_ready_w_10.write <= UInt<1>("h00") @[MemControl.scala 43:15]
          instruction_io_deq_ready_w_10.reverse <= UInt<1>("h01") @[MemControl.scala 44:17]
          enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
          wire instruction_io_deq_ready_io_dataflow_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_io_dataflow_w_2.bits.size <= instruction_io_deq_ready_w_8.size @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_io_dataflow_w_2.bits.kind <= instruction_io_deq_ready_w_8.kind @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_io_dataflow_w_2.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer3.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w_2.ready @[ReadyValid.scala 19:11]
          io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w_2.bits.size @[MultiEnqueue.scala 115:10]
          io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w_2.bits.kind @[MultiEnqueue.scala 115:10]
          io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w_2.valid @[MultiEnqueue.scala 115:10]
          instruction_io_deq_ready_io_dataflow_w_2.ready <= io.dataflow.ready @[MultiEnqueue.scala 115:10]
          wire instruction_io_deq_ready_arrayHandler_io_in_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.size <= instruction_io_deq_ready_w_9.size @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.zeroes <= instruction_io_deq_ready_w_9.zeroes @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.load <= instruction_io_deq_ready_w_9.load @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_arrayHandler_io_in_w_3.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
          enqueuer3.io.out[1].ready <= instruction_io_deq_ready_arrayHandler_io_in_w_3.ready @[ReadyValid.scala 19:11]
          arrayHandler.io.in.bits.size <= instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.size @[MultiEnqueue.scala 116:10]
          arrayHandler.io.in.bits.zeroes <= instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.zeroes @[MultiEnqueue.scala 116:10]
          arrayHandler.io.in.bits.load <= instruction_io_deq_ready_arrayHandler_io_in_w_3.bits.load @[MultiEnqueue.scala 116:10]
          arrayHandler.io.in.valid <= instruction_io_deq_ready_arrayHandler_io_in_w_3.valid @[MultiEnqueue.scala 116:10]
          instruction_io_deq_ready_arrayHandler_io_in_w_3.ready <= arrayHandler.io.in.ready @[MultiEnqueue.scala 116:10]
          wire instruction_io_deq_ready_memPortA_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
          instruction_io_deq_ready_memPortA_io_enq_w_1.bits.reverse <= instruction_io_deq_ready_w_10.reverse @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_memPortA_io_enq_w_1.bits.stride <= instruction_io_deq_ready_w_10.stride @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_memPortA_io_enq_w_1.bits.size <= instruction_io_deq_ready_w_10.size @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_memPortA_io_enq_w_1.bits.address <= instruction_io_deq_ready_w_10.address @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_memPortA_io_enq_w_1.bits.write <= instruction_io_deq_ready_w_10.write @[ReadyValid.scala 17:12]
          instruction_io_deq_ready_memPortA_io_enq_w_1.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
          enqueuer3.io.out[2].ready <= instruction_io_deq_ready_memPortA_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          memPortA.io.enq.bits.reverse <= instruction_io_deq_ready_memPortA_io_enq_w_1.bits.reverse @[MultiEnqueue.scala 117:10]
          memPortA.io.enq.bits.stride <= instruction_io_deq_ready_memPortA_io_enq_w_1.bits.stride @[MultiEnqueue.scala 117:10]
          memPortA.io.enq.bits.size <= instruction_io_deq_ready_memPortA_io_enq_w_1.bits.size @[MultiEnqueue.scala 117:10]
          memPortA.io.enq.bits.address <= instruction_io_deq_ready_memPortA_io_enq_w_1.bits.address @[MultiEnqueue.scala 117:10]
          memPortA.io.enq.bits.write <= instruction_io_deq_ready_memPortA_io_enq_w_1.bits.write @[MultiEnqueue.scala 117:10]
          memPortA.io.enq.valid <= instruction_io_deq_ready_memPortA_io_enq_w_1.valid @[MultiEnqueue.scala 117:10]
          instruction_io_deq_ready_memPortA_io_enq_w_1.ready <= memPortA.io.enq.ready @[MultiEnqueue.scala 117:10]
          instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 310:25]
          skip @[Decoder.scala 308:17]
        skip @[Decoder.scala 292:62]
      else : @[Decoder.scala 329:59]
        node _T_4 = eq(instruction.io.deq.bits.opcode, UInt<2>("h02")) @[Decoder.scala 329:38]
        when _T_4 : @[Decoder.scala 329:59]
          wire args_2 : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Decoder.scala 331:11]
          wire flags_2 : {kind : UInt<4>} @[Decoder.scala 334:21]
          wire _args_WIRE_4 : {size : UInt<8>, _unused1 : UInt<1>, accStride : UInt<3>, accAddress : UInt<20>, _unused0 : UInt<7>, memStride : UInt<3>, memAddress : UInt<6>} @[Decoder.scala 336:48]
          wire _args_WIRE_5 : UInt<48>
          _args_WIRE_5 <= instruction.io.deq.bits.arguments
          node _args_T_11 = bits(_args_WIRE_5, 5, 0) @[Decoder.scala 336:48]
          _args_WIRE_4.memAddress <= _args_T_11 @[Decoder.scala 336:48]
          node _args_T_12 = bits(_args_WIRE_5, 8, 6) @[Decoder.scala 336:48]
          _args_WIRE_4.memStride <= _args_T_12 @[Decoder.scala 336:48]
          node _args_T_13 = bits(_args_WIRE_5, 15, 9) @[Decoder.scala 336:48]
          _args_WIRE_4._unused0 <= _args_T_13 @[Decoder.scala 336:48]
          node _args_T_14 = bits(_args_WIRE_5, 35, 16) @[Decoder.scala 336:48]
          _args_WIRE_4.accAddress <= _args_T_14 @[Decoder.scala 336:48]
          node _args_T_15 = bits(_args_WIRE_5, 38, 36) @[Decoder.scala 336:48]
          _args_WIRE_4.accStride <= _args_T_15 @[Decoder.scala 336:48]
          node _args_T_16 = bits(_args_WIRE_5, 39, 39) @[Decoder.scala 336:48]
          _args_WIRE_4._unused1 <= _args_T_16 @[Decoder.scala 336:48]
          node _args_T_17 = bits(_args_WIRE_5, 47, 40) @[Decoder.scala 336:48]
          _args_WIRE_4.size <= _args_T_17 @[Decoder.scala 336:48]
          args_2.memAddress <= _args_WIRE_4.memAddress @[Decoder.scala 336:10]
          args_2.memStride <= _args_WIRE_4.memStride @[Decoder.scala 336:10]
          args_2._unused0 <= _args_WIRE_4._unused0 @[Decoder.scala 336:10]
          args_2.accAddress <= _args_WIRE_4.accAddress @[Decoder.scala 336:10]
          args_2.accStride <= _args_WIRE_4.accStride @[Decoder.scala 336:10]
          args_2._unused1 <= _args_WIRE_4._unused1 @[Decoder.scala 336:10]
          args_2.size <= _args_WIRE_4.size @[Decoder.scala 336:10]
          wire _flags_WIRE_4 : {kind : UInt<4>} @[Decoder.scala 337:45]
          wire _flags_WIRE_5 : UInt<4>
          _flags_WIRE_5 <= instruction.io.deq.bits.flags
          node _flags_T_5 = bits(_flags_WIRE_5, 3, 0) @[Decoder.scala 337:45]
          _flags_WIRE_4.kind <= _flags_T_5 @[Decoder.scala 337:45]
          flags_2.kind <= _flags_WIRE_4.kind @[Decoder.scala 337:11]
          node _T_5 = eq(flags_2.kind, UInt<1>("h00")) @[Decoder.scala 339:21]
          when _T_5 : @[Decoder.scala 339:53]
            wire instruction_io_deq_ready_w_11 : {kind : UInt<2>, size : UInt<6>} @[HostRouter.scala 93:19]
            instruction_io_deq_ready_w_11.kind <= UInt<1>("h00") @[HostRouter.scala 94:14]
            instruction_io_deq_ready_w_11.size <= args_2.size @[HostRouter.scala 95:14]
            wire instruction_io_deq_ready_w_12 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
            instruction_io_deq_ready_w_12.address <= args_2.memAddress @[MemControl.scala 40:17]
            instruction_io_deq_ready_w_12.size <= args_2.size @[MemControl.scala 41:14]
            instruction_io_deq_ready_w_12.stride <= args_2.memStride @[MemControl.scala 42:16]
            instruction_io_deq_ready_w_12.write <= UInt<1>("h01") @[MemControl.scala 43:15]
            instruction_io_deq_ready_w_12.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
            wire instruction_io_deq_ready_w_13 : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
            instruction_io_deq_ready_w_13.address <= args_2.accAddress @[MemControl.scala 40:17]
            instruction_io_deq_ready_w_13.size <= args_2.size @[MemControl.scala 41:14]
            instruction_io_deq_ready_w_13.stride <= args_2.accStride @[MemControl.scala 42:16]
            instruction_io_deq_ready_w_13.write <= UInt<1>("h00") @[MemControl.scala 43:15]
            instruction_io_deq_ready_w_13.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
            enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
            wire instruction_io_deq_ready_hostDataflowHandler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_hostDataflowHandler_io_in_w.bits.size <= instruction_io_deq_ready_w_11.size @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_hostDataflowHandler_io_in_w.bits.kind <= instruction_io_deq_ready_w_11.kind @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_hostDataflowHandler_io_in_w.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer3.io.out[0].ready <= instruction_io_deq_ready_hostDataflowHandler_io_in_w.ready @[ReadyValid.scala 19:11]
            hostDataflowHandler.io.in.bits.size <= instruction_io_deq_ready_hostDataflowHandler_io_in_w.bits.size @[MultiEnqueue.scala 115:10]
            hostDataflowHandler.io.in.bits.kind <= instruction_io_deq_ready_hostDataflowHandler_io_in_w.bits.kind @[MultiEnqueue.scala 115:10]
            hostDataflowHandler.io.in.valid <= instruction_io_deq_ready_hostDataflowHandler_io_in_w.valid @[MultiEnqueue.scala 115:10]
            instruction_io_deq_ready_hostDataflowHandler_io_in_w.ready <= hostDataflowHandler.io.in.ready @[MultiEnqueue.scala 115:10]
            wire instruction_io_deq_ready_memPortB_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_memPortB_io_enq_w.bits.reverse <= instruction_io_deq_ready_w_12.reverse @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_memPortB_io_enq_w.bits.stride <= instruction_io_deq_ready_w_12.stride @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_memPortB_io_enq_w.bits.size <= instruction_io_deq_ready_w_12.size @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_memPortB_io_enq_w.bits.address <= instruction_io_deq_ready_w_12.address @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_memPortB_io_enq_w.bits.write <= instruction_io_deq_ready_w_12.write @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_memPortB_io_enq_w.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
            enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortB_io_enq_w.ready @[ReadyValid.scala 19:11]
            memPortB.io.enq.bits.reverse <= instruction_io_deq_ready_memPortB_io_enq_w.bits.reverse @[MultiEnqueue.scala 116:10]
            memPortB.io.enq.bits.stride <= instruction_io_deq_ready_memPortB_io_enq_w.bits.stride @[MultiEnqueue.scala 116:10]
            memPortB.io.enq.bits.size <= instruction_io_deq_ready_memPortB_io_enq_w.bits.size @[MultiEnqueue.scala 116:10]
            memPortB.io.enq.bits.address <= instruction_io_deq_ready_memPortB_io_enq_w.bits.address @[MultiEnqueue.scala 116:10]
            memPortB.io.enq.bits.write <= instruction_io_deq_ready_memPortB_io_enq_w.bits.write @[MultiEnqueue.scala 116:10]
            memPortB.io.enq.valid <= instruction_io_deq_ready_memPortB_io_enq_w.valid @[MultiEnqueue.scala 116:10]
            instruction_io_deq_ready_memPortB_io_enq_w.ready <= memPortB.io.enq.ready @[MultiEnqueue.scala 116:10]
            wire instruction_io_deq_ready_dram0Handler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_dram0Handler_io_in_w.bits.reverse <= instruction_io_deq_ready_w_13.reverse @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0Handler_io_in_w.bits.stride <= instruction_io_deq_ready_w_13.stride @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0Handler_io_in_w.bits.size <= instruction_io_deq_ready_w_13.size @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0Handler_io_in_w.bits.address <= instruction_io_deq_ready_w_13.address @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0Handler_io_in_w.bits.write <= instruction_io_deq_ready_w_13.write @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_dram0Handler_io_in_w.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
            enqueuer3.io.out[2].ready <= instruction_io_deq_ready_dram0Handler_io_in_w.ready @[ReadyValid.scala 19:11]
            dram0Handler.io.in.bits.reverse <= instruction_io_deq_ready_dram0Handler_io_in_w.bits.reverse @[MultiEnqueue.scala 117:10]
            dram0Handler.io.in.bits.stride <= instruction_io_deq_ready_dram0Handler_io_in_w.bits.stride @[MultiEnqueue.scala 117:10]
            dram0Handler.io.in.bits.size <= instruction_io_deq_ready_dram0Handler_io_in_w.bits.size @[MultiEnqueue.scala 117:10]
            dram0Handler.io.in.bits.address <= instruction_io_deq_ready_dram0Handler_io_in_w.bits.address @[MultiEnqueue.scala 117:10]
            dram0Handler.io.in.bits.write <= instruction_io_deq_ready_dram0Handler_io_in_w.bits.write @[MultiEnqueue.scala 117:10]
            dram0Handler.io.in.valid <= instruction_io_deq_ready_dram0Handler_io_in_w.valid @[MultiEnqueue.scala 117:10]
            instruction_io_deq_ready_dram0Handler_io_in_w.ready <= dram0Handler.io.in.ready @[MultiEnqueue.scala 117:10]
            instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 341:25]
            skip @[Decoder.scala 339:53]
          else : @[Decoder.scala 365:59]
            node _T_6 = eq(flags_2.kind, UInt<1>("h01")) @[Decoder.scala 365:27]
            when _T_6 : @[Decoder.scala 365:59]
              wire instruction_io_deq_ready_w_14 : {kind : UInt<2>, size : UInt<6>} @[HostRouter.scala 93:19]
              instruction_io_deq_ready_w_14.kind <= UInt<1>("h01") @[HostRouter.scala 94:14]
              instruction_io_deq_ready_w_14.size <= args_2.size @[HostRouter.scala 95:14]
              wire instruction_io_deq_ready_w_15 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
              instruction_io_deq_ready_w_15.address <= args_2.memAddress @[MemControl.scala 40:17]
              instruction_io_deq_ready_w_15.size <= args_2.size @[MemControl.scala 41:14]
              instruction_io_deq_ready_w_15.stride <= args_2.memStride @[MemControl.scala 42:16]
              instruction_io_deq_ready_w_15.write <= UInt<1>("h00") @[MemControl.scala 43:15]
              instruction_io_deq_ready_w_15.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
              wire instruction_io_deq_ready_w_16 : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
              instruction_io_deq_ready_w_16.address <= args_2.accAddress @[MemControl.scala 40:17]
              instruction_io_deq_ready_w_16.size <= args_2.size @[MemControl.scala 41:14]
              instruction_io_deq_ready_w_16.stride <= args_2.accStride @[MemControl.scala 42:16]
              instruction_io_deq_ready_w_16.write <= UInt<1>("h01") @[MemControl.scala 43:15]
              instruction_io_deq_ready_w_16.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
              enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
              wire instruction_io_deq_ready_hostDataflowHandler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.bits.size <= instruction_io_deq_ready_w_14.size @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.bits.kind <= instruction_io_deq_ready_w_14.kind @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
              enqueuer3.io.out[0].ready <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.ready @[ReadyValid.scala 19:11]
              hostDataflowHandler.io.in.bits.size <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.bits.size @[MultiEnqueue.scala 115:10]
              hostDataflowHandler.io.in.bits.kind <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.bits.kind @[MultiEnqueue.scala 115:10]
              hostDataflowHandler.io.in.valid <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.valid @[MultiEnqueue.scala 115:10]
              instruction_io_deq_ready_hostDataflowHandler_io_in_w_1.ready <= hostDataflowHandler.io.in.ready @[MultiEnqueue.scala 115:10]
              wire instruction_io_deq_ready_memPortB_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_memPortB_io_enq_w_1.bits.reverse <= instruction_io_deq_ready_w_15.reverse @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_memPortB_io_enq_w_1.bits.stride <= instruction_io_deq_ready_w_15.stride @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_memPortB_io_enq_w_1.bits.size <= instruction_io_deq_ready_w_15.size @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_memPortB_io_enq_w_1.bits.address <= instruction_io_deq_ready_w_15.address @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_memPortB_io_enq_w_1.bits.write <= instruction_io_deq_ready_w_15.write @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_memPortB_io_enq_w_1.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
              enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortB_io_enq_w_1.ready @[ReadyValid.scala 19:11]
              memPortB.io.enq.bits.reverse <= instruction_io_deq_ready_memPortB_io_enq_w_1.bits.reverse @[MultiEnqueue.scala 116:10]
              memPortB.io.enq.bits.stride <= instruction_io_deq_ready_memPortB_io_enq_w_1.bits.stride @[MultiEnqueue.scala 116:10]
              memPortB.io.enq.bits.size <= instruction_io_deq_ready_memPortB_io_enq_w_1.bits.size @[MultiEnqueue.scala 116:10]
              memPortB.io.enq.bits.address <= instruction_io_deq_ready_memPortB_io_enq_w_1.bits.address @[MultiEnqueue.scala 116:10]
              memPortB.io.enq.bits.write <= instruction_io_deq_ready_memPortB_io_enq_w_1.bits.write @[MultiEnqueue.scala 116:10]
              memPortB.io.enq.valid <= instruction_io_deq_ready_memPortB_io_enq_w_1.valid @[MultiEnqueue.scala 116:10]
              instruction_io_deq_ready_memPortB_io_enq_w_1.ready <= memPortB.io.enq.ready @[MultiEnqueue.scala 116:10]
              wire instruction_io_deq_ready_dram0Handler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.reverse <= instruction_io_deq_ready_w_16.reverse @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.stride <= instruction_io_deq_ready_w_16.stride @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.size <= instruction_io_deq_ready_w_16.size @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.address <= instruction_io_deq_ready_w_16.address @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.write <= instruction_io_deq_ready_w_16.write @[ReadyValid.scala 17:12]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
              enqueuer3.io.out[2].ready <= instruction_io_deq_ready_dram0Handler_io_in_w_1.ready @[ReadyValid.scala 19:11]
              dram0Handler.io.in.bits.reverse <= instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.reverse @[MultiEnqueue.scala 117:10]
              dram0Handler.io.in.bits.stride <= instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.stride @[MultiEnqueue.scala 117:10]
              dram0Handler.io.in.bits.size <= instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.size @[MultiEnqueue.scala 117:10]
              dram0Handler.io.in.bits.address <= instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.address @[MultiEnqueue.scala 117:10]
              dram0Handler.io.in.bits.write <= instruction_io_deq_ready_dram0Handler_io_in_w_1.bits.write @[MultiEnqueue.scala 117:10]
              dram0Handler.io.in.valid <= instruction_io_deq_ready_dram0Handler_io_in_w_1.valid @[MultiEnqueue.scala 117:10]
              instruction_io_deq_ready_dram0Handler_io_in_w_1.ready <= dram0Handler.io.in.ready @[MultiEnqueue.scala 117:10]
              instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 367:25]
              skip @[Decoder.scala 365:59]
            else : @[Decoder.scala 391:59]
              node _T_7 = eq(flags_2.kind, UInt<2>("h02")) @[Decoder.scala 391:27]
              when _T_7 : @[Decoder.scala 391:59]
                wire instruction_io_deq_ready_w_17 : {kind : UInt<2>, size : UInt<6>} @[HostRouter.scala 93:19]
                instruction_io_deq_ready_w_17.kind <= UInt<2>("h02") @[HostRouter.scala 94:14]
                instruction_io_deq_ready_w_17.size <= args_2.size @[HostRouter.scala 95:14]
                wire instruction_io_deq_ready_w_18 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                instruction_io_deq_ready_w_18.address <= args_2.memAddress @[MemControl.scala 40:17]
                instruction_io_deq_ready_w_18.size <= args_2.size @[MemControl.scala 41:14]
                instruction_io_deq_ready_w_18.stride <= args_2.memStride @[MemControl.scala 42:16]
                instruction_io_deq_ready_w_18.write <= UInt<1>("h01") @[MemControl.scala 43:15]
                instruction_io_deq_ready_w_18.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                wire instruction_io_deq_ready_w_19 : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                instruction_io_deq_ready_w_19.address <= args_2.accAddress @[MemControl.scala 40:17]
                instruction_io_deq_ready_w_19.size <= args_2.size @[MemControl.scala 41:14]
                instruction_io_deq_ready_w_19.stride <= args_2.accStride @[MemControl.scala 42:16]
                instruction_io_deq_ready_w_19.write <= UInt<1>("h00") @[MemControl.scala 43:15]
                instruction_io_deq_ready_w_19.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
                wire instruction_io_deq_ready_hostDataflowHandler_io_in_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.bits.size <= instruction_io_deq_ready_w_17.size @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.bits.kind <= instruction_io_deq_ready_w_17.kind @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
                enqueuer3.io.out[0].ready <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.ready @[ReadyValid.scala 19:11]
                hostDataflowHandler.io.in.bits.size <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.bits.size @[MultiEnqueue.scala 115:10]
                hostDataflowHandler.io.in.bits.kind <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.bits.kind @[MultiEnqueue.scala 115:10]
                hostDataflowHandler.io.in.valid <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.valid @[MultiEnqueue.scala 115:10]
                instruction_io_deq_ready_hostDataflowHandler_io_in_w_2.ready <= hostDataflowHandler.io.in.ready @[MultiEnqueue.scala 115:10]
                wire instruction_io_deq_ready_memPortB_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_memPortB_io_enq_w_2.bits.reverse <= instruction_io_deq_ready_w_18.reverse @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_memPortB_io_enq_w_2.bits.stride <= instruction_io_deq_ready_w_18.stride @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_memPortB_io_enq_w_2.bits.size <= instruction_io_deq_ready_w_18.size @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_memPortB_io_enq_w_2.bits.address <= instruction_io_deq_ready_w_18.address @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_memPortB_io_enq_w_2.bits.write <= instruction_io_deq_ready_w_18.write @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_memPortB_io_enq_w_2.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
                enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortB_io_enq_w_2.ready @[ReadyValid.scala 19:11]
                memPortB.io.enq.bits.reverse <= instruction_io_deq_ready_memPortB_io_enq_w_2.bits.reverse @[MultiEnqueue.scala 116:10]
                memPortB.io.enq.bits.stride <= instruction_io_deq_ready_memPortB_io_enq_w_2.bits.stride @[MultiEnqueue.scala 116:10]
                memPortB.io.enq.bits.size <= instruction_io_deq_ready_memPortB_io_enq_w_2.bits.size @[MultiEnqueue.scala 116:10]
                memPortB.io.enq.bits.address <= instruction_io_deq_ready_memPortB_io_enq_w_2.bits.address @[MultiEnqueue.scala 116:10]
                memPortB.io.enq.bits.write <= instruction_io_deq_ready_memPortB_io_enq_w_2.bits.write @[MultiEnqueue.scala 116:10]
                memPortB.io.enq.valid <= instruction_io_deq_ready_memPortB_io_enq_w_2.valid @[MultiEnqueue.scala 116:10]
                instruction_io_deq_ready_memPortB_io_enq_w_2.ready <= memPortB.io.enq.ready @[MultiEnqueue.scala 116:10]
                wire instruction_io_deq_ready_dram1Handler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                instruction_io_deq_ready_dram1Handler_io_in_w.bits.reverse <= instruction_io_deq_ready_w_19.reverse @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1Handler_io_in_w.bits.stride <= instruction_io_deq_ready_w_19.stride @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1Handler_io_in_w.bits.size <= instruction_io_deq_ready_w_19.size @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1Handler_io_in_w.bits.address <= instruction_io_deq_ready_w_19.address @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1Handler_io_in_w.bits.write <= instruction_io_deq_ready_w_19.write @[ReadyValid.scala 17:12]
                instruction_io_deq_ready_dram1Handler_io_in_w.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
                enqueuer3.io.out[2].ready <= instruction_io_deq_ready_dram1Handler_io_in_w.ready @[ReadyValid.scala 19:11]
                dram1Handler.io.in.bits.reverse <= instruction_io_deq_ready_dram1Handler_io_in_w.bits.reverse @[MultiEnqueue.scala 117:10]
                dram1Handler.io.in.bits.stride <= instruction_io_deq_ready_dram1Handler_io_in_w.bits.stride @[MultiEnqueue.scala 117:10]
                dram1Handler.io.in.bits.size <= instruction_io_deq_ready_dram1Handler_io_in_w.bits.size @[MultiEnqueue.scala 117:10]
                dram1Handler.io.in.bits.address <= instruction_io_deq_ready_dram1Handler_io_in_w.bits.address @[MultiEnqueue.scala 117:10]
                dram1Handler.io.in.bits.write <= instruction_io_deq_ready_dram1Handler_io_in_w.bits.write @[MultiEnqueue.scala 117:10]
                dram1Handler.io.in.valid <= instruction_io_deq_ready_dram1Handler_io_in_w.valid @[MultiEnqueue.scala 117:10]
                instruction_io_deq_ready_dram1Handler_io_in_w.ready <= dram1Handler.io.in.ready @[MultiEnqueue.scala 117:10]
                instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 393:25]
                skip @[Decoder.scala 391:59]
              else : @[Decoder.scala 417:59]
                node _T_8 = eq(flags_2.kind, UInt<2>("h03")) @[Decoder.scala 417:27]
                when _T_8 : @[Decoder.scala 417:59]
                  wire instruction_io_deq_ready_w_20 : {kind : UInt<2>, size : UInt<6>} @[HostRouter.scala 93:19]
                  instruction_io_deq_ready_w_20.kind <= UInt<2>("h03") @[HostRouter.scala 94:14]
                  instruction_io_deq_ready_w_20.size <= args_2.size @[HostRouter.scala 95:14]
                  wire instruction_io_deq_ready_w_21 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                  instruction_io_deq_ready_w_21.address <= args_2.memAddress @[MemControl.scala 40:17]
                  instruction_io_deq_ready_w_21.size <= args_2.size @[MemControl.scala 41:14]
                  instruction_io_deq_ready_w_21.stride <= args_2.memStride @[MemControl.scala 42:16]
                  instruction_io_deq_ready_w_21.write <= UInt<1>("h00") @[MemControl.scala 43:15]
                  instruction_io_deq_ready_w_21.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                  wire instruction_io_deq_ready_w_22 : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                  instruction_io_deq_ready_w_22.address <= args_2.accAddress @[MemControl.scala 40:17]
                  instruction_io_deq_ready_w_22.size <= args_2.size @[MemControl.scala 41:14]
                  instruction_io_deq_ready_w_22.stride <= args_2.accStride @[MemControl.scala 42:16]
                  instruction_io_deq_ready_w_22.write <= UInt<1>("h01") @[MemControl.scala 43:15]
                  instruction_io_deq_ready_w_22.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                  enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
                  wire instruction_io_deq_ready_hostDataflowHandler_io_in_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.bits.size <= instruction_io_deq_ready_w_20.size @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.bits.kind <= instruction_io_deq_ready_w_20.kind @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
                  enqueuer3.io.out[0].ready <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.ready @[ReadyValid.scala 19:11]
                  hostDataflowHandler.io.in.bits.size <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.bits.size @[MultiEnqueue.scala 115:10]
                  hostDataflowHandler.io.in.bits.kind <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.bits.kind @[MultiEnqueue.scala 115:10]
                  hostDataflowHandler.io.in.valid <= instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.valid @[MultiEnqueue.scala 115:10]
                  instruction_io_deq_ready_hostDataflowHandler_io_in_w_3.ready <= hostDataflowHandler.io.in.ready @[MultiEnqueue.scala 115:10]
                  wire instruction_io_deq_ready_memPortB_io_enq_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.bits.reverse <= instruction_io_deq_ready_w_21.reverse @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.bits.stride <= instruction_io_deq_ready_w_21.stride @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.bits.size <= instruction_io_deq_ready_w_21.size @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.bits.address <= instruction_io_deq_ready_w_21.address @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.bits.write <= instruction_io_deq_ready_w_21.write @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
                  enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortB_io_enq_w_3.ready @[ReadyValid.scala 19:11]
                  memPortB.io.enq.bits.reverse <= instruction_io_deq_ready_memPortB_io_enq_w_3.bits.reverse @[MultiEnqueue.scala 116:10]
                  memPortB.io.enq.bits.stride <= instruction_io_deq_ready_memPortB_io_enq_w_3.bits.stride @[MultiEnqueue.scala 116:10]
                  memPortB.io.enq.bits.size <= instruction_io_deq_ready_memPortB_io_enq_w_3.bits.size @[MultiEnqueue.scala 116:10]
                  memPortB.io.enq.bits.address <= instruction_io_deq_ready_memPortB_io_enq_w_3.bits.address @[MultiEnqueue.scala 116:10]
                  memPortB.io.enq.bits.write <= instruction_io_deq_ready_memPortB_io_enq_w_3.bits.write @[MultiEnqueue.scala 116:10]
                  memPortB.io.enq.valid <= instruction_io_deq_ready_memPortB_io_enq_w_3.valid @[MultiEnqueue.scala 116:10]
                  instruction_io_deq_ready_memPortB_io_enq_w_3.ready <= memPortB.io.enq.ready @[MultiEnqueue.scala 116:10]
                  wire instruction_io_deq_ready_dram1Handler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.reverse <= instruction_io_deq_ready_w_22.reverse @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.stride <= instruction_io_deq_ready_w_22.stride @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.size <= instruction_io_deq_ready_w_22.size @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.address <= instruction_io_deq_ready_w_22.address @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.write <= instruction_io_deq_ready_w_22.write @[ReadyValid.scala 17:12]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
                  enqueuer3.io.out[2].ready <= instruction_io_deq_ready_dram1Handler_io_in_w_1.ready @[ReadyValid.scala 19:11]
                  dram1Handler.io.in.bits.reverse <= instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.reverse @[MultiEnqueue.scala 117:10]
                  dram1Handler.io.in.bits.stride <= instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.stride @[MultiEnqueue.scala 117:10]
                  dram1Handler.io.in.bits.size <= instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.size @[MultiEnqueue.scala 117:10]
                  dram1Handler.io.in.bits.address <= instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.address @[MultiEnqueue.scala 117:10]
                  dram1Handler.io.in.bits.write <= instruction_io_deq_ready_dram1Handler_io_in_w_1.bits.write @[MultiEnqueue.scala 117:10]
                  dram1Handler.io.in.valid <= instruction_io_deq_ready_dram1Handler_io_in_w_1.valid @[MultiEnqueue.scala 117:10]
                  instruction_io_deq_ready_dram1Handler_io_in_w_1.ready <= dram1Handler.io.in.ready @[MultiEnqueue.scala 117:10]
                  instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 418:25]
                  skip @[Decoder.scala 417:59]
                else : @[Decoder.scala 444:7]
                  node _T_9 = eq(flags_2.kind, UInt<4>("h0c")) @[Decoder.scala 443:18]
                  when _T_9 : @[Decoder.scala 444:7]
                    wire instruction_io_deq_ready_w_23 : {kind : UInt<4>, size : UInt<6>} @[LocalDataFlowControl.scala 28:19]
                    instruction_io_deq_ready_w_23.kind <= UInt<3>("h04") @[LocalDataFlowControl.scala 29:14]
                    instruction_io_deq_ready_w_23.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                    wire instruction_io_deq_ready_w_24 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                    instruction_io_deq_ready_w_24.address <= args_2.memAddress @[MemControl.scala 40:17]
                    instruction_io_deq_ready_w_24.size <= args_2.size @[MemControl.scala 41:14]
                    instruction_io_deq_ready_w_24.stride <= args_2.memStride @[MemControl.scala 42:16]
                    instruction_io_deq_ready_w_24.write <= UInt<1>("h01") @[MemControl.scala 43:15]
                    instruction_io_deq_ready_w_24.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                    wire instruction_io_deq_ready_w_25 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
                    instruction_io_deq_ready_w_25.instruction.dest <= UInt<1>("h00") @[Decoder.scala 657:19]
                    instruction_io_deq_ready_w_25.instruction.sourceRight <= UInt<1>("h00") @[Decoder.scala 657:19]
                    instruction_io_deq_ready_w_25.instruction.sourceLeft <= UInt<1>("h00") @[Decoder.scala 657:19]
                    instruction_io_deq_ready_w_25.instruction.op <= UInt<1>("h00") @[Decoder.scala 657:19]
                    instruction_io_deq_ready_w_25.address <= args_2.accAddress @[Decoder.scala 658:15]
                    instruction_io_deq_ready_w_25.altAddress <= UInt<1>("h00") @[Decoder.scala 659:18]
                    instruction_io_deq_ready_w_25.accumulate <= UInt<1>("h00") @[Decoder.scala 660:18]
                    instruction_io_deq_ready_w_25.write <= UInt<1>("h00") @[Decoder.scala 661:13]
                    instruction_io_deq_ready_w_25.read <= UInt<1>("h01") @[Decoder.scala 662:12]
                    instruction_io_deq_ready_w_25.size <= args_2.size @[Decoder.scala 663:12]
                    instruction_io_deq_ready_w_25.stride <= args_2.accStride @[Decoder.scala 664:14]
                    instruction_io_deq_ready_w_25.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
                    enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
                    wire instruction_io_deq_ready_io_dataflow_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_io_dataflow_w_3.bits.size <= instruction_io_deq_ready_w_23.size @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_io_dataflow_w_3.bits.kind <= instruction_io_deq_ready_w_23.kind @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_io_dataflow_w_3.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
                    enqueuer3.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w_3.ready @[ReadyValid.scala 19:11]
                    io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w_3.bits.size @[MultiEnqueue.scala 115:10]
                    io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w_3.bits.kind @[MultiEnqueue.scala 115:10]
                    io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w_3.valid @[MultiEnqueue.scala 115:10]
                    instruction_io_deq_ready_io_dataflow_w_3.ready <= io.dataflow.ready @[MultiEnqueue.scala 115:10]
                    wire instruction_io_deq_ready_memPortA_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.bits.reverse <= instruction_io_deq_ready_w_24.reverse @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.bits.stride <= instruction_io_deq_ready_w_24.stride @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.bits.size <= instruction_io_deq_ready_w_24.size @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.bits.address <= instruction_io_deq_ready_w_24.address @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.bits.write <= instruction_io_deq_ready_w_24.write @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
                    enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortA_io_enq_w_2.ready @[ReadyValid.scala 19:11]
                    memPortA.io.enq.bits.reverse <= instruction_io_deq_ready_memPortA_io_enq_w_2.bits.reverse @[MultiEnqueue.scala 116:10]
                    memPortA.io.enq.bits.stride <= instruction_io_deq_ready_memPortA_io_enq_w_2.bits.stride @[MultiEnqueue.scala 116:10]
                    memPortA.io.enq.bits.size <= instruction_io_deq_ready_memPortA_io_enq_w_2.bits.size @[MultiEnqueue.scala 116:10]
                    memPortA.io.enq.bits.address <= instruction_io_deq_ready_memPortA_io_enq_w_2.bits.address @[MultiEnqueue.scala 116:10]
                    memPortA.io.enq.bits.write <= instruction_io_deq_ready_memPortA_io_enq_w_2.bits.write @[MultiEnqueue.scala 116:10]
                    memPortA.io.enq.valid <= instruction_io_deq_ready_memPortA_io_enq_w_2.valid @[MultiEnqueue.scala 116:10]
                    instruction_io_deq_ready_memPortA_io_enq_w_2.ready <= memPortA.io.enq.ready @[MultiEnqueue.scala 116:10]
                    wire instruction_io_deq_ready_accHandler_io_in_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.reverse <= instruction_io_deq_ready_w_25.reverse @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.stride <= instruction_io_deq_ready_w_25.stride @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.size <= instruction_io_deq_ready_w_25.size @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.accumulate <= instruction_io_deq_ready_w_25.accumulate @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.write <= instruction_io_deq_ready_w_25.write @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.read <= instruction_io_deq_ready_w_25.read @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.altAddress <= instruction_io_deq_ready_w_25.altAddress @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.address <= instruction_io_deq_ready_w_25.address @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.dest <= instruction_io_deq_ready_w_25.instruction.dest @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.sourceRight <= instruction_io_deq_ready_w_25.instruction.sourceRight @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_25.instruction.sourceLeft @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.op <= instruction_io_deq_ready_w_25.instruction.op @[ReadyValid.scala 17:12]
                    instruction_io_deq_ready_accHandler_io_in_w_2.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
                    enqueuer3.io.out[2].ready <= instruction_io_deq_ready_accHandler_io_in_w_2.ready @[ReadyValid.scala 19:11]
                    accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.reverse @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.stride @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.size @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.accumulate @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.write @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.read @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.altAddress @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.address @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.dest @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.sourceRight @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.sourceLeft @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w_2.bits.instruction.op @[MultiEnqueue.scala 117:10]
                    accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w_2.valid @[MultiEnqueue.scala 117:10]
                    instruction_io_deq_ready_accHandler_io_in_w_2.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 117:10]
                    instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 446:25]
                    skip @[Decoder.scala 444:7]
                  else : @[Decoder.scala 466:7]
                    node _T_10 = eq(flags_2.kind, UInt<4>("h0d")) @[Decoder.scala 465:18]
                    when _T_10 : @[Decoder.scala 466:7]
                      wire instruction_io_deq_ready_w_26 : {kind : UInt<4>, size : UInt<6>} @[LocalDataFlowControl.scala 28:19]
                      instruction_io_deq_ready_w_26.kind <= UInt<3>("h05") @[LocalDataFlowControl.scala 29:14]
                      instruction_io_deq_ready_w_26.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                      wire instruction_io_deq_ready_w_27 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                      instruction_io_deq_ready_w_27.address <= args_2.memAddress @[MemControl.scala 40:17]
                      instruction_io_deq_ready_w_27.size <= args_2.size @[MemControl.scala 41:14]
                      instruction_io_deq_ready_w_27.stride <= args_2.memStride @[MemControl.scala 42:16]
                      instruction_io_deq_ready_w_27.write <= UInt<1>("h00") @[MemControl.scala 43:15]
                      instruction_io_deq_ready_w_27.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                      wire instruction_io_deq_ready_w_28 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
                      instruction_io_deq_ready_w_28.instruction.dest <= UInt<1>("h00") @[Decoder.scala 657:19]
                      instruction_io_deq_ready_w_28.instruction.sourceRight <= UInt<1>("h00") @[Decoder.scala 657:19]
                      instruction_io_deq_ready_w_28.instruction.sourceLeft <= UInt<1>("h00") @[Decoder.scala 657:19]
                      instruction_io_deq_ready_w_28.instruction.op <= UInt<1>("h00") @[Decoder.scala 657:19]
                      instruction_io_deq_ready_w_28.address <= args_2.accAddress @[Decoder.scala 658:15]
                      instruction_io_deq_ready_w_28.altAddress <= UInt<1>("h00") @[Decoder.scala 659:18]
                      instruction_io_deq_ready_w_28.accumulate <= UInt<1>("h00") @[Decoder.scala 660:18]
                      instruction_io_deq_ready_w_28.write <= UInt<1>("h01") @[Decoder.scala 661:13]
                      instruction_io_deq_ready_w_28.read <= UInt<1>("h00") @[Decoder.scala 662:12]
                      instruction_io_deq_ready_w_28.size <= args_2.size @[Decoder.scala 663:12]
                      instruction_io_deq_ready_w_28.stride <= args_2.accStride @[Decoder.scala 664:14]
                      instruction_io_deq_ready_w_28.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
                      enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
                      wire instruction_io_deq_ready_io_dataflow_w_4 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_io_dataflow_w_4.bits.size <= instruction_io_deq_ready_w_26.size @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_io_dataflow_w_4.bits.kind <= instruction_io_deq_ready_w_26.kind @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_io_dataflow_w_4.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
                      enqueuer3.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w_4.ready @[ReadyValid.scala 19:11]
                      io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w_4.bits.size @[MultiEnqueue.scala 115:10]
                      io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w_4.bits.kind @[MultiEnqueue.scala 115:10]
                      io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w_4.valid @[MultiEnqueue.scala 115:10]
                      instruction_io_deq_ready_io_dataflow_w_4.ready <= io.dataflow.ready @[MultiEnqueue.scala 115:10]
                      wire instruction_io_deq_ready_memPortA_io_enq_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.bits.reverse <= instruction_io_deq_ready_w_27.reverse @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.bits.stride <= instruction_io_deq_ready_w_27.stride @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.bits.size <= instruction_io_deq_ready_w_27.size @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.bits.address <= instruction_io_deq_ready_w_27.address @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.bits.write <= instruction_io_deq_ready_w_27.write @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
                      enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortA_io_enq_w_3.ready @[ReadyValid.scala 19:11]
                      memPortA.io.enq.bits.reverse <= instruction_io_deq_ready_memPortA_io_enq_w_3.bits.reverse @[MultiEnqueue.scala 116:10]
                      memPortA.io.enq.bits.stride <= instruction_io_deq_ready_memPortA_io_enq_w_3.bits.stride @[MultiEnqueue.scala 116:10]
                      memPortA.io.enq.bits.size <= instruction_io_deq_ready_memPortA_io_enq_w_3.bits.size @[MultiEnqueue.scala 116:10]
                      memPortA.io.enq.bits.address <= instruction_io_deq_ready_memPortA_io_enq_w_3.bits.address @[MultiEnqueue.scala 116:10]
                      memPortA.io.enq.bits.write <= instruction_io_deq_ready_memPortA_io_enq_w_3.bits.write @[MultiEnqueue.scala 116:10]
                      memPortA.io.enq.valid <= instruction_io_deq_ready_memPortA_io_enq_w_3.valid @[MultiEnqueue.scala 116:10]
                      instruction_io_deq_ready_memPortA_io_enq_w_3.ready <= memPortA.io.enq.ready @[MultiEnqueue.scala 116:10]
                      wire instruction_io_deq_ready_accHandler_io_in_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.reverse <= instruction_io_deq_ready_w_28.reverse @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.stride <= instruction_io_deq_ready_w_28.stride @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.size <= instruction_io_deq_ready_w_28.size @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.accumulate <= instruction_io_deq_ready_w_28.accumulate @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.write <= instruction_io_deq_ready_w_28.write @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.read <= instruction_io_deq_ready_w_28.read @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.altAddress <= instruction_io_deq_ready_w_28.altAddress @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.address <= instruction_io_deq_ready_w_28.address @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.dest <= instruction_io_deq_ready_w_28.instruction.dest @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.sourceRight <= instruction_io_deq_ready_w_28.instruction.sourceRight @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_28.instruction.sourceLeft @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.op <= instruction_io_deq_ready_w_28.instruction.op @[ReadyValid.scala 17:12]
                      instruction_io_deq_ready_accHandler_io_in_w_3.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
                      enqueuer3.io.out[2].ready <= instruction_io_deq_ready_accHandler_io_in_w_3.ready @[ReadyValid.scala 19:11]
                      accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.reverse @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.stride @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.size @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.accumulate @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.write @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.read @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.altAddress @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.address @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.dest @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.sourceRight @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.sourceLeft @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w_3.bits.instruction.op @[MultiEnqueue.scala 117:10]
                      accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w_3.valid @[MultiEnqueue.scala 117:10]
                      instruction_io_deq_ready_accHandler_io_in_w_3.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 117:10]
                      instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 468:25]
                      skip @[Decoder.scala 466:7]
                    else : @[Decoder.scala 488:7]
                      node _T_11 = eq(flags_2.kind, UInt<4>("h0f")) @[Decoder.scala 487:18]
                      when _T_11 : @[Decoder.scala 488:7]
                        wire instruction_io_deq_ready_w_29 : {kind : UInt<4>, size : UInt<6>} @[LocalDataFlowControl.scala 28:19]
                        instruction_io_deq_ready_w_29.kind <= UInt<3>("h05") @[LocalDataFlowControl.scala 29:14]
                        instruction_io_deq_ready_w_29.size <= args_2.size @[LocalDataFlowControl.scala 30:14]
                        wire instruction_io_deq_ready_w_30 : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[MemControl.scala 39:19]
                        instruction_io_deq_ready_w_30.address <= args_2.memAddress @[MemControl.scala 40:17]
                        instruction_io_deq_ready_w_30.size <= args_2.size @[MemControl.scala 41:14]
                        instruction_io_deq_ready_w_30.stride <= args_2.memStride @[MemControl.scala 42:16]
                        instruction_io_deq_ready_w_30.write <= UInt<1>("h00") @[MemControl.scala 43:15]
                        instruction_io_deq_ready_w_30.reverse <= UInt<1>("h00") @[MemControl.scala 44:17]
                        wire instruction_io_deq_ready_w_31 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
                        instruction_io_deq_ready_w_31.instruction.dest <= UInt<1>("h00") @[Decoder.scala 657:19]
                        instruction_io_deq_ready_w_31.instruction.sourceRight <= UInt<1>("h00") @[Decoder.scala 657:19]
                        instruction_io_deq_ready_w_31.instruction.sourceLeft <= UInt<1>("h00") @[Decoder.scala 657:19]
                        instruction_io_deq_ready_w_31.instruction.op <= UInt<1>("h00") @[Decoder.scala 657:19]
                        instruction_io_deq_ready_w_31.address <= args_2.accAddress @[Decoder.scala 658:15]
                        instruction_io_deq_ready_w_31.altAddress <= UInt<1>("h00") @[Decoder.scala 659:18]
                        instruction_io_deq_ready_w_31.accumulate <= UInt<1>("h01") @[Decoder.scala 660:18]
                        instruction_io_deq_ready_w_31.write <= UInt<1>("h01") @[Decoder.scala 661:13]
                        instruction_io_deq_ready_w_31.read <= UInt<1>("h00") @[Decoder.scala 662:12]
                        instruction_io_deq_ready_w_31.size <= args_2.size @[Decoder.scala 663:12]
                        instruction_io_deq_ready_w_31.stride <= args_2.accStride @[Decoder.scala 664:14]
                        instruction_io_deq_ready_w_31.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
                        enqueuer3.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 114:17]
                        wire instruction_io_deq_ready_io_dataflow_w_5 : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_io_dataflow_w_5.bits.size <= instruction_io_deq_ready_w_29.size @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_io_dataflow_w_5.bits.kind <= instruction_io_deq_ready_w_29.kind @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_io_dataflow_w_5.valid <= enqueuer3.io.out[0].valid @[ReadyValid.scala 18:13]
                        enqueuer3.io.out[0].ready <= instruction_io_deq_ready_io_dataflow_w_5.ready @[ReadyValid.scala 19:11]
                        io.dataflow.bits.size <= instruction_io_deq_ready_io_dataflow_w_5.bits.size @[MultiEnqueue.scala 115:10]
                        io.dataflow.bits.kind <= instruction_io_deq_ready_io_dataflow_w_5.bits.kind @[MultiEnqueue.scala 115:10]
                        io.dataflow.valid <= instruction_io_deq_ready_io_dataflow_w_5.valid @[MultiEnqueue.scala 115:10]
                        instruction_io_deq_ready_io_dataflow_w_5.ready <= io.dataflow.ready @[MultiEnqueue.scala 115:10]
                        wire instruction_io_deq_ready_memPortA_io_enq_w_4 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.bits.reverse <= instruction_io_deq_ready_w_30.reverse @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.bits.stride <= instruction_io_deq_ready_w_30.stride @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.bits.size <= instruction_io_deq_ready_w_30.size @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.bits.address <= instruction_io_deq_ready_w_30.address @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.bits.write <= instruction_io_deq_ready_w_30.write @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.valid <= enqueuer3.io.out[1].valid @[ReadyValid.scala 18:13]
                        enqueuer3.io.out[1].ready <= instruction_io_deq_ready_memPortA_io_enq_w_4.ready @[ReadyValid.scala 19:11]
                        memPortA.io.enq.bits.reverse <= instruction_io_deq_ready_memPortA_io_enq_w_4.bits.reverse @[MultiEnqueue.scala 116:10]
                        memPortA.io.enq.bits.stride <= instruction_io_deq_ready_memPortA_io_enq_w_4.bits.stride @[MultiEnqueue.scala 116:10]
                        memPortA.io.enq.bits.size <= instruction_io_deq_ready_memPortA_io_enq_w_4.bits.size @[MultiEnqueue.scala 116:10]
                        memPortA.io.enq.bits.address <= instruction_io_deq_ready_memPortA_io_enq_w_4.bits.address @[MultiEnqueue.scala 116:10]
                        memPortA.io.enq.bits.write <= instruction_io_deq_ready_memPortA_io_enq_w_4.bits.write @[MultiEnqueue.scala 116:10]
                        memPortA.io.enq.valid <= instruction_io_deq_ready_memPortA_io_enq_w_4.valid @[MultiEnqueue.scala 116:10]
                        instruction_io_deq_ready_memPortA_io_enq_w_4.ready <= memPortA.io.enq.ready @[MultiEnqueue.scala 116:10]
                        wire instruction_io_deq_ready_accHandler_io_in_w_4 : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.reverse <= instruction_io_deq_ready_w_31.reverse @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.stride <= instruction_io_deq_ready_w_31.stride @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.size <= instruction_io_deq_ready_w_31.size @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.accumulate <= instruction_io_deq_ready_w_31.accumulate @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.write <= instruction_io_deq_ready_w_31.write @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.read <= instruction_io_deq_ready_w_31.read @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.altAddress <= instruction_io_deq_ready_w_31.altAddress @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.address <= instruction_io_deq_ready_w_31.address @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.dest <= instruction_io_deq_ready_w_31.instruction.dest @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.sourceRight <= instruction_io_deq_ready_w_31.instruction.sourceRight @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_31.instruction.sourceLeft @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.op <= instruction_io_deq_ready_w_31.instruction.op @[ReadyValid.scala 17:12]
                        instruction_io_deq_ready_accHandler_io_in_w_4.valid <= enqueuer3.io.out[2].valid @[ReadyValid.scala 18:13]
                        enqueuer3.io.out[2].ready <= instruction_io_deq_ready_accHandler_io_in_w_4.ready @[ReadyValid.scala 19:11]
                        accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.reverse @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.stride @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.size @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.accumulate @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.write @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.read @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.altAddress @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.address @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.dest @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.sourceRight @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.sourceLeft @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w_4.bits.instruction.op @[MultiEnqueue.scala 117:10]
                        accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w_4.valid @[MultiEnqueue.scala 117:10]
                        instruction_io_deq_ready_accHandler_io_in_w_4.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 117:10]
                        instruction.io.deq.ready <= enqueuer3.io.in.ready @[Decoder.scala 490:25]
                        skip @[Decoder.scala 488:7]
                      else : @[Decoder.scala 508:17]
                        instruction.io.deq.ready <= UInt<1>("h01") @[Decoder.scala 510:25]
                        skip @[Decoder.scala 508:17]
          skip @[Decoder.scala 329:59]
        else : @[Decoder.scala 512:55]
          node _T_12 = eq(instruction.io.deq.bits.opcode, UInt<3>("h04")) @[Decoder.scala 512:38]
          when _T_12 : @[Decoder.scala 512:55]
            wire flags_3 : {_unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Decoder.scala 513:21]
            wire args_3 : {_unused : UInt<1>, instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Decoder.scala 515:11]
            wire _flags_WIRE_6 : {_unused : UInt<1>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>} @[Decoder.scala 518:45]
            wire _flags_WIRE_7 : UInt<4>
            _flags_WIRE_7 <= instruction.io.deq.bits.flags
            node _flags_T_6 = bits(_flags_WIRE_7, 0, 0) @[Decoder.scala 518:45]
            _flags_WIRE_6.read <= _flags_T_6 @[Decoder.scala 518:45]
            node _flags_T_7 = bits(_flags_WIRE_7, 1, 1) @[Decoder.scala 518:45]
            _flags_WIRE_6.write <= _flags_T_7 @[Decoder.scala 518:45]
            node _flags_T_8 = bits(_flags_WIRE_7, 2, 2) @[Decoder.scala 518:45]
            _flags_WIRE_6.accumulate <= _flags_T_8 @[Decoder.scala 518:45]
            node _flags_T_9 = bits(_flags_WIRE_7, 3, 3) @[Decoder.scala 518:45]
            _flags_WIRE_6._unused <= _flags_T_9 @[Decoder.scala 518:45]
            flags_3.read <= _flags_WIRE_6.read @[Decoder.scala 518:11]
            flags_3.write <= _flags_WIRE_6.write @[Decoder.scala 518:11]
            flags_3.accumulate <= _flags_WIRE_6.accumulate @[Decoder.scala 518:11]
            flags_3._unused <= _flags_WIRE_6._unused @[Decoder.scala 518:11]
            wire _args_WIRE_6 : {_unused : UInt<1>, instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, accReadAddress : UInt<24>, accWriteAddress : UInt<16>} @[Decoder.scala 519:48]
            wire _args_WIRE_7 : UInt<48>
            _args_WIRE_7 <= instruction.io.deq.bits.arguments
            node _args_T_18 = bits(_args_WIRE_7, 15, 0) @[Decoder.scala 519:48]
            _args_WIRE_6.accWriteAddress <= _args_T_18 @[Decoder.scala 519:48]
            node _args_T_19 = bits(_args_WIRE_7, 39, 16) @[Decoder.scala 519:48]
            _args_WIRE_6.accReadAddress <= _args_T_19 @[Decoder.scala 519:48]
            node _args_T_20 = bits(_args_WIRE_7, 40, 40) @[Decoder.scala 519:48]
            _args_WIRE_6.instruction.dest <= _args_T_20 @[Decoder.scala 519:48]
            node _args_T_21 = bits(_args_WIRE_7, 41, 41) @[Decoder.scala 519:48]
            _args_WIRE_6.instruction.sourceRight <= _args_T_21 @[Decoder.scala 519:48]
            node _args_T_22 = bits(_args_WIRE_7, 42, 42) @[Decoder.scala 519:48]
            _args_WIRE_6.instruction.sourceLeft <= _args_T_22 @[Decoder.scala 519:48]
            node _args_T_23 = bits(_args_WIRE_7, 46, 43) @[Decoder.scala 519:48]
            _args_WIRE_6.instruction.op <= _args_T_23 @[Decoder.scala 519:48]
            node _args_T_24 = bits(_args_WIRE_7, 47, 47) @[Decoder.scala 519:48]
            _args_WIRE_6._unused <= _args_T_24 @[Decoder.scala 519:48]
            args_3.accWriteAddress <= _args_WIRE_6.accWriteAddress @[Decoder.scala 519:10]
            args_3.accReadAddress <= _args_WIRE_6.accReadAddress @[Decoder.scala 519:10]
            args_3.instruction.dest <= _args_WIRE_6.instruction.dest @[Decoder.scala 519:10]
            args_3.instruction.sourceRight <= _args_WIRE_6.instruction.sourceRight @[Decoder.scala 519:10]
            args_3.instruction.sourceLeft <= _args_WIRE_6.instruction.sourceLeft @[Decoder.scala 519:10]
            args_3.instruction.op <= _args_WIRE_6.instruction.op @[Decoder.scala 519:10]
            args_3._unused <= _args_WIRE_6._unused @[Decoder.scala 519:10]
            wire instruction_io_deq_ready_w_32 : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>} @[Decoder.scala 656:17]
            instruction_io_deq_ready_w_32.instruction.dest <= args_3.instruction.dest @[Decoder.scala 657:19]
            instruction_io_deq_ready_w_32.instruction.sourceRight <= args_3.instruction.sourceRight @[Decoder.scala 657:19]
            instruction_io_deq_ready_w_32.instruction.sourceLeft <= args_3.instruction.sourceLeft @[Decoder.scala 657:19]
            instruction_io_deq_ready_w_32.instruction.op <= args_3.instruction.op @[Decoder.scala 657:19]
            instruction_io_deq_ready_w_32.address <= args_3.accReadAddress @[Decoder.scala 658:15]
            instruction_io_deq_ready_w_32.altAddress <= args_3.accWriteAddress @[Decoder.scala 659:18]
            instruction_io_deq_ready_w_32.accumulate <= flags_3.accumulate @[Decoder.scala 660:18]
            instruction_io_deq_ready_w_32.write <= flags_3.write @[Decoder.scala 661:13]
            instruction_io_deq_ready_w_32.read <= flags_3.read @[Decoder.scala 662:12]
            instruction_io_deq_ready_w_32.size <= UInt<1>("h00") @[Decoder.scala 663:12]
            instruction_io_deq_ready_w_32.stride <= UInt<1>("h00") @[Decoder.scala 664:14]
            instruction_io_deq_ready_w_32.reverse <= UInt<1>("h00") @[Decoder.scala 665:15]
            enqueuer1.io.in.valid <= instruction.io.deq.valid @[MultiEnqueue.scala 60:17]
            wire instruction_io_deq_ready_accHandler_io_in_w_5 : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, address : UInt<6>, altAddress : UInt<6>, read : UInt<1>, write : UInt<1>, accumulate : UInt<1>, size : UInt<6>, stride : UInt<3>, reverse : UInt<1>}} @[ReadyValid.scala 16:17]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.reverse <= instruction_io_deq_ready_w_32.reverse @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.stride <= instruction_io_deq_ready_w_32.stride @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.size <= instruction_io_deq_ready_w_32.size @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.accumulate <= instruction_io_deq_ready_w_32.accumulate @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.write <= instruction_io_deq_ready_w_32.write @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.read <= instruction_io_deq_ready_w_32.read @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.altAddress <= instruction_io_deq_ready_w_32.altAddress @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.address <= instruction_io_deq_ready_w_32.address @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.dest <= instruction_io_deq_ready_w_32.instruction.dest @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.sourceRight <= instruction_io_deq_ready_w_32.instruction.sourceRight @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.sourceLeft <= instruction_io_deq_ready_w_32.instruction.sourceLeft @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.op <= instruction_io_deq_ready_w_32.instruction.op @[ReadyValid.scala 17:12]
            instruction_io_deq_ready_accHandler_io_in_w_5.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer1.io.out[0].ready <= instruction_io_deq_ready_accHandler_io_in_w_5.ready @[ReadyValid.scala 19:11]
            accHandler.io.in.bits.reverse <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.reverse @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.stride <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.stride @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.size <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.size @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.accumulate <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.accumulate @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.write <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.write @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.read <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.read @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.altAddress <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.altAddress @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.address <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.address @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.instruction.dest <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.dest @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.instruction.sourceRight <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.sourceRight @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.instruction.sourceLeft <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.sourceLeft @[MultiEnqueue.scala 61:10]
            accHandler.io.in.bits.instruction.op <= instruction_io_deq_ready_accHandler_io_in_w_5.bits.instruction.op @[MultiEnqueue.scala 61:10]
            accHandler.io.in.valid <= instruction_io_deq_ready_accHandler_io_in_w_5.valid @[MultiEnqueue.scala 61:10]
            instruction_io_deq_ready_accHandler_io_in_w_5.ready <= accHandler.io.in.ready @[MultiEnqueue.scala 61:10]
            instruction.io.deq.ready <= enqueuer1.io.in.ready @[Decoder.scala 521:23]
            skip @[Decoder.scala 512:55]
          else : @[Decoder.scala 535:60]
            node _T_13 = eq(instruction.io.deq.bits.opcode, UInt<4>("h0f")) @[Decoder.scala 535:38]
            when _T_13 : @[Decoder.scala 535:60]
              when instruction.io.deq.valid : @[Decoder.scala 536:29]
                wire args_4 : {value : UInt<28>, register : UInt<4>} @[Decoder.scala 538:13]
                wire _args_WIRE_8 : {value : UInt<28>, register : UInt<4>} @[Decoder.scala 540:50]
                wire _args_WIRE_9 : UInt<32>
                _args_WIRE_9 <= instruction.io.deq.bits.arguments
                node _args_T_25 = bits(_args_WIRE_9, 3, 0) @[Decoder.scala 540:50]
                _args_WIRE_8.register <= _args_T_25 @[Decoder.scala 540:50]
                node _args_T_26 = bits(_args_WIRE_9, 31, 4) @[Decoder.scala 540:50]
                _args_WIRE_8.value <= _args_T_26 @[Decoder.scala 540:50]
                args_4.register <= _args_WIRE_8.register @[Decoder.scala 540:12]
                args_4.value <= _args_WIRE_8.value @[Decoder.scala 540:12]
                node _T_14 = eq(args_4.register, UInt<1>("h00")) @[Decoder.scala 542:26]
                when _T_14 : @[Decoder.scala 542:60]
                  node _dram0AddressOffset_T = shl(args_4.value, 16) @[Decoder.scala 543:43]
                  dram0AddressOffset <= _dram0AddressOffset_T @[Decoder.scala 543:28]
                  skip @[Decoder.scala 542:60]
                else : @[Decoder.scala 544:67]
                  node _T_15 = eq(args_4.register, UInt<1>("h01")) @[Decoder.scala 544:32]
                  when _T_15 : @[Decoder.scala 544:67]
                    dram0CacheBehaviour <= args_4.value @[Decoder.scala 545:29]
                    skip @[Decoder.scala 544:67]
                  else : @[Decoder.scala 546:66]
                    node _T_16 = eq(args_4.register, UInt<3>("h04")) @[Decoder.scala 546:32]
                    when _T_16 : @[Decoder.scala 546:66]
                      node _dram1AddressOffset_T = shl(args_4.value, 16) @[Decoder.scala 547:43]
                      dram1AddressOffset <= _dram1AddressOffset_T @[Decoder.scala 547:28]
                      skip @[Decoder.scala 546:66]
                    else : @[Decoder.scala 548:67]
                      node _T_17 = eq(args_4.register, UInt<3>("h05")) @[Decoder.scala 548:32]
                      when _T_17 : @[Decoder.scala 548:67]
                        dram1CacheBehaviour <= args_4.value @[Decoder.scala 549:29]
                        skip @[Decoder.scala 548:67]
                      else : @[Decoder.scala 550:55]
                        node _T_18 = eq(args_4.register, UInt<4>("h08")) @[Decoder.scala 550:32]
                        when _T_18 : @[Decoder.scala 550:55]
                          timeout <= args_4.value @[Decoder.scala 551:17]
                          skip @[Decoder.scala 550:55]
                        else : @[Decoder.scala 552:58]
                          node _T_19 = eq(args_4.register, UInt<4>("h09")) @[Decoder.scala 552:32]
                          when _T_19 : @[Decoder.scala 552:58]
                            tracepoint <= args_4.value @[Decoder.scala 553:20]
                            skip @[Decoder.scala 552:58]
                          else : @[Decoder.scala 554:62]
                            node _T_20 = eq(args_4.register, UInt<4>("h0a")) @[Decoder.scala 554:32]
                            when _T_20 : @[Decoder.scala 554:62]
                              programCounter <= args_4.value @[Decoder.scala 555:24]
                              skip @[Decoder.scala 554:62]
                            else : @[Decoder.scala 556:62]
                              node _T_21 = eq(args_4.register, UInt<4>("h0b")) @[Decoder.scala 556:32]
                              when _T_21 : @[Decoder.scala 556:62]
                                sampleInterval <= args_4.value @[Decoder.scala 557:24]
                                skip @[Decoder.scala 556:62]
                skip @[Decoder.scala 536:29]
              instruction.io.deq.ready <= UInt<1>("h01") @[Decoder.scala 561:23]
              skip @[Decoder.scala 535:60]
            else : @[Decoder.scala 562:55]
              node _T_22 = eq(instruction.io.deq.bits.opcode, UInt<1>("h00")) @[Decoder.scala 562:38]
              when _T_22 : @[Decoder.scala 562:55]
                instruction.io.deq.ready <= UInt<1>("h01") @[Decoder.scala 563:23]
                io.nooped.valid <= UInt<1>("h01") @[Decoder.scala 564:21]
                skip @[Decoder.scala 562:55]
              else : @[Decoder.scala 565:15]
                instruction.io.deq.ready <= UInt<1>("h01") @[Decoder.scala 566:23]
                io.skipped.valid <= UInt<1>("h01") @[Decoder.scala 567:22]
                skip @[Decoder.scala 565:15]
    inst validator of Validator @[Decoder.scala 571:27]
    validator.clock <= clock
    validator.reset <= reset
    validator.io.instruction.bits.arguments <= instruction.io.deq.bits.arguments @[Decoder.scala 572:35]
    validator.io.instruction.bits.flags <= instruction.io.deq.bits.flags @[Decoder.scala 572:35]
    validator.io.instruction.bits.opcode <= instruction.io.deq.bits.opcode @[Decoder.scala 572:35]
    validator.io.instruction.valid <= instruction.io.deq.valid @[Decoder.scala 573:36]
    io.error <= validator.io.error @[Decoder.scala 574:14]
    wire _io_sample_bits_bits_WIRE : {flags : {instruction : {ready : UInt<1>, valid : UInt<1>}, memPortA : {ready : UInt<1>, valid : UInt<1>}, memPortB : {ready : UInt<1>, valid : UInt<1>}, dram0 : {ready : UInt<1>, valid : UInt<1>}, dram1 : {ready : UInt<1>, valid : UInt<1>}, dataflow : {ready : UInt<1>, valid : UInt<1>}, acc : {ready : UInt<1>, valid : UInt<1>}, array : {ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>} @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.programCounter <= UInt<32>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.array.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.array.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.acc.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.acc.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dataflow.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dataflow.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dram1.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dram1.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dram0.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.dram0.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.memPortB.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.memPortB.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.memPortA.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.memPortA.ready <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.instruction.valid <= UInt<1>("h00") @[package.scala 80:57]
    _io_sample_bits_bits_WIRE.flags.instruction.ready <= UInt<1>("h00") @[package.scala 80:57]
    io.sample.bits.bits.programCounter <= _io_sample_bits_bits_WIRE.programCounter @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.array.valid <= _io_sample_bits_bits_WIRE.flags.array.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.array.ready <= _io_sample_bits_bits_WIRE.flags.array.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.acc.valid <= _io_sample_bits_bits_WIRE.flags.acc.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.acc.ready <= _io_sample_bits_bits_WIRE.flags.acc.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dataflow.valid <= _io_sample_bits_bits_WIRE.flags.dataflow.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dataflow.ready <= _io_sample_bits_bits_WIRE.flags.dataflow.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dram1.valid <= _io_sample_bits_bits_WIRE.flags.dram1.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dram1.ready <= _io_sample_bits_bits_WIRE.flags.dram1.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dram0.valid <= _io_sample_bits_bits_WIRE.flags.dram0.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.dram0.ready <= _io_sample_bits_bits_WIRE.flags.dram0.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.memPortB.valid <= _io_sample_bits_bits_WIRE.flags.memPortB.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.memPortB.ready <= _io_sample_bits_bits_WIRE.flags.memPortB.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.memPortA.valid <= _io_sample_bits_bits_WIRE.flags.memPortA.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.memPortA.ready <= _io_sample_bits_bits_WIRE.flags.memPortA.ready @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.instruction.valid <= _io_sample_bits_bits_WIRE.flags.instruction.valid @[Decoder.scala 593:25]
    io.sample.bits.bits.flags.instruction.ready <= _io_sample_bits_bits_WIRE.flags.instruction.ready @[Decoder.scala 593:25]
    io.sample.bits.last <= UInt<1>("h00") @[Decoder.scala 594:25]
    io.sample.valid <= UInt<1>("h00") @[Decoder.scala 595:21]
    
  module MAC : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_16 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_17 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_18 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_19 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_20 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_21 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_22 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_23 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_24 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_25 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_26 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_27 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_28 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_29 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_30 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_31 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_32 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_33 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_34 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_35 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_36 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_37 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_38 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_39 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_40 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_41 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_42 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_43 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_44 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_45 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_46 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_47 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_48 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_49 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_50 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_51 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_52 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_53 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_54 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_55 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_56 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_57 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_58 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_59 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_60 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_61 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_62 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module MAC_63 : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip mulInput : Fixed<16><<8>>, flip addInput : Fixed<16><<8>>, output : Fixed<16><<8>>, passthrough : Fixed<16><<8>>}
    
    wire _weight_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _weight_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _weight_T_1 = asFixedPoint(_weight_T, 8) @[package.scala 79:56]
    _weight_WIRE <= _weight_T_1 @[package.scala 79:56]
    reg weight : Fixed<<8>>, clock with : (reset => (reset, _weight_WIRE)) @[MAC.scala 18:28]
    wire _passthrough_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _passthrough_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _passthrough_T_1 = asFixedPoint(_passthrough_T, 8) @[package.scala 79:56]
    _passthrough_WIRE <= _passthrough_T_1 @[package.scala 79:56]
    reg passthrough : Fixed<<8>>, clock with : (reset => (reset, _passthrough_WIRE)) @[MAC.scala 19:28]
    wire _output_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _output_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _output_T_1 = asFixedPoint(_output_T, 8) @[package.scala 79:56]
    _output_WIRE <= _output_T_1 @[package.scala 79:56]
    reg output : Fixed<<8>>, clock with : (reset => (reset, _output_WIRE)) @[MAC.scala 20:28]
    io.passthrough <= passthrough @[MAC.scala 22:18]
    passthrough <= io.mulInput @[MAC.scala 23:15]
    when io.load : @[MAC.scala 25:17]
      weight <= io.addInput @[MAC.scala 26:12]
      io.output <= weight @[MAC.scala 27:15]
      skip @[MAC.scala 25:17]
    else : @[MAC.scala 28:15]
      node _output_T_2 = asSInt(io.mulInput) @[package.scala 152:36]
      node _output_T_3 = asSInt(weight) @[package.scala 152:48]
      node _output_T_4 = asSInt(io.addInput) @[package.scala 152:60]
      node _output_mac_T = mul(_output_T_2, _output_T_3) @[package.scala 122:18]
      node _output_mac_T_1 = shl(_output_T_4, 8) @[package.scala 122:29]
      node output_mac = add(_output_mac_T, _output_mac_T_1) @[package.scala 122:23]
      node output_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _output_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _output_mask1_T_1 = sub(_output_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _output_mask1_T_2 = tail(_output_mask1_T_1, 1) @[package.scala 125:44]
      node output_mask1 = asSInt(_output_mask1_T_2) @[package.scala 125:44]
      node output_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _output_adjustment_T = and(output_mac, output_mask0) @[package.scala 130:16]
      node _output_adjustment_T_1 = asSInt(_output_adjustment_T) @[package.scala 130:16]
      node _output_adjustment_T_2 = neq(_output_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _output_adjustment_T_3 = and(output_mac, output_mask1) @[package.scala 130:44]
      node _output_adjustment_T_4 = asSInt(_output_adjustment_T_3) @[package.scala 130:44]
      node _output_adjustment_T_5 = neq(_output_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _output_adjustment_T_6 = and(output_mac, output_mask2) @[package.scala 130:71]
      node _output_adjustment_T_7 = asSInt(_output_adjustment_T_6) @[package.scala 130:71]
      node _output_adjustment_T_8 = neq(_output_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _output_adjustment_T_9 = or(_output_adjustment_T_5, _output_adjustment_T_8) @[package.scala 130:62]
      node _output_adjustment_T_10 = and(_output_adjustment_T_2, _output_adjustment_T_9) @[package.scala 130:34]
      node output_adjustment = mux(_output_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _output_adjusted_T = shr(output_mac, 8) @[package.scala 135:26]
      node _output_adjusted_T_1 = add(_output_adjusted_T, output_adjustment) @[package.scala 135:42]
      node _output_adjusted_T_2 = tail(_output_adjusted_T_1, 1) @[package.scala 135:42]
      node output_adjusted = asSInt(_output_adjusted_T_2) @[package.scala 135:42]
      node _output_saturated_T = gt(output_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _output_saturated_T_1 = lt(output_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _output_saturated_T_2 = mux(_output_saturated_T_1, asSInt(UInt<16>("h08000")), output_adjusted) @[package.scala 103:26]
      node output_saturated = mux(_output_saturated_T, asSInt(UInt<16>("h07fff")), _output_saturated_T_2) @[package.scala 103:8]
      node _output_T_5 = asFixedPoint(output_saturated, 8) @[package.scala 138:27]
      output <= _output_T_5 @[MAC.scala 29:12]
      io.output <= output @[MAC.scala 30:15]
      skip @[MAC.scala 28:15]
    
  module InnerSystolicArray : 
    input clock : Clock
    input reset : Reset
    output io : {flip load : UInt<1>, flip input : Fixed<16><<8>>[8], flip weight : Fixed<16><<8>>[8], output : Fixed<16><<8>>[8]}
    
    inst mac_0_0 of MAC @[InnerSystolicArray.scala 34:50]
    mac_0_0.clock <= clock
    mac_0_0.reset <= reset
    inst mac_0_1 of MAC_1 @[InnerSystolicArray.scala 34:50]
    mac_0_1.clock <= clock
    mac_0_1.reset <= reset
    inst mac_0_2 of MAC_2 @[InnerSystolicArray.scala 34:50]
    mac_0_2.clock <= clock
    mac_0_2.reset <= reset
    inst mac_0_3 of MAC_3 @[InnerSystolicArray.scala 34:50]
    mac_0_3.clock <= clock
    mac_0_3.reset <= reset
    inst mac_0_4 of MAC_4 @[InnerSystolicArray.scala 34:50]
    mac_0_4.clock <= clock
    mac_0_4.reset <= reset
    inst mac_0_5 of MAC_5 @[InnerSystolicArray.scala 34:50]
    mac_0_5.clock <= clock
    mac_0_5.reset <= reset
    inst mac_0_6 of MAC_6 @[InnerSystolicArray.scala 34:50]
    mac_0_6.clock <= clock
    mac_0_6.reset <= reset
    inst mac_0_7 of MAC_7 @[InnerSystolicArray.scala 34:50]
    mac_0_7.clock <= clock
    mac_0_7.reset <= reset
    inst mac_1_0 of MAC_8 @[InnerSystolicArray.scala 34:50]
    mac_1_0.clock <= clock
    mac_1_0.reset <= reset
    inst mac_1_1 of MAC_9 @[InnerSystolicArray.scala 34:50]
    mac_1_1.clock <= clock
    mac_1_1.reset <= reset
    inst mac_1_2 of MAC_10 @[InnerSystolicArray.scala 34:50]
    mac_1_2.clock <= clock
    mac_1_2.reset <= reset
    inst mac_1_3 of MAC_11 @[InnerSystolicArray.scala 34:50]
    mac_1_3.clock <= clock
    mac_1_3.reset <= reset
    inst mac_1_4 of MAC_12 @[InnerSystolicArray.scala 34:50]
    mac_1_4.clock <= clock
    mac_1_4.reset <= reset
    inst mac_1_5 of MAC_13 @[InnerSystolicArray.scala 34:50]
    mac_1_5.clock <= clock
    mac_1_5.reset <= reset
    inst mac_1_6 of MAC_14 @[InnerSystolicArray.scala 34:50]
    mac_1_6.clock <= clock
    mac_1_6.reset <= reset
    inst mac_1_7 of MAC_15 @[InnerSystolicArray.scala 34:50]
    mac_1_7.clock <= clock
    mac_1_7.reset <= reset
    inst mac_2_0 of MAC_16 @[InnerSystolicArray.scala 34:50]
    mac_2_0.clock <= clock
    mac_2_0.reset <= reset
    inst mac_2_1 of MAC_17 @[InnerSystolicArray.scala 34:50]
    mac_2_1.clock <= clock
    mac_2_1.reset <= reset
    inst mac_2_2 of MAC_18 @[InnerSystolicArray.scala 34:50]
    mac_2_2.clock <= clock
    mac_2_2.reset <= reset
    inst mac_2_3 of MAC_19 @[InnerSystolicArray.scala 34:50]
    mac_2_3.clock <= clock
    mac_2_3.reset <= reset
    inst mac_2_4 of MAC_20 @[InnerSystolicArray.scala 34:50]
    mac_2_4.clock <= clock
    mac_2_4.reset <= reset
    inst mac_2_5 of MAC_21 @[InnerSystolicArray.scala 34:50]
    mac_2_5.clock <= clock
    mac_2_5.reset <= reset
    inst mac_2_6 of MAC_22 @[InnerSystolicArray.scala 34:50]
    mac_2_6.clock <= clock
    mac_2_6.reset <= reset
    inst mac_2_7 of MAC_23 @[InnerSystolicArray.scala 34:50]
    mac_2_7.clock <= clock
    mac_2_7.reset <= reset
    inst mac_3_0 of MAC_24 @[InnerSystolicArray.scala 34:50]
    mac_3_0.clock <= clock
    mac_3_0.reset <= reset
    inst mac_3_1 of MAC_25 @[InnerSystolicArray.scala 34:50]
    mac_3_1.clock <= clock
    mac_3_1.reset <= reset
    inst mac_3_2 of MAC_26 @[InnerSystolicArray.scala 34:50]
    mac_3_2.clock <= clock
    mac_3_2.reset <= reset
    inst mac_3_3 of MAC_27 @[InnerSystolicArray.scala 34:50]
    mac_3_3.clock <= clock
    mac_3_3.reset <= reset
    inst mac_3_4 of MAC_28 @[InnerSystolicArray.scala 34:50]
    mac_3_4.clock <= clock
    mac_3_4.reset <= reset
    inst mac_3_5 of MAC_29 @[InnerSystolicArray.scala 34:50]
    mac_3_5.clock <= clock
    mac_3_5.reset <= reset
    inst mac_3_6 of MAC_30 @[InnerSystolicArray.scala 34:50]
    mac_3_6.clock <= clock
    mac_3_6.reset <= reset
    inst mac_3_7 of MAC_31 @[InnerSystolicArray.scala 34:50]
    mac_3_7.clock <= clock
    mac_3_7.reset <= reset
    inst mac_4_0 of MAC_32 @[InnerSystolicArray.scala 34:50]
    mac_4_0.clock <= clock
    mac_4_0.reset <= reset
    inst mac_4_1 of MAC_33 @[InnerSystolicArray.scala 34:50]
    mac_4_1.clock <= clock
    mac_4_1.reset <= reset
    inst mac_4_2 of MAC_34 @[InnerSystolicArray.scala 34:50]
    mac_4_2.clock <= clock
    mac_4_2.reset <= reset
    inst mac_4_3 of MAC_35 @[InnerSystolicArray.scala 34:50]
    mac_4_3.clock <= clock
    mac_4_3.reset <= reset
    inst mac_4_4 of MAC_36 @[InnerSystolicArray.scala 34:50]
    mac_4_4.clock <= clock
    mac_4_4.reset <= reset
    inst mac_4_5 of MAC_37 @[InnerSystolicArray.scala 34:50]
    mac_4_5.clock <= clock
    mac_4_5.reset <= reset
    inst mac_4_6 of MAC_38 @[InnerSystolicArray.scala 34:50]
    mac_4_6.clock <= clock
    mac_4_6.reset <= reset
    inst mac_4_7 of MAC_39 @[InnerSystolicArray.scala 34:50]
    mac_4_7.clock <= clock
    mac_4_7.reset <= reset
    inst mac_5_0 of MAC_40 @[InnerSystolicArray.scala 34:50]
    mac_5_0.clock <= clock
    mac_5_0.reset <= reset
    inst mac_5_1 of MAC_41 @[InnerSystolicArray.scala 34:50]
    mac_5_1.clock <= clock
    mac_5_1.reset <= reset
    inst mac_5_2 of MAC_42 @[InnerSystolicArray.scala 34:50]
    mac_5_2.clock <= clock
    mac_5_2.reset <= reset
    inst mac_5_3 of MAC_43 @[InnerSystolicArray.scala 34:50]
    mac_5_3.clock <= clock
    mac_5_3.reset <= reset
    inst mac_5_4 of MAC_44 @[InnerSystolicArray.scala 34:50]
    mac_5_4.clock <= clock
    mac_5_4.reset <= reset
    inst mac_5_5 of MAC_45 @[InnerSystolicArray.scala 34:50]
    mac_5_5.clock <= clock
    mac_5_5.reset <= reset
    inst mac_5_6 of MAC_46 @[InnerSystolicArray.scala 34:50]
    mac_5_6.clock <= clock
    mac_5_6.reset <= reset
    inst mac_5_7 of MAC_47 @[InnerSystolicArray.scala 34:50]
    mac_5_7.clock <= clock
    mac_5_7.reset <= reset
    inst mac_6_0 of MAC_48 @[InnerSystolicArray.scala 34:50]
    mac_6_0.clock <= clock
    mac_6_0.reset <= reset
    inst mac_6_1 of MAC_49 @[InnerSystolicArray.scala 34:50]
    mac_6_1.clock <= clock
    mac_6_1.reset <= reset
    inst mac_6_2 of MAC_50 @[InnerSystolicArray.scala 34:50]
    mac_6_2.clock <= clock
    mac_6_2.reset <= reset
    inst mac_6_3 of MAC_51 @[InnerSystolicArray.scala 34:50]
    mac_6_3.clock <= clock
    mac_6_3.reset <= reset
    inst mac_6_4 of MAC_52 @[InnerSystolicArray.scala 34:50]
    mac_6_4.clock <= clock
    mac_6_4.reset <= reset
    inst mac_6_5 of MAC_53 @[InnerSystolicArray.scala 34:50]
    mac_6_5.clock <= clock
    mac_6_5.reset <= reset
    inst mac_6_6 of MAC_54 @[InnerSystolicArray.scala 34:50]
    mac_6_6.clock <= clock
    mac_6_6.reset <= reset
    inst mac_6_7 of MAC_55 @[InnerSystolicArray.scala 34:50]
    mac_6_7.clock <= clock
    mac_6_7.reset <= reset
    inst mac_7_0 of MAC_56 @[InnerSystolicArray.scala 34:50]
    mac_7_0.clock <= clock
    mac_7_0.reset <= reset
    inst mac_7_1 of MAC_57 @[InnerSystolicArray.scala 34:50]
    mac_7_1.clock <= clock
    mac_7_1.reset <= reset
    inst mac_7_2 of MAC_58 @[InnerSystolicArray.scala 34:50]
    mac_7_2.clock <= clock
    mac_7_2.reset <= reset
    inst mac_7_3 of MAC_59 @[InnerSystolicArray.scala 34:50]
    mac_7_3.clock <= clock
    mac_7_3.reset <= reset
    inst mac_7_4 of MAC_60 @[InnerSystolicArray.scala 34:50]
    mac_7_4.clock <= clock
    mac_7_4.reset <= reset
    inst mac_7_5 of MAC_61 @[InnerSystolicArray.scala 34:50]
    mac_7_5.clock <= clock
    mac_7_5.reset <= reset
    inst mac_7_6 of MAC_62 @[InnerSystolicArray.scala 34:50]
    mac_7_6.clock <= clock
    mac_7_6.reset <= reset
    inst mac_7_7 of MAC_63 @[InnerSystolicArray.scala 34:50]
    mac_7_7.clock <= clock
    mac_7_7.reset <= reset
    wire _bias_b_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_1 = asFixedPoint(_bias_b_T, 8) @[package.scala 79:56]
    _bias_b_WIRE <= _bias_b_T_1 @[package.scala 79:56]
    reg bias_0 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_0 <= io.weight[0] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_1 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_2 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_3 = asFixedPoint(_bias_b_T_2, 8) @[package.scala 79:56]
    _bias_b_WIRE_1 <= _bias_b_T_3 @[package.scala 79:56]
    reg bias_1 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_1)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_1 <= io.weight[1] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_5 = asFixedPoint(_bias_b_T_4, 8) @[package.scala 79:56]
    _bias_b_WIRE_2 <= _bias_b_T_5 @[package.scala 79:56]
    reg bias_2 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_2)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_2 <= io.weight[2] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_7 = asFixedPoint(_bias_b_T_6, 8) @[package.scala 79:56]
    _bias_b_WIRE_3 <= _bias_b_T_7 @[package.scala 79:56]
    reg bias_3 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_3)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_3 <= io.weight[3] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_4 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_8 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_9 = asFixedPoint(_bias_b_T_8, 8) @[package.scala 79:56]
    _bias_b_WIRE_4 <= _bias_b_T_9 @[package.scala 79:56]
    reg bias_4 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_4)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_4 <= io.weight[4] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_11 = asFixedPoint(_bias_b_T_10, 8) @[package.scala 79:56]
    _bias_b_WIRE_5 <= _bias_b_T_11 @[package.scala 79:56]
    reg bias_5 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_5)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_5 <= io.weight[5] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_6 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_12 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_13 = asFixedPoint(_bias_b_T_12, 8) @[package.scala 79:56]
    _bias_b_WIRE_6 <= _bias_b_T_13 @[package.scala 79:56]
    reg bias_6 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_6)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_6 <= io.weight[6] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    wire _bias_b_WIRE_7 : Fixed<16><<8>> @[package.scala 79:56]
    node _bias_b_T_14 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bias_b_T_15 = asFixedPoint(_bias_b_T_14, 8) @[package.scala 79:56]
    _bias_b_WIRE_7 <= _bias_b_T_15 @[package.scala 79:56]
    reg bias_7 : Fixed<<8>>, clock with : (reset => (reset, _bias_b_WIRE_7)) @[InnerSystolicArray.scala 37:20]
    when io.load : @[InnerSystolicArray.scala 38:19]
      bias_7 <= io.weight[7] @[InnerSystolicArray.scala 39:9]
      skip @[InnerSystolicArray.scala 38:19]
    mac_0_0.io.mulInput <= io.input[0] @[InnerSystolicArray.scala 48:27]
    mac_0_0.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_1_io_mulInput_sr_WIRE : Fixed<16><<8>>[1] @[package.scala 80:57]
    node _mac_0_1_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_1_io_mulInput_sr_WIRE[0] <= _mac_0_1_io_mulInput_sr_T @[package.scala 80:57]
    reg mac_0_1_io_mulInput_sr : Fixed<16><<8>>[1], clock with : (reset => (reset, _mac_0_1_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_1_io_mulInput_sr[0] <= io.input[1] @[ShiftRegister.scala 25:12]
    mac_0_1.io.mulInput <= mac_0_1_io_mulInput_sr[0] @[InnerSystolicArray.scala 48:27]
    mac_0_1.io.addInput <= mac_0_0.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_1.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_2_io_mulInput_sr_WIRE : Fixed<16><<8>>[2] @[package.scala 80:57]
    node _mac_0_2_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_2_io_mulInput_sr_WIRE[0] <= _mac_0_2_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_2_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_2_io_mulInput_sr_WIRE[1] <= _mac_0_2_io_mulInput_sr_T_1 @[package.scala 80:57]
    reg mac_0_2_io_mulInput_sr : Fixed<16><<8>>[2], clock with : (reset => (reset, _mac_0_2_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_2_io_mulInput_sr[1] <= mac_0_2_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_2_io_mulInput_sr[0] <= io.input[2] @[ShiftRegister.scala 25:12]
    mac_0_2.io.mulInput <= mac_0_2_io_mulInput_sr[1] @[InnerSystolicArray.scala 48:27]
    mac_0_2.io.addInput <= mac_0_1.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_2.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_3_io_mulInput_sr_WIRE : Fixed<16><<8>>[3] @[package.scala 80:57]
    node _mac_0_3_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_3_io_mulInput_sr_WIRE[0] <= _mac_0_3_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_3_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_3_io_mulInput_sr_WIRE[1] <= _mac_0_3_io_mulInput_sr_T_1 @[package.scala 80:57]
    node _mac_0_3_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_3_io_mulInput_sr_WIRE[2] <= _mac_0_3_io_mulInput_sr_T_2 @[package.scala 80:57]
    reg mac_0_3_io_mulInput_sr : Fixed<16><<8>>[3], clock with : (reset => (reset, _mac_0_3_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_3_io_mulInput_sr[1] <= mac_0_3_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_3_io_mulInput_sr[2] <= mac_0_3_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_3_io_mulInput_sr[0] <= io.input[3] @[ShiftRegister.scala 25:12]
    mac_0_3.io.mulInput <= mac_0_3_io_mulInput_sr[2] @[InnerSystolicArray.scala 48:27]
    mac_0_3.io.addInput <= mac_0_2.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_3.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_4_io_mulInput_sr_WIRE : Fixed<16><<8>>[4] @[package.scala 80:57]
    node _mac_0_4_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_4_io_mulInput_sr_WIRE[0] <= _mac_0_4_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_4_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_4_io_mulInput_sr_WIRE[1] <= _mac_0_4_io_mulInput_sr_T_1 @[package.scala 80:57]
    node _mac_0_4_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_4_io_mulInput_sr_WIRE[2] <= _mac_0_4_io_mulInput_sr_T_2 @[package.scala 80:57]
    node _mac_0_4_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_4_io_mulInput_sr_WIRE[3] <= _mac_0_4_io_mulInput_sr_T_3 @[package.scala 80:57]
    reg mac_0_4_io_mulInput_sr : Fixed<16><<8>>[4], clock with : (reset => (reset, _mac_0_4_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_4_io_mulInput_sr[1] <= mac_0_4_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[2] <= mac_0_4_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[3] <= mac_0_4_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_4_io_mulInput_sr[0] <= io.input[4] @[ShiftRegister.scala 25:12]
    mac_0_4.io.mulInput <= mac_0_4_io_mulInput_sr[3] @[InnerSystolicArray.scala 48:27]
    mac_0_4.io.addInput <= mac_0_3.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_4.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_5_io_mulInput_sr_WIRE : Fixed<16><<8>>[5] @[package.scala 80:57]
    node _mac_0_5_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_5_io_mulInput_sr_WIRE[0] <= _mac_0_5_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_5_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_5_io_mulInput_sr_WIRE[1] <= _mac_0_5_io_mulInput_sr_T_1 @[package.scala 80:57]
    node _mac_0_5_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_5_io_mulInput_sr_WIRE[2] <= _mac_0_5_io_mulInput_sr_T_2 @[package.scala 80:57]
    node _mac_0_5_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_5_io_mulInput_sr_WIRE[3] <= _mac_0_5_io_mulInput_sr_T_3 @[package.scala 80:57]
    node _mac_0_5_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_5_io_mulInput_sr_WIRE[4] <= _mac_0_5_io_mulInput_sr_T_4 @[package.scala 80:57]
    reg mac_0_5_io_mulInput_sr : Fixed<16><<8>>[5], clock with : (reset => (reset, _mac_0_5_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_5_io_mulInput_sr[1] <= mac_0_5_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[2] <= mac_0_5_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[3] <= mac_0_5_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[4] <= mac_0_5_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_5_io_mulInput_sr[0] <= io.input[5] @[ShiftRegister.scala 25:12]
    mac_0_5.io.mulInput <= mac_0_5_io_mulInput_sr[4] @[InnerSystolicArray.scala 48:27]
    mac_0_5.io.addInput <= mac_0_4.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_5.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_6_io_mulInput_sr_WIRE : Fixed<16><<8>>[6] @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[0] <= _mac_0_6_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[1] <= _mac_0_6_io_mulInput_sr_T_1 @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[2] <= _mac_0_6_io_mulInput_sr_T_2 @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[3] <= _mac_0_6_io_mulInput_sr_T_3 @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[4] <= _mac_0_6_io_mulInput_sr_T_4 @[package.scala 80:57]
    node _mac_0_6_io_mulInput_sr_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_6_io_mulInput_sr_WIRE[5] <= _mac_0_6_io_mulInput_sr_T_5 @[package.scala 80:57]
    reg mac_0_6_io_mulInput_sr : Fixed<16><<8>>[6], clock with : (reset => (reset, _mac_0_6_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_6_io_mulInput_sr[1] <= mac_0_6_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[2] <= mac_0_6_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[3] <= mac_0_6_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[4] <= mac_0_6_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[5] <= mac_0_6_io_mulInput_sr[4] @[ShiftRegister.scala 13:11]
    mac_0_6_io_mulInput_sr[0] <= io.input[6] @[ShiftRegister.scala 25:12]
    mac_0_6.io.mulInput <= mac_0_6_io_mulInput_sr[5] @[InnerSystolicArray.scala 48:27]
    mac_0_6.io.addInput <= mac_0_5.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_6.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    wire _mac_0_7_io_mulInput_sr_WIRE : Fixed<16><<8>>[7] @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[0] <= _mac_0_7_io_mulInput_sr_T @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[1] <= _mac_0_7_io_mulInput_sr_T_1 @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[2] <= _mac_0_7_io_mulInput_sr_T_2 @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[3] <= _mac_0_7_io_mulInput_sr_T_3 @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[4] <= _mac_0_7_io_mulInput_sr_T_4 @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[5] <= _mac_0_7_io_mulInput_sr_T_5 @[package.scala 80:57]
    node _mac_0_7_io_mulInput_sr_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _mac_0_7_io_mulInput_sr_WIRE[6] <= _mac_0_7_io_mulInput_sr_T_6 @[package.scala 80:57]
    reg mac_0_7_io_mulInput_sr : Fixed<16><<8>>[7], clock with : (reset => (reset, _mac_0_7_io_mulInput_sr_WIRE)) @[ShiftRegister.scala 10:22]
    mac_0_7_io_mulInput_sr[1] <= mac_0_7_io_mulInput_sr[0] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[2] <= mac_0_7_io_mulInput_sr[1] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[3] <= mac_0_7_io_mulInput_sr[2] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[4] <= mac_0_7_io_mulInput_sr[3] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[5] <= mac_0_7_io_mulInput_sr[4] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[6] <= mac_0_7_io_mulInput_sr[5] @[ShiftRegister.scala 13:11]
    mac_0_7_io_mulInput_sr[0] <= io.input[7] @[ShiftRegister.scala 25:12]
    mac_0_7.io.mulInput <= mac_0_7_io_mulInput_sr[6] @[InnerSystolicArray.scala 48:27]
    mac_0_7.io.addInput <= mac_0_6.io.output @[InnerSystolicArray.scala 50:29]
    mac_0_7.io.load <= io.load @[InnerSystolicArray.scala 52:23]
    mac_0_0.io.addInput <= bias_0 @[InnerSystolicArray.scala 57:27]
    mac_1_0.io.addInput <= bias_1 @[InnerSystolicArray.scala 57:27]
    mac_1_0.io.mulInput <= mac_0_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_1_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_2_0.io.addInput <= bias_2 @[InnerSystolicArray.scala 57:27]
    mac_2_0.io.mulInput <= mac_1_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_2_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_3_0.io.addInput <= bias_3 @[InnerSystolicArray.scala 57:27]
    mac_3_0.io.mulInput <= mac_2_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_3_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_4_0.io.addInput <= bias_4 @[InnerSystolicArray.scala 57:27]
    mac_4_0.io.mulInput <= mac_3_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_4_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_5_0.io.addInput <= bias_5 @[InnerSystolicArray.scala 57:27]
    mac_5_0.io.mulInput <= mac_4_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_5_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_6_0.io.addInput <= bias_6 @[InnerSystolicArray.scala 57:27]
    mac_6_0.io.mulInput <= mac_5_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_6_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_7_0.io.addInput <= bias_7 @[InnerSystolicArray.scala 57:27]
    mac_7_0.io.mulInput <= mac_6_0.io.passthrough @[InnerSystolicArray.scala 59:29]
    mac_7_0.io.load <= io.load @[InnerSystolicArray.scala 60:25]
    mac_1_1.io.mulInput <= mac_0_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_1.io.addInput <= mac_1_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_2.io.mulInput <= mac_0_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_2.io.addInput <= mac_1_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_3.io.mulInput <= mac_0_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_3.io.addInput <= mac_1_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_4.io.mulInput <= mac_0_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_4.io.addInput <= mac_1_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_5.io.mulInput <= mac_0_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_5.io.addInput <= mac_1_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_6.io.mulInput <= mac_0_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_6.io.addInput <= mac_1_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_1_7.io.mulInput <= mac_0_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_1_7.io.addInput <= mac_1_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_1_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_1.io.mulInput <= mac_1_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_1.io.addInput <= mac_2_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_2.io.mulInput <= mac_1_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_2.io.addInput <= mac_2_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_3.io.mulInput <= mac_1_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_3.io.addInput <= mac_2_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_4.io.mulInput <= mac_1_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_4.io.addInput <= mac_2_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_5.io.mulInput <= mac_1_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_5.io.addInput <= mac_2_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_6.io.mulInput <= mac_1_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_6.io.addInput <= mac_2_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_2_7.io.mulInput <= mac_1_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_2_7.io.addInput <= mac_2_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_2_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_1.io.mulInput <= mac_2_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_1.io.addInput <= mac_3_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_2.io.mulInput <= mac_2_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_2.io.addInput <= mac_3_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_3.io.mulInput <= mac_2_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_3.io.addInput <= mac_3_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_4.io.mulInput <= mac_2_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_4.io.addInput <= mac_3_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_5.io.mulInput <= mac_2_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_5.io.addInput <= mac_3_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_6.io.mulInput <= mac_2_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_6.io.addInput <= mac_3_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_3_7.io.mulInput <= mac_2_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_3_7.io.addInput <= mac_3_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_3_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_1.io.mulInput <= mac_3_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_1.io.addInput <= mac_4_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_2.io.mulInput <= mac_3_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_2.io.addInput <= mac_4_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_3.io.mulInput <= mac_3_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_3.io.addInput <= mac_4_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_4.io.mulInput <= mac_3_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_4.io.addInput <= mac_4_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_5.io.mulInput <= mac_3_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_5.io.addInput <= mac_4_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_6.io.mulInput <= mac_3_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_6.io.addInput <= mac_4_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_4_7.io.mulInput <= mac_3_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_4_7.io.addInput <= mac_4_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_4_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_1.io.mulInput <= mac_4_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_1.io.addInput <= mac_5_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_2.io.mulInput <= mac_4_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_2.io.addInput <= mac_5_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_3.io.mulInput <= mac_4_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_3.io.addInput <= mac_5_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_4.io.mulInput <= mac_4_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_4.io.addInput <= mac_5_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_5.io.mulInput <= mac_4_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_5.io.addInput <= mac_5_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_6.io.mulInput <= mac_4_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_6.io.addInput <= mac_5_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_5_7.io.mulInput <= mac_4_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_5_7.io.addInput <= mac_5_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_5_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_1.io.mulInput <= mac_5_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_1.io.addInput <= mac_6_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_2.io.mulInput <= mac_5_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_2.io.addInput <= mac_6_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_3.io.mulInput <= mac_5_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_3.io.addInput <= mac_6_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_4.io.mulInput <= mac_5_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_4.io.addInput <= mac_6_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_5.io.mulInput <= mac_5_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_5.io.addInput <= mac_6_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_6.io.mulInput <= mac_5_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_6.io.addInput <= mac_6_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_6_7.io.mulInput <= mac_5_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_6_7.io.addInput <= mac_6_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_6_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_1.io.mulInput <= mac_6_1.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_1.io.addInput <= mac_7_0.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_1.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_2.io.mulInput <= mac_6_2.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_2.io.addInput <= mac_7_1.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_2.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_3.io.mulInput <= mac_6_3.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_3.io.addInput <= mac_7_2.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_3.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_4.io.mulInput <= mac_6_4.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_4.io.addInput <= mac_7_3.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_4.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_5.io.mulInput <= mac_6_5.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_5.io.addInput <= mac_7_4.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_5.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_6.io.mulInput <= mac_6_6.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_6.io.addInput <= mac_7_5.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_6.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    mac_7_7.io.mulInput <= mac_6_7.io.passthrough @[InnerSystolicArray.scala 67:29]
    mac_7_7.io.addInput <= mac_7_6.io.output @[InnerSystolicArray.scala 68:29]
    mac_7_7.io.load <= io.load @[InnerSystolicArray.scala 69:25]
    wire _io_output_0_sr_WIRE : Fixed<16><<8>>[7] @[package.scala 80:57]
    node _io_output_0_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[0] <= _io_output_0_sr_T @[package.scala 80:57]
    node _io_output_0_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[1] <= _io_output_0_sr_T_1 @[package.scala 80:57]
    node _io_output_0_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[2] <= _io_output_0_sr_T_2 @[package.scala 80:57]
    node _io_output_0_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[3] <= _io_output_0_sr_T_3 @[package.scala 80:57]
    node _io_output_0_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[4] <= _io_output_0_sr_T_4 @[package.scala 80:57]
    node _io_output_0_sr_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[5] <= _io_output_0_sr_T_5 @[package.scala 80:57]
    node _io_output_0_sr_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_0_sr_WIRE[6] <= _io_output_0_sr_T_6 @[package.scala 80:57]
    reg io_output_0_sr : Fixed<16><<8>>[7], clock with : (reset => (reset, _io_output_0_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_0_sr[1] <= io_output_0_sr[0] @[ShiftRegister.scala 13:11]
    io_output_0_sr[2] <= io_output_0_sr[1] @[ShiftRegister.scala 13:11]
    io_output_0_sr[3] <= io_output_0_sr[2] @[ShiftRegister.scala 13:11]
    io_output_0_sr[4] <= io_output_0_sr[3] @[ShiftRegister.scala 13:11]
    io_output_0_sr[5] <= io_output_0_sr[4] @[ShiftRegister.scala 13:11]
    io_output_0_sr[6] <= io_output_0_sr[5] @[ShiftRegister.scala 13:11]
    io_output_0_sr[0] <= mac_0_7.io.output @[ShiftRegister.scala 25:12]
    io.output[0] <= io_output_0_sr[6] @[InnerSystolicArray.scala 75:18]
    wire _io_output_1_sr_WIRE : Fixed<16><<8>>[6] @[package.scala 80:57]
    node _io_output_1_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[0] <= _io_output_1_sr_T @[package.scala 80:57]
    node _io_output_1_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[1] <= _io_output_1_sr_T_1 @[package.scala 80:57]
    node _io_output_1_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[2] <= _io_output_1_sr_T_2 @[package.scala 80:57]
    node _io_output_1_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[3] <= _io_output_1_sr_T_3 @[package.scala 80:57]
    node _io_output_1_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[4] <= _io_output_1_sr_T_4 @[package.scala 80:57]
    node _io_output_1_sr_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_1_sr_WIRE[5] <= _io_output_1_sr_T_5 @[package.scala 80:57]
    reg io_output_1_sr : Fixed<16><<8>>[6], clock with : (reset => (reset, _io_output_1_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_1_sr[1] <= io_output_1_sr[0] @[ShiftRegister.scala 13:11]
    io_output_1_sr[2] <= io_output_1_sr[1] @[ShiftRegister.scala 13:11]
    io_output_1_sr[3] <= io_output_1_sr[2] @[ShiftRegister.scala 13:11]
    io_output_1_sr[4] <= io_output_1_sr[3] @[ShiftRegister.scala 13:11]
    io_output_1_sr[5] <= io_output_1_sr[4] @[ShiftRegister.scala 13:11]
    io_output_1_sr[0] <= mac_1_7.io.output @[ShiftRegister.scala 25:12]
    io.output[1] <= io_output_1_sr[5] @[InnerSystolicArray.scala 75:18]
    wire _io_output_2_sr_WIRE : Fixed<16><<8>>[5] @[package.scala 80:57]
    node _io_output_2_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_2_sr_WIRE[0] <= _io_output_2_sr_T @[package.scala 80:57]
    node _io_output_2_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_2_sr_WIRE[1] <= _io_output_2_sr_T_1 @[package.scala 80:57]
    node _io_output_2_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_2_sr_WIRE[2] <= _io_output_2_sr_T_2 @[package.scala 80:57]
    node _io_output_2_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_2_sr_WIRE[3] <= _io_output_2_sr_T_3 @[package.scala 80:57]
    node _io_output_2_sr_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_2_sr_WIRE[4] <= _io_output_2_sr_T_4 @[package.scala 80:57]
    reg io_output_2_sr : Fixed<16><<8>>[5], clock with : (reset => (reset, _io_output_2_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_2_sr[1] <= io_output_2_sr[0] @[ShiftRegister.scala 13:11]
    io_output_2_sr[2] <= io_output_2_sr[1] @[ShiftRegister.scala 13:11]
    io_output_2_sr[3] <= io_output_2_sr[2] @[ShiftRegister.scala 13:11]
    io_output_2_sr[4] <= io_output_2_sr[3] @[ShiftRegister.scala 13:11]
    io_output_2_sr[0] <= mac_2_7.io.output @[ShiftRegister.scala 25:12]
    io.output[2] <= io_output_2_sr[4] @[InnerSystolicArray.scala 75:18]
    wire _io_output_3_sr_WIRE : Fixed<16><<8>>[4] @[package.scala 80:57]
    node _io_output_3_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_3_sr_WIRE[0] <= _io_output_3_sr_T @[package.scala 80:57]
    node _io_output_3_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_3_sr_WIRE[1] <= _io_output_3_sr_T_1 @[package.scala 80:57]
    node _io_output_3_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_3_sr_WIRE[2] <= _io_output_3_sr_T_2 @[package.scala 80:57]
    node _io_output_3_sr_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_3_sr_WIRE[3] <= _io_output_3_sr_T_3 @[package.scala 80:57]
    reg io_output_3_sr : Fixed<16><<8>>[4], clock with : (reset => (reset, _io_output_3_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_3_sr[1] <= io_output_3_sr[0] @[ShiftRegister.scala 13:11]
    io_output_3_sr[2] <= io_output_3_sr[1] @[ShiftRegister.scala 13:11]
    io_output_3_sr[3] <= io_output_3_sr[2] @[ShiftRegister.scala 13:11]
    io_output_3_sr[0] <= mac_3_7.io.output @[ShiftRegister.scala 25:12]
    io.output[3] <= io_output_3_sr[3] @[InnerSystolicArray.scala 75:18]
    wire _io_output_4_sr_WIRE : Fixed<16><<8>>[3] @[package.scala 80:57]
    node _io_output_4_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_4_sr_WIRE[0] <= _io_output_4_sr_T @[package.scala 80:57]
    node _io_output_4_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_4_sr_WIRE[1] <= _io_output_4_sr_T_1 @[package.scala 80:57]
    node _io_output_4_sr_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_4_sr_WIRE[2] <= _io_output_4_sr_T_2 @[package.scala 80:57]
    reg io_output_4_sr : Fixed<16><<8>>[3], clock with : (reset => (reset, _io_output_4_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_4_sr[1] <= io_output_4_sr[0] @[ShiftRegister.scala 13:11]
    io_output_4_sr[2] <= io_output_4_sr[1] @[ShiftRegister.scala 13:11]
    io_output_4_sr[0] <= mac_4_7.io.output @[ShiftRegister.scala 25:12]
    io.output[4] <= io_output_4_sr[2] @[InnerSystolicArray.scala 75:18]
    wire _io_output_5_sr_WIRE : Fixed<16><<8>>[2] @[package.scala 80:57]
    node _io_output_5_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_5_sr_WIRE[0] <= _io_output_5_sr_T @[package.scala 80:57]
    node _io_output_5_sr_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_5_sr_WIRE[1] <= _io_output_5_sr_T_1 @[package.scala 80:57]
    reg io_output_5_sr : Fixed<16><<8>>[2], clock with : (reset => (reset, _io_output_5_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_5_sr[1] <= io_output_5_sr[0] @[ShiftRegister.scala 13:11]
    io_output_5_sr[0] <= mac_5_7.io.output @[ShiftRegister.scala 25:12]
    io.output[5] <= io_output_5_sr[1] @[InnerSystolicArray.scala 75:18]
    wire _io_output_6_sr_WIRE : Fixed<16><<8>>[1] @[package.scala 80:57]
    node _io_output_6_sr_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_output_6_sr_WIRE[0] <= _io_output_6_sr_T @[package.scala 80:57]
    reg io_output_6_sr : Fixed<16><<8>>[1], clock with : (reset => (reset, _io_output_6_sr_WIRE)) @[ShiftRegister.scala 10:22]
    io_output_6_sr[0] <= mac_6_7.io.output @[ShiftRegister.scala 25:12]
    io.output[6] <= io_output_6_sr[0] @[InnerSystolicArray.scala 75:18]
    io.output[7] <= mac_7_7.io.output @[InnerSystolicArray.scala 75:18]
    
  module Queue_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<4>}
    
    cmem ram : Fixed<16><<8>>[8][15] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<4>("h0e")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      when wrap : @[Counter.scala 86:20]
        enq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("h0e")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      when wrap_1 : @[Counter.scala 86:20]
        deq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = mux(maybe_full, UInt<4>("h0f"), UInt<1>("h00")) @[Decoupled.scala 262:24]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 264:39]
    node _io_count_T_2 = add(UInt<4>("h0f"), ptr_diff) @[Decoupled.scala 265:38]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 265:38]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 264:24]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 261:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 261:14]
    
  module Queue_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {zeroes : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {zeroes : UInt<1>}}, count : UInt<5>}
    
    cmem ram : {zeroes : UInt<1>}[16] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.zeroes <= io.enq.bits.zeroes @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<4>("h0f")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.zeroes <= io_deq_bits_MPORT.zeroes @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits.zeroes <= io.enq.bits.zeroes @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<5>("h010"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module SystolicArray : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>}}, flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip weight : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, ran : {flip ready : UInt<1>, valid : UInt<1>, bits : {zeroes : UInt<1>}}, loaded : {flip ready : UInt<1>, valid : UInt<1>, bits : {zeroes : UInt<1>}}}
    
    inst array of InnerSystolicArray @[SystolicArray.scala 40:37]
    array.clock <= clock
    array.reset <= reset
    inst input of Queue_4 @[Decoupled.scala 296:21]
    input.clock <= clock
    input.reset <= reset
    input.io.enq.valid <= io.input.valid @[Decoupled.scala 297:22]
    input.io.enq.bits[0] <= io.input.bits[0] @[Decoupled.scala 298:21]
    input.io.enq.bits[1] <= io.input.bits[1] @[Decoupled.scala 298:21]
    input.io.enq.bits[2] <= io.input.bits[2] @[Decoupled.scala 298:21]
    input.io.enq.bits[3] <= io.input.bits[3] @[Decoupled.scala 298:21]
    input.io.enq.bits[4] <= io.input.bits[4] @[Decoupled.scala 298:21]
    input.io.enq.bits[5] <= io.input.bits[5] @[Decoupled.scala 298:21]
    input.io.enq.bits[6] <= io.input.bits[6] @[Decoupled.scala 298:21]
    input.io.enq.bits[7] <= io.input.bits[7] @[Decoupled.scala 298:21]
    io.input.ready <= input.io.enq.ready @[Decoupled.scala 299:17]
    inst output of Queue_5 @[SystolicArray.scala 45:22]
    output.clock <= clock
    output.reset <= reset
    io.loaded.bits.zeroes <= io.control.bits.zeroes @[SystolicArray.scala 52:25]
    io.loaded.valid <= array.io.load @[SystolicArray.scala 53:19]
    inst ran of Queue_6 @[SystolicArray.scala 54:19]
    ran.clock <= clock
    ran.reset <= reset
    ran.io.enq.bits.zeroes <= io.control.bits.zeroes @[SystolicArray.scala 57:26]
    io.ran.bits.zeroes <= ran.io.deq.bits.zeroes @[SystolicArray.scala 58:15]
    io.ran.valid <= ran.io.deq.valid @[SystolicArray.scala 59:16]
    node _ran_io_deq_ready_T = and(io.ran.ready, output.io.deq.valid) @[SystolicArray.scala 60:36]
    ran.io.deq.ready <= _ran_io_deq_ready_T @[SystolicArray.scala 60:20]
    node _runInput_T = eq(io.control.bits.load, UInt<1>("h00")) @[SystolicArray.scala 62:36]
    node _runInput_T_1 = and(io.control.valid, _runInput_T) @[SystolicArray.scala 62:33]
    node _runInput_T_2 = eq(io.control.bits.zeroes, UInt<1>("h00")) @[SystolicArray.scala 62:58]
    node runInput = and(_runInput_T_1, _runInput_T_2) @[SystolicArray.scala 62:55]
    node _runZeroes_T = eq(io.control.bits.load, UInt<1>("h00")) @[SystolicArray.scala 63:36]
    node _runZeroes_T_1 = and(io.control.valid, _runZeroes_T) @[SystolicArray.scala 63:33]
    node runZeroes = and(_runZeroes_T_1, io.control.bits.zeroes) @[SystolicArray.scala 63:55]
    node _loadWeight_T = and(io.control.valid, io.control.bits.load) @[SystolicArray.scala 65:19]
    node _loadWeight_T_1 = eq(io.control.bits.zeroes, UInt<1>("h00")) @[SystolicArray.scala 65:43]
    node loadWeight = and(_loadWeight_T, _loadWeight_T_1) @[SystolicArray.scala 65:40]
    node _loadZeroes_T = and(io.control.valid, io.control.bits.load) @[SystolicArray.scala 66:34]
    node loadZeroes = and(_loadZeroes_T, io.control.bits.zeroes) @[SystolicArray.scala 66:55]
    node _running_T = and(runInput, input.io.deq.valid) @[SystolicArray.scala 69:16]
    node _running_T_1 = and(_running_T, input.io.deq.ready) @[SystolicArray.scala 69:31]
    node _running_T_2 = or(_running_T_1, runZeroes) @[SystolicArray.scala 69:47]
    node running = and(_running_T_2, output.io.deq.ready) @[SystolicArray.scala 69:61]
    node _loading_T = and(loadWeight, io.weight.valid) @[SystolicArray.scala 70:29]
    node _loading_T_1 = and(_loading_T, io.weight.ready) @[SystolicArray.scala 70:45]
    node loading = or(_loading_T_1, loadZeroes) @[SystolicArray.scala 70:62]
    ran.io.enq.valid <= running @[SystolicArray.scala 72:20]
    reg arrayPropagationCountdown : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[SystolicArray.scala 74:42]
    when running : @[SystolicArray.scala 77:17]
      arrayPropagationCountdown <= UInt<4>("h0f") @[SystolicArray.scala 78:31]
      skip @[SystolicArray.scala 77:17]
    else : @[SystolicArray.scala 79:15]
      node _T = gt(arrayPropagationCountdown, UInt<1>("h00")) @[SystolicArray.scala 80:36]
      when _T : @[SystolicArray.scala 80:43]
        node _arrayPropagationCountdown_T = sub(arrayPropagationCountdown, UInt<1>("h01")) @[SystolicArray.scala 81:62]
        node _arrayPropagationCountdown_T_1 = tail(_arrayPropagationCountdown_T, 1) @[SystolicArray.scala 81:62]
        arrayPropagationCountdown <= _arrayPropagationCountdown_T_1 @[SystolicArray.scala 81:33]
        skip @[SystolicArray.scala 80:43]
      skip @[SystolicArray.scala 79:15]
    node inputDone = eq(arrayPropagationCountdown, UInt<1>("h00")) @[SystolicArray.scala 87:45]
    node _array_io_load_T = and(inputDone, loading) @[SystolicArray.scala 89:30]
    array.io.load <= _array_io_load_T @[SystolicArray.scala 89:17]
    wire _WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[0] <= _T_1 @[package.scala 80:57]
    node _T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[1] <= _T_2 @[package.scala 80:57]
    node _T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[2] <= _T_3 @[package.scala 80:57]
    node _T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[3] <= _T_4 @[package.scala 80:57]
    node _T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[4] <= _T_5 @[package.scala 80:57]
    node _T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[5] <= _T_6 @[package.scala 80:57]
    node _T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[6] <= _T_7 @[package.scala 80:57]
    node _T_8 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE[7] <= _T_8 @[package.scala 80:57]
    node _T_9 = mux(io.control.bits.zeroes, _WIRE, input.io.deq.bits) @[SystolicArray.scala 90:24]
    array.io.input[0] <= _T_9[0] @[SystolicArray.scala 90:18]
    array.io.input[1] <= _T_9[1] @[SystolicArray.scala 90:18]
    array.io.input[2] <= _T_9[2] @[SystolicArray.scala 90:18]
    array.io.input[3] <= _T_9[3] @[SystolicArray.scala 90:18]
    array.io.input[4] <= _T_9[4] @[SystolicArray.scala 90:18]
    array.io.input[5] <= _T_9[5] @[SystolicArray.scala 90:18]
    array.io.input[6] <= _T_9[6] @[SystolicArray.scala 90:18]
    array.io.input[7] <= _T_9[7] @[SystolicArray.scala 90:18]
    wire _WIRE_1 : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _T_10 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[0] <= _T_10 @[package.scala 80:57]
    node _T_11 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[1] <= _T_11 @[package.scala 80:57]
    node _T_12 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[2] <= _T_12 @[package.scala 80:57]
    node _T_13 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[3] <= _T_13 @[package.scala 80:57]
    node _T_14 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[4] <= _T_14 @[package.scala 80:57]
    node _T_15 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[5] <= _T_15 @[package.scala 80:57]
    node _T_16 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[6] <= _T_16 @[package.scala 80:57]
    node _T_17 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _WIRE_1[7] <= _T_17 @[package.scala 80:57]
    node _T_18 = mux(io.control.bits.zeroes, _WIRE_1, io.weight.bits) @[SystolicArray.scala 91:25]
    array.io.weight[0] <= _T_18[0] @[SystolicArray.scala 91:19]
    array.io.weight[1] <= _T_18[1] @[SystolicArray.scala 91:19]
    array.io.weight[2] <= _T_18[2] @[SystolicArray.scala 91:19]
    array.io.weight[3] <= _T_18[3] @[SystolicArray.scala 91:19]
    array.io.weight[4] <= _T_18[4] @[SystolicArray.scala 91:19]
    array.io.weight[5] <= _T_18[5] @[SystolicArray.scala 91:19]
    array.io.weight[6] <= _T_18[6] @[SystolicArray.scala 91:19]
    array.io.weight[7] <= _T_18[7] @[SystolicArray.scala 91:19]
    output.io.enq.bits[0] <= array.io.output[0] @[SystolicArray.scala 96:22]
    output.io.enq.bits[1] <= array.io.output[1] @[SystolicArray.scala 96:22]
    output.io.enq.bits[2] <= array.io.output[2] @[SystolicArray.scala 96:22]
    output.io.enq.bits[3] <= array.io.output[3] @[SystolicArray.scala 96:22]
    output.io.enq.bits[4] <= array.io.output[4] @[SystolicArray.scala 96:22]
    output.io.enq.bits[5] <= array.io.output[5] @[SystolicArray.scala 96:22]
    output.io.enq.bits[6] <= array.io.output[6] @[SystolicArray.scala 96:22]
    output.io.enq.bits[7] <= array.io.output[7] @[SystolicArray.scala 96:22]
    io.output.bits[0] <= output.io.deq.bits[0] @[SystolicArray.scala 97:13]
    io.output.bits[1] <= output.io.deq.bits[1] @[SystolicArray.scala 97:13]
    io.output.bits[2] <= output.io.deq.bits[2] @[SystolicArray.scala 97:13]
    io.output.bits[3] <= output.io.deq.bits[3] @[SystolicArray.scala 97:13]
    io.output.bits[4] <= output.io.deq.bits[4] @[SystolicArray.scala 97:13]
    io.output.bits[5] <= output.io.deq.bits[5] @[SystolicArray.scala 97:13]
    io.output.bits[6] <= output.io.deq.bits[6] @[SystolicArray.scala 97:13]
    io.output.bits[7] <= output.io.deq.bits[7] @[SystolicArray.scala 97:13]
    io.output.valid <= output.io.deq.valid @[SystolicArray.scala 97:13]
    output.io.deq.ready <= io.output.ready @[SystolicArray.scala 97:13]
    node _input_io_deq_ready_T = and(runInput, output.io.deq.ready) @[SystolicArray.scala 99:27]
    input.io.deq.ready <= _input_io_deq_ready_T @[SystolicArray.scala 99:15]
    node _io_weight_ready_T = and(loadWeight, inputDone) @[SystolicArray.scala 100:30]
    io.weight.ready <= _io_weight_ready_T @[SystolicArray.scala 100:16]
    node _io_control_ready_T = eq(io.control.bits.load, UInt<1>("h00")) @[SystolicArray.scala 101:21]
    node _io_control_ready_T_1 = or(io.control.bits.zeroes, input.io.deq.valid) @[SystolicArray.scala 101:64]
    node _io_control_ready_T_2 = and(_io_control_ready_T, _io_control_ready_T_1) @[SystolicArray.scala 101:40]
    node _io_control_ready_T_3 = and(_io_control_ready_T_2, output.io.deq.ready) @[SystolicArray.scala 101:80]
    node _io_control_ready_T_4 = or(io.control.bits.zeroes, io.weight.valid) @[SystolicArray.scala 102:48]
    node _io_control_ready_T_5 = and(io.control.bits.load, _io_control_ready_T_4) @[SystolicArray.scala 102:24]
    node _io_control_ready_T_6 = and(_io_control_ready_T_5, inputDone) @[SystolicArray.scala 102:65]
    node _io_control_ready_T_7 = or(_io_control_ready_T_3, _io_control_ready_T_6) @[SystolicArray.scala 101:104]
    io.control.ready <= _io_control_ready_T_7 @[SystolicArray.scala 101:17]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[15] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[1] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[2] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[3] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[4] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[5] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[6] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[7] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[8] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[9] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[10] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[11] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[12] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[13] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[14] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr : UInt<1>[15], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[1] <= output_io_enq_valid_sr[0] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[2] <= output_io_enq_valid_sr[1] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[3] <= output_io_enq_valid_sr[2] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[4] <= output_io_enq_valid_sr[3] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[5] <= output_io_enq_valid_sr[4] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[6] <= output_io_enq_valid_sr[5] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[7] <= output_io_enq_valid_sr[6] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[8] <= output_io_enq_valid_sr[7] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[9] <= output_io_enq_valid_sr[8] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[10] <= output_io_enq_valid_sr[9] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[11] <= output_io_enq_valid_sr[10] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[12] <= output_io_enq_valid_sr[11] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[13] <= output_io_enq_valid_sr[12] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[14] <= output_io_enq_valid_sr[13] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[0] <= running @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[14] @[SystolicArray.scala 105:23]
    
  extmodule bram_dp_128x64 : 
    input clka : UInt<1>
    input wea : UInt<1>
    input ena : UInt<1>
    input addra : UInt<6>
    input dia : UInt<128>
    output doa : UInt<128>
    input clkb : UInt<1>
    input web : UInt<1>
    input enb : UInt<1>
    input addrb : UInt<6>
    input dib : UInt<128>
    output dob : UInt<128>
    
    defname = bram_dp_128x64
    
    
  module InnerDualPortMem : 
    input clock : Clock
    input reset : Reset
    output io : {portA : {flip address : UInt<6>, read : {flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : {flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}, portB : {flip address : UInt<6>, read : {flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : {flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}}
    
    inst mem of bram_dp_128x64 @[DualPortMem.scala 164:25]
    mem.dob is invalid
    mem.dib is invalid
    mem.addrb is invalid
    mem.enb is invalid
    mem.web is invalid
    mem.clkb is invalid
    mem.doa is invalid
    mem.dia is invalid
    mem.addra is invalid
    mem.ena is invalid
    mem.wea is invalid
    mem.clka is invalid
    node _mem_io_clka_T = asUInt(clock) @[DualPortMem.scala 166:30]
    node _mem_io_clka_T_1 = bits(_mem_io_clka_T, 0, 0) @[DualPortMem.scala 166:30]
    mem.clka <= _mem_io_clka_T_1 @[DualPortMem.scala 166:21]
    node _mem_io_ena_T = asUInt(reset) @[DualPortMem.scala 167:30]
    node _mem_io_ena_T_1 = eq(_mem_io_ena_T, UInt<1>("h00")) @[DualPortMem.scala 167:23]
    mem.ena <= _mem_io_ena_T_1 @[DualPortMem.scala 167:20]
    mem.addra <= io.portA.address @[DualPortMem.scala 168:22]
    wire _io_portA_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 169:50]
    wire _io_portA_read_data_WIRE_1 : UInt<128>
    _io_portA_read_data_WIRE_1 <= mem.doa
    node _io_portA_read_data_T = bits(_io_portA_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_1 = asFixedPoint(_io_portA_read_data_T, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[0] <= _io_portA_read_data_T_1 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_2 = bits(_io_portA_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_3 = asFixedPoint(_io_portA_read_data_T_2, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[1] <= _io_portA_read_data_T_3 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_4 = bits(_io_portA_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_5 = asFixedPoint(_io_portA_read_data_T_4, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[2] <= _io_portA_read_data_T_5 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_6 = bits(_io_portA_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_7 = asFixedPoint(_io_portA_read_data_T_6, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[3] <= _io_portA_read_data_T_7 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_8 = bits(_io_portA_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_9 = asFixedPoint(_io_portA_read_data_T_8, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[4] <= _io_portA_read_data_T_9 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_10 = bits(_io_portA_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_11 = asFixedPoint(_io_portA_read_data_T_10, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[5] <= _io_portA_read_data_T_11 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_12 = bits(_io_portA_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_13 = asFixedPoint(_io_portA_read_data_T_12, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[6] <= _io_portA_read_data_T_13 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_14 = bits(_io_portA_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_15 = asFixedPoint(_io_portA_read_data_T_14, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[7] <= _io_portA_read_data_T_15 @[DualPortMem.scala 169:50]
    io.portA.read.data[0] <= _io_portA_read_data_WIRE[0] @[DualPortMem.scala 169:28]
    io.portA.read.data[1] <= _io_portA_read_data_WIRE[1] @[DualPortMem.scala 169:28]
    io.portA.read.data[2] <= _io_portA_read_data_WIRE[2] @[DualPortMem.scala 169:28]
    io.portA.read.data[3] <= _io_portA_read_data_WIRE[3] @[DualPortMem.scala 169:28]
    io.portA.read.data[4] <= _io_portA_read_data_WIRE[4] @[DualPortMem.scala 169:28]
    io.portA.read.data[5] <= _io_portA_read_data_WIRE[5] @[DualPortMem.scala 169:28]
    io.portA.read.data[6] <= _io_portA_read_data_WIRE[6] @[DualPortMem.scala 169:28]
    io.portA.read.data[7] <= _io_portA_read_data_WIRE[7] @[DualPortMem.scala 169:28]
    mem.wea <= io.portA.write.enable @[DualPortMem.scala 170:20]
    wire _mem_io_dia_WIRE : UInt<128> @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo_lo = asUInt(io.portA.write.data[0]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo_hi = asUInt(io.portA.write.data[1]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi_lo = asUInt(io.portA.write.data[2]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi_hi = asUInt(io.portA.write.data[3]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo_lo = asUInt(io.portA.write.data[4]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo_hi = asUInt(io.portA.write.data[5]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi_lo = asUInt(io.portA.write.data[6]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi_hi = asUInt(io.portA.write.data[7]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo = cat(mem_io_dia_lo_lo_hi, mem_io_dia_lo_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi = cat(mem_io_dia_lo_hi_hi, mem_io_dia_lo_hi_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo = cat(mem_io_dia_lo_hi, mem_io_dia_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo = cat(mem_io_dia_hi_lo_hi, mem_io_dia_hi_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi = cat(mem_io_dia_hi_hi_hi, mem_io_dia_hi_hi_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi = cat(mem_io_dia_hi_hi, mem_io_dia_hi_lo) @[DualPortMem.scala 171:51]
    node _mem_io_dia_T = cat(mem_io_dia_hi, mem_io_dia_lo) @[DualPortMem.scala 171:51]
    _mem_io_dia_WIRE <= _mem_io_dia_T @[DualPortMem.scala 171:51]
    mem.dia <= _mem_io_dia_WIRE @[DualPortMem.scala 171:20]
    node _mem_io_clkb_T = asUInt(clock) @[DualPortMem.scala 173:30]
    node _mem_io_clkb_T_1 = bits(_mem_io_clkb_T, 0, 0) @[DualPortMem.scala 173:30]
    mem.clkb <= _mem_io_clkb_T_1 @[DualPortMem.scala 173:21]
    node _mem_io_enb_T = asUInt(reset) @[DualPortMem.scala 174:30]
    node _mem_io_enb_T_1 = eq(_mem_io_enb_T, UInt<1>("h00")) @[DualPortMem.scala 174:23]
    mem.enb <= _mem_io_enb_T_1 @[DualPortMem.scala 174:20]
    mem.addrb <= io.portB.address @[DualPortMem.scala 175:22]
    wire _io_portB_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 176:50]
    wire _io_portB_read_data_WIRE_1 : UInt<128>
    _io_portB_read_data_WIRE_1 <= mem.dob
    node _io_portB_read_data_T = bits(_io_portB_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_1 = asFixedPoint(_io_portB_read_data_T, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[0] <= _io_portB_read_data_T_1 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_2 = bits(_io_portB_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_3 = asFixedPoint(_io_portB_read_data_T_2, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[1] <= _io_portB_read_data_T_3 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_4 = bits(_io_portB_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_5 = asFixedPoint(_io_portB_read_data_T_4, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[2] <= _io_portB_read_data_T_5 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_6 = bits(_io_portB_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_7 = asFixedPoint(_io_portB_read_data_T_6, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[3] <= _io_portB_read_data_T_7 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_8 = bits(_io_portB_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_9 = asFixedPoint(_io_portB_read_data_T_8, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[4] <= _io_portB_read_data_T_9 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_10 = bits(_io_portB_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_11 = asFixedPoint(_io_portB_read_data_T_10, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[5] <= _io_portB_read_data_T_11 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_12 = bits(_io_portB_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_13 = asFixedPoint(_io_portB_read_data_T_12, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[6] <= _io_portB_read_data_T_13 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_14 = bits(_io_portB_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_15 = asFixedPoint(_io_portB_read_data_T_14, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[7] <= _io_portB_read_data_T_15 @[DualPortMem.scala 176:50]
    io.portB.read.data[0] <= _io_portB_read_data_WIRE[0] @[DualPortMem.scala 176:28]
    io.portB.read.data[1] <= _io_portB_read_data_WIRE[1] @[DualPortMem.scala 176:28]
    io.portB.read.data[2] <= _io_portB_read_data_WIRE[2] @[DualPortMem.scala 176:28]
    io.portB.read.data[3] <= _io_portB_read_data_WIRE[3] @[DualPortMem.scala 176:28]
    io.portB.read.data[4] <= _io_portB_read_data_WIRE[4] @[DualPortMem.scala 176:28]
    io.portB.read.data[5] <= _io_portB_read_data_WIRE[5] @[DualPortMem.scala 176:28]
    io.portB.read.data[6] <= _io_portB_read_data_WIRE[6] @[DualPortMem.scala 176:28]
    io.portB.read.data[7] <= _io_portB_read_data_WIRE[7] @[DualPortMem.scala 176:28]
    mem.web <= io.portB.write.enable @[DualPortMem.scala 177:20]
    wire _mem_io_dib_WIRE : UInt<128> @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo_lo = asUInt(io.portB.write.data[0]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo_hi = asUInt(io.portB.write.data[1]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi_lo = asUInt(io.portB.write.data[2]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi_hi = asUInt(io.portB.write.data[3]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo_lo = asUInt(io.portB.write.data[4]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo_hi = asUInt(io.portB.write.data[5]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi_lo = asUInt(io.portB.write.data[6]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi_hi = asUInt(io.portB.write.data[7]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo = cat(mem_io_dib_lo_lo_hi, mem_io_dib_lo_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi = cat(mem_io_dib_lo_hi_hi, mem_io_dib_lo_hi_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo = cat(mem_io_dib_lo_hi, mem_io_dib_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo = cat(mem_io_dib_hi_lo_hi, mem_io_dib_hi_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi = cat(mem_io_dib_hi_hi_hi, mem_io_dib_hi_hi_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi = cat(mem_io_dib_hi_hi, mem_io_dib_hi_lo) @[DualPortMem.scala 178:51]
    node _mem_io_dib_T = cat(mem_io_dib_hi, mem_io_dib_lo) @[DualPortMem.scala 178:51]
    _mem_io_dib_WIRE <= _mem_io_dib_T @[DualPortMem.scala 178:51]
    mem.dib <= _mem_io_dib_WIRE @[DualPortMem.scala 178:20]
    
  module Queue_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][3] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      when wrap : @[Counter.scala 86:20]
        enq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      when wrap_1 : @[Counter.scala 86:20]
        deq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h03"), UInt<1>("h00")) @[Decoupled.scala 262:24]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 264:39]
    node _io_count_T_2 = add(UInt<2>("h03"), ptr_diff) @[Decoupled.scala 265:38]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 265:38]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 264:24]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 261:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 261:14]
    
  module Queue_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][3] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      when wrap : @[Counter.scala 86:20]
        enq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      when wrap_1 : @[Counter.scala 86:20]
        deq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h03"), UInt<1>("h00")) @[Decoupled.scala 262:24]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 264:39]
    node _io_count_T_2 = add(UInt<2>("h03"), ptr_diff) @[Decoupled.scala 265:38]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 265:38]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 264:24]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 261:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 261:14]
    
  module Queue_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module DualPortMem : 
    input clock : Clock
    input reset : Reset
    output io : {portA : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, inputStatus : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, portB : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, inputStatus : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst mem of InnerDualPortMem @[DualPortMem.scala 34:19]
    mem.clock <= clock
    mem.reset <= reset
    inst output of Queue_7 @[DualPortMem.scala 49:24]
    output.clock <= clock
    output.reset <= reset
    node outputReady = lt(output.io.count, UInt<2>("h02")) @[DualPortMem.scala 56:39]
    mem.io.portA.address <= io.portA.control.bits.address @[DualPortMem.scala 58:19]
    when io.portA.control.bits.write : @[DualPortMem.scala 60:30]
      io.portA.control.ready <= io.portA.input.valid @[DualPortMem.scala 61:21]
      node _mem_io_portA_write_enable_T = and(io.portA.control.valid, io.portA.input.valid) @[DualPortMem.scala 62:43]
      mem.io.portA.write.enable <= _mem_io_portA_write_enable_T @[DualPortMem.scala 62:26]
      mem.io.portA.read.enable <= UInt<1>("h00") @[DualPortMem.scala 63:25]
      skip @[DualPortMem.scala 60:30]
    else : @[DualPortMem.scala 64:17]
      io.portA.control.ready <= outputReady @[DualPortMem.scala 65:21]
      mem.io.portA.write.enable <= UInt<1>("h00") @[DualPortMem.scala 66:26]
      node _mem_io_portA_read_enable_T = and(io.portA.control.valid, outputReady) @[DualPortMem.scala 67:42]
      mem.io.portA.read.enable <= _mem_io_portA_read_enable_T @[DualPortMem.scala 67:25]
      skip @[DualPortMem.scala 64:17]
    output.io.enq.bits[0] <= mem.io.portA.read.data[0] @[DualPortMem.scala 70:24]
    output.io.enq.bits[1] <= mem.io.portA.read.data[1] @[DualPortMem.scala 70:24]
    output.io.enq.bits[2] <= mem.io.portA.read.data[2] @[DualPortMem.scala 70:24]
    output.io.enq.bits[3] <= mem.io.portA.read.data[3] @[DualPortMem.scala 70:24]
    output.io.enq.bits[4] <= mem.io.portA.read.data[4] @[DualPortMem.scala 70:24]
    output.io.enq.bits[5] <= mem.io.portA.read.data[5] @[DualPortMem.scala 70:24]
    output.io.enq.bits[6] <= mem.io.portA.read.data[6] @[DualPortMem.scala 70:24]
    output.io.enq.bits[7] <= mem.io.portA.read.data[7] @[DualPortMem.scala 70:24]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[1] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr : UInt<1>[1], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[0] <= mem.io.portA.read.enable @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[0] @[DualPortMem.scala 71:25]
    io.portA.output.bits[0] <= output.io.deq.bits[0] @[DualPortMem.scala 73:17]
    io.portA.output.bits[1] <= output.io.deq.bits[1] @[DualPortMem.scala 73:17]
    io.portA.output.bits[2] <= output.io.deq.bits[2] @[DualPortMem.scala 73:17]
    io.portA.output.bits[3] <= output.io.deq.bits[3] @[DualPortMem.scala 73:17]
    io.portA.output.bits[4] <= output.io.deq.bits[4] @[DualPortMem.scala 73:17]
    io.portA.output.bits[5] <= output.io.deq.bits[5] @[DualPortMem.scala 73:17]
    io.portA.output.bits[6] <= output.io.deq.bits[6] @[DualPortMem.scala 73:17]
    io.portA.output.bits[7] <= output.io.deq.bits[7] @[DualPortMem.scala 73:17]
    io.portA.output.valid <= output.io.deq.valid @[DualPortMem.scala 73:17]
    output.io.deq.ready <= io.portA.output.ready @[DualPortMem.scala 73:17]
    mem.io.portA.write.data[0] <= io.portA.input.bits[0] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[1] <= io.portA.input.bits[1] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[2] <= io.portA.input.bits[2] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[3] <= io.portA.input.bits[3] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[4] <= io.portA.input.bits[4] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[5] <= io.portA.input.bits[5] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[6] <= io.portA.input.bits[6] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[7] <= io.portA.input.bits[7] @[DualPortMem.scala 75:22]
    node _io_portA_input_ready_T = and(io.portA.control.valid, io.portA.control.bits.write) @[DualPortMem.scala 76:34]
    io.portA.input.ready <= _io_portA_input_ready_T @[DualPortMem.scala 76:17]
    io.portA.status.bits.size <= io.portA.control.bits.size @[DualPortMem.scala 90:22]
    io.portA.status.bits.address <= io.portA.control.bits.address @[DualPortMem.scala 90:22]
    io.portA.status.bits.write <= io.portA.control.bits.write @[DualPortMem.scala 90:22]
    node _io_portA_status_valid_T = and(io.portA.control.valid, io.portA.control.ready) @[DualPortMem.scala 91:40]
    io.portA.status.valid <= _io_portA_status_valid_T @[DualPortMem.scala 91:23]
    io.portA.inputStatus.bits[0] <= io.portA.input.bits[0] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[1] <= io.portA.input.bits[1] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[2] <= io.portA.input.bits[2] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[3] <= io.portA.input.bits[3] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[4] <= io.portA.input.bits[4] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[5] <= io.portA.input.bits[5] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[6] <= io.portA.input.bits[6] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[7] <= io.portA.input.bits[7] @[DualPortMem.scala 93:27]
    node _io_portA_inputStatus_valid_T = and(io.portA.input.valid, io.portA.input.ready) @[DualPortMem.scala 94:43]
    io.portA.inputStatus.valid <= _io_portA_inputStatus_valid_T @[DualPortMem.scala 94:28]
    inst wrote of Queue_8 @[Mem.scala 23:19]
    wrote.clock <= clock
    wrote.reset <= reset
    io.portA.wrote.bits <= wrote.io.deq.bits @[Mem.scala 24:7]
    io.portA.wrote.valid <= wrote.io.deq.valid @[Mem.scala 24:7]
    wrote.io.deq.ready <= io.portA.wrote.ready @[Mem.scala 24:7]
    wrote.io.enq.bits <= UInt<1>("h01") @[DualPortMem.scala 97:16]
    wrote.io.enq.valid <= mem.io.portA.write.enable @[DualPortMem.scala 98:17]
    inst output_1 of Queue_9 @[DualPortMem.scala 49:24]
    output_1.clock <= clock
    output_1.reset <= reset
    node outputReady_1 = lt(output_1.io.count, UInt<2>("h02")) @[DualPortMem.scala 56:39]
    mem.io.portB.address <= io.portB.control.bits.address @[DualPortMem.scala 58:19]
    when io.portB.control.bits.write : @[DualPortMem.scala 60:30]
      io.portB.control.ready <= io.portB.input.valid @[DualPortMem.scala 61:21]
      node _mem_io_portB_write_enable_T = and(io.portB.control.valid, io.portB.input.valid) @[DualPortMem.scala 62:43]
      mem.io.portB.write.enable <= _mem_io_portB_write_enable_T @[DualPortMem.scala 62:26]
      mem.io.portB.read.enable <= UInt<1>("h00") @[DualPortMem.scala 63:25]
      skip @[DualPortMem.scala 60:30]
    else : @[DualPortMem.scala 64:17]
      io.portB.control.ready <= outputReady_1 @[DualPortMem.scala 65:21]
      mem.io.portB.write.enable <= UInt<1>("h00") @[DualPortMem.scala 66:26]
      node _mem_io_portB_read_enable_T = and(io.portB.control.valid, outputReady_1) @[DualPortMem.scala 67:42]
      mem.io.portB.read.enable <= _mem_io_portB_read_enable_T @[DualPortMem.scala 67:25]
      skip @[DualPortMem.scala 64:17]
    output_1.io.enq.bits[0] <= mem.io.portB.read.data[0] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[1] <= mem.io.portB.read.data[1] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[2] <= mem.io.portB.read.data[2] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[3] <= mem.io.portB.read.data[3] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[4] <= mem.io.portB.read.data[4] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[5] <= mem.io.portB.read.data[5] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[6] <= mem.io.portB.read.data[6] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[7] <= mem.io.portB.read.data[7] @[DualPortMem.scala 70:24]
    wire _output_io_enq_valid_sr_WIRE_1 : UInt<1>[1] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE_1[0] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr_1 : UInt<1>[1], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE_1)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr_1[0] <= mem.io.portB.read.enable @[ShiftRegister.scala 25:12]
    output_1.io.enq.valid <= output_io_enq_valid_sr_1[0] @[DualPortMem.scala 71:25]
    io.portB.output.bits[0] <= output_1.io.deq.bits[0] @[DualPortMem.scala 73:17]
    io.portB.output.bits[1] <= output_1.io.deq.bits[1] @[DualPortMem.scala 73:17]
    io.portB.output.bits[2] <= output_1.io.deq.bits[2] @[DualPortMem.scala 73:17]
    io.portB.output.bits[3] <= output_1.io.deq.bits[3] @[DualPortMem.scala 73:17]
    io.portB.output.bits[4] <= output_1.io.deq.bits[4] @[DualPortMem.scala 73:17]
    io.portB.output.bits[5] <= output_1.io.deq.bits[5] @[DualPortMem.scala 73:17]
    io.portB.output.bits[6] <= output_1.io.deq.bits[6] @[DualPortMem.scala 73:17]
    io.portB.output.bits[7] <= output_1.io.deq.bits[7] @[DualPortMem.scala 73:17]
    io.portB.output.valid <= output_1.io.deq.valid @[DualPortMem.scala 73:17]
    output_1.io.deq.ready <= io.portB.output.ready @[DualPortMem.scala 73:17]
    mem.io.portB.write.data[0] <= io.portB.input.bits[0] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[1] <= io.portB.input.bits[1] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[2] <= io.portB.input.bits[2] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[3] <= io.portB.input.bits[3] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[4] <= io.portB.input.bits[4] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[5] <= io.portB.input.bits[5] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[6] <= io.portB.input.bits[6] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[7] <= io.portB.input.bits[7] @[DualPortMem.scala 75:22]
    node _io_portB_input_ready_T = and(io.portB.control.valid, io.portB.control.bits.write) @[DualPortMem.scala 76:34]
    io.portB.input.ready <= _io_portB_input_ready_T @[DualPortMem.scala 76:17]
    io.portB.status.bits.size <= io.portB.control.bits.size @[DualPortMem.scala 90:22]
    io.portB.status.bits.address <= io.portB.control.bits.address @[DualPortMem.scala 90:22]
    io.portB.status.bits.write <= io.portB.control.bits.write @[DualPortMem.scala 90:22]
    node _io_portB_status_valid_T = and(io.portB.control.valid, io.portB.control.ready) @[DualPortMem.scala 91:40]
    io.portB.status.valid <= _io_portB_status_valid_T @[DualPortMem.scala 91:23]
    io.portB.inputStatus.bits[0] <= io.portB.input.bits[0] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[1] <= io.portB.input.bits[1] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[2] <= io.portB.input.bits[2] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[3] <= io.portB.input.bits[3] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[4] <= io.portB.input.bits[4] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[5] <= io.portB.input.bits[5] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[6] <= io.portB.input.bits[6] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[7] <= io.portB.input.bits[7] @[DualPortMem.scala 93:27]
    node _io_portB_inputStatus_valid_T = and(io.portB.input.valid, io.portB.input.ready) @[DualPortMem.scala 94:43]
    io.portB.inputStatus.valid <= _io_portB_inputStatus_valid_T @[DualPortMem.scala 94:28]
    inst wrote_1 of Queue_10 @[Mem.scala 23:19]
    wrote_1.clock <= clock
    wrote_1.reset <= reset
    io.portB.wrote.bits <= wrote_1.io.deq.bits @[Mem.scala 24:7]
    io.portB.wrote.valid <= wrote_1.io.deq.valid @[Mem.scala 24:7]
    wrote_1.io.deq.ready <= io.portB.wrote.ready @[Mem.scala 24:7]
    wrote_1.io.enq.bits <= UInt<1>("h01") @[DualPortMem.scala 97:16]
    wrote_1.io.enq.valid <= mem.io.portB.write.enable @[DualPortMem.scala 98:17]
    
  module Queue_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<1>}
    
    cmem ram : Fixed<16><<8>>[8][1] @[Decoupled.scala 218:16]
    wire value : UInt
    value <= UInt<1>("h00")
    wire value_1 : UInt
    value_1 <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<1>}
    
    cmem ram : Fixed<16><<8>>[8][1] @[Decoupled.scala 218:16]
    wire value : UInt
    value <= UInt<1>("h00")
    wire value_1 : UInt
    value_1 <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module VecAdder : 
    input clock : Clock
    input reset : Reset
    output io : {flip left : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip right : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    inst left of Queue_11 @[Decoupled.scala 296:21]
    left.clock <= clock
    left.reset <= reset
    left.io.enq.valid <= io.left.valid @[Decoupled.scala 297:22]
    left.io.enq.bits[0] <= io.left.bits[0] @[Decoupled.scala 298:21]
    left.io.enq.bits[1] <= io.left.bits[1] @[Decoupled.scala 298:21]
    left.io.enq.bits[2] <= io.left.bits[2] @[Decoupled.scala 298:21]
    left.io.enq.bits[3] <= io.left.bits[3] @[Decoupled.scala 298:21]
    left.io.enq.bits[4] <= io.left.bits[4] @[Decoupled.scala 298:21]
    left.io.enq.bits[5] <= io.left.bits[5] @[Decoupled.scala 298:21]
    left.io.enq.bits[6] <= io.left.bits[6] @[Decoupled.scala 298:21]
    left.io.enq.bits[7] <= io.left.bits[7] @[Decoupled.scala 298:21]
    io.left.ready <= left.io.enq.ready @[Decoupled.scala 299:17]
    inst right of Queue_12 @[Decoupled.scala 296:21]
    right.clock <= clock
    right.reset <= reset
    right.io.enq.valid <= io.right.valid @[Decoupled.scala 297:22]
    right.io.enq.bits[0] <= io.right.bits[0] @[Decoupled.scala 298:21]
    right.io.enq.bits[1] <= io.right.bits[1] @[Decoupled.scala 298:21]
    right.io.enq.bits[2] <= io.right.bits[2] @[Decoupled.scala 298:21]
    right.io.enq.bits[3] <= io.right.bits[3] @[Decoupled.scala 298:21]
    right.io.enq.bits[4] <= io.right.bits[4] @[Decoupled.scala 298:21]
    right.io.enq.bits[5] <= io.right.bits[5] @[Decoupled.scala 298:21]
    right.io.enq.bits[6] <= io.right.bits[6] @[Decoupled.scala 298:21]
    right.io.enq.bits[7] <= io.right.bits[7] @[Decoupled.scala 298:21]
    io.right.ready <= right.io.enq.ready @[Decoupled.scala 299:17]
    node _io_output_bits_0_T = add(left.io.deq.bits[0], right.io.deq.bits[0]) @[VecAdder.scala 21:39]
    node _io_output_bits_0_T_1 = tail(_io_output_bits_0_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_0_T_2 = asFixedPoint(_io_output_bits_0_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[0] <= _io_output_bits_0_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_1_T = add(left.io.deq.bits[1], right.io.deq.bits[1]) @[VecAdder.scala 21:39]
    node _io_output_bits_1_T_1 = tail(_io_output_bits_1_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_1_T_2 = asFixedPoint(_io_output_bits_1_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[1] <= _io_output_bits_1_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_2_T = add(left.io.deq.bits[2], right.io.deq.bits[2]) @[VecAdder.scala 21:39]
    node _io_output_bits_2_T_1 = tail(_io_output_bits_2_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_2_T_2 = asFixedPoint(_io_output_bits_2_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[2] <= _io_output_bits_2_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_3_T = add(left.io.deq.bits[3], right.io.deq.bits[3]) @[VecAdder.scala 21:39]
    node _io_output_bits_3_T_1 = tail(_io_output_bits_3_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_3_T_2 = asFixedPoint(_io_output_bits_3_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[3] <= _io_output_bits_3_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_4_T = add(left.io.deq.bits[4], right.io.deq.bits[4]) @[VecAdder.scala 21:39]
    node _io_output_bits_4_T_1 = tail(_io_output_bits_4_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_4_T_2 = asFixedPoint(_io_output_bits_4_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[4] <= _io_output_bits_4_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_5_T = add(left.io.deq.bits[5], right.io.deq.bits[5]) @[VecAdder.scala 21:39]
    node _io_output_bits_5_T_1 = tail(_io_output_bits_5_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_5_T_2 = asFixedPoint(_io_output_bits_5_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[5] <= _io_output_bits_5_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_6_T = add(left.io.deq.bits[6], right.io.deq.bits[6]) @[VecAdder.scala 21:39]
    node _io_output_bits_6_T_1 = tail(_io_output_bits_6_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_6_T_2 = asFixedPoint(_io_output_bits_6_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[6] <= _io_output_bits_6_T_2 @[VecAdder.scala 21:23]
    node _io_output_bits_7_T = add(left.io.deq.bits[7], right.io.deq.bits[7]) @[VecAdder.scala 21:39]
    node _io_output_bits_7_T_1 = tail(_io_output_bits_7_T, 1) @[VecAdder.scala 21:39]
    node _io_output_bits_7_T_2 = asFixedPoint(_io_output_bits_7_T_1, 8) @[VecAdder.scala 21:39]
    io.output.bits[7] <= _io_output_bits_7_T_2 @[VecAdder.scala 21:23]
    node _io_output_valid_T = and(left.io.deq.valid, right.io.deq.valid) @[VecAdder.scala 23:33]
    io.output.valid <= _io_output_valid_T @[VecAdder.scala 23:19]
    node _left_io_deq_ready_T = and(io.output.ready, right.io.deq.valid) @[VecAdder.scala 24:33]
    left.io.deq.ready <= _left_io_deq_ready_T @[VecAdder.scala 24:14]
    node _right_io_deq_ready_T = and(io.output.ready, left.io.deq.valid) @[VecAdder.scala 25:34]
    right.io.deq.ready <= _right_io_deq_ready_T @[VecAdder.scala 25:15]
    
  module Queue_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}}, count : UInt<1>}
    
    cmem ram : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}[1] @[Decoupled.scala 218:16]
    wire value : UInt
    value <= UInt<1>("h00")
    wire value_1 : UInt
    value_1 <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      MPORT.accumulate <= io.enq.bits.accumulate @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    io.deq.bits.accumulate <= io_deq_bits_MPORT.accumulate @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits.write <= io.enq.bits.write @[Decoupled.scala 247:19]
      io.deq.bits.accumulate <= io.enq.bits.accumulate @[Decoupled.scala 247:19]
      io.deq.bits.address <= io.enq.bits.address @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, count : UInt<1>}
    
    cmem ram : {write : UInt<1>, address : UInt<6>, size : UInt<6>}[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits.size <= io.enq.bits.size @[Decoupled.scala 247:19]
      io.deq.bits.address <= io.enq.bits.address @[Decoupled.scala 247:19]
      io.deq.bits.write <= io.enq.bits.write @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Demux : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module Queue_16 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}
    
    cmem ram : UInt<1>[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Demux_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module Queue_17 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}
    
    cmem ram : UInt<1>[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module MultiEnqueue_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[4]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_3 = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module Accumulator : 
    input clock : Clock
    input reset : Reset
    output io : {flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst mem of DualPortMem @[Accumulator.scala 38:19]
    mem.clock <= clock
    mem.reset <= reset
    inst adder of VecAdder @[Accumulator.scala 46:23]
    adder.clock <= clock
    adder.reset <= reset
    inst control of Queue_13 @[Decoupled.scala 296:21]
    control.clock <= clock
    control.reset <= reset
    control.io.enq.valid <= io.control.valid @[Decoupled.scala 297:22]
    control.io.enq.bits.write <= io.control.bits.write @[Decoupled.scala 298:21]
    control.io.enq.bits.accumulate <= io.control.bits.accumulate @[Decoupled.scala 298:21]
    control.io.enq.bits.address <= io.control.bits.address @[Decoupled.scala 298:21]
    io.control.ready <= control.io.enq.ready @[Decoupled.scala 299:17]
    inst input of Queue_14 @[Decoupled.scala 296:21]
    input.clock <= clock
    input.reset <= reset
    input.io.enq.valid <= io.input.valid @[Decoupled.scala 297:22]
    input.io.enq.bits[0] <= io.input.bits[0] @[Decoupled.scala 298:21]
    input.io.enq.bits[1] <= io.input.bits[1] @[Decoupled.scala 298:21]
    input.io.enq.bits[2] <= io.input.bits[2] @[Decoupled.scala 298:21]
    input.io.enq.bits[3] <= io.input.bits[3] @[Decoupled.scala 298:21]
    input.io.enq.bits[4] <= io.input.bits[4] @[Decoupled.scala 298:21]
    input.io.enq.bits[5] <= io.input.bits[5] @[Decoupled.scala 298:21]
    input.io.enq.bits[6] <= io.input.bits[6] @[Decoupled.scala 298:21]
    input.io.enq.bits[7] <= io.input.bits[7] @[Decoupled.scala 298:21]
    io.input.ready <= input.io.enq.ready @[Decoupled.scala 299:17]
    inst portBControl of Queue_15 @[Mem.scala 23:19]
    portBControl.clock <= clock
    portBControl.reset <= reset
    mem.io.portB.control.bits.size <= portBControl.io.deq.bits.size @[Mem.scala 24:7]
    mem.io.portB.control.bits.address <= portBControl.io.deq.bits.address @[Mem.scala 24:7]
    mem.io.portB.control.bits.write <= portBControl.io.deq.bits.write @[Mem.scala 24:7]
    mem.io.portB.control.valid <= portBControl.io.deq.valid @[Mem.scala 24:7]
    portBControl.io.deq.ready <= mem.io.portB.control.ready @[Mem.scala 24:7]
    mem.io.programCounter <= io.programCounter @[Accumulator.scala 55:25]
    mem.io.tracepoint <= io.tracepoint @[Accumulator.scala 56:21]
    wire _mem_io_portA_control_bits_WIRE : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[package.scala 80:57]
    _mem_io_portA_control_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _mem_io_portA_control_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    _mem_io_portA_control_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    mem.io.portA.control.bits.size <= _mem_io_portA_control_bits_WIRE.size @[package.scala 409:14]
    mem.io.portA.control.bits.address <= _mem_io_portA_control_bits_WIRE.address @[package.scala 409:14]
    mem.io.portA.control.bits.write <= _mem_io_portA_control_bits_WIRE.write @[package.scala 409:14]
    mem.io.portA.control.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _portBControl_io_enq_bits_WIRE : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[package.scala 80:57]
    _portBControl_io_enq_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _portBControl_io_enq_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    _portBControl_io_enq_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    portBControl.io.enq.bits.size <= _portBControl_io_enq_bits_WIRE.size @[package.scala 409:14]
    portBControl.io.enq.bits.address <= _portBControl_io_enq_bits_WIRE.address @[package.scala 409:14]
    portBControl.io.enq.bits.write <= _portBControl_io_enq_bits_WIRE.write @[package.scala 409:14]
    portBControl.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    mem.io.portA.status.ready <= UInt<1>("h01") @[Accumulator.scala 59:22]
    mem.io.portA.inputStatus.ready <= UInt<1>("h01") @[Accumulator.scala 60:27]
    mem.io.portB.status.ready <= UInt<1>("h01") @[Accumulator.scala 61:22]
    mem.io.portB.inputStatus.ready <= UInt<1>("h01") @[Accumulator.scala 62:27]
    io.wrote.bits <= mem.io.portA.wrote.bits @[Accumulator.scala 63:12]
    io.wrote.valid <= mem.io.portA.wrote.valid @[Accumulator.scala 63:12]
    mem.io.portA.wrote.ready <= io.wrote.ready @[Accumulator.scala 63:12]
    mem.io.portB.wrote.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
    mem.io.portB.input.bits[0] <= adder.io.output.bits[0] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[1] <= adder.io.output.bits[1] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[2] <= adder.io.output.bits[2] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[3] <= adder.io.output.bits[3] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[4] <= adder.io.output.bits[4] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[5] <= adder.io.output.bits[5] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[6] <= adder.io.output.bits[6] @[Accumulator.scala 66:15]
    mem.io.portB.input.bits[7] <= adder.io.output.bits[7] @[Accumulator.scala 66:15]
    mem.io.portB.input.valid <= adder.io.output.valid @[Accumulator.scala 66:15]
    adder.io.output.ready <= mem.io.portB.input.ready @[Accumulator.scala 66:15]
    mem.io.portB.output.ready <= UInt<1>("h00") @[Accumulator.scala 67:22]
    inst inputDemux_x14_demux of Demux @[Demux.scala 46:23]
    inputDemux_x14_demux.clock <= clock
    inputDemux_x14_demux.reset <= reset
    inputDemux_x14_demux.io.in.bits[0] <= input.io.deq.bits[0] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[1] <= input.io.deq.bits[1] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[2] <= input.io.deq.bits[2] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[3] <= input.io.deq.bits[3] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[4] <= input.io.deq.bits[4] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[5] <= input.io.deq.bits[5] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[6] <= input.io.deq.bits[6] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.bits[7] <= input.io.deq.bits[7] @[Demux.scala 54:17]
    inputDemux_x14_demux.io.in.valid <= input.io.deq.valid @[Demux.scala 54:17]
    input.io.deq.ready <= inputDemux_x14_demux.io.in.ready @[Demux.scala 54:17]
    mem.io.portA.input.bits[0] <= inputDemux_x14_demux.io.out[0].bits[0] @[Demux.scala 55:10]
    mem.io.portA.input.bits[1] <= inputDemux_x14_demux.io.out[0].bits[1] @[Demux.scala 55:10]
    mem.io.portA.input.bits[2] <= inputDemux_x14_demux.io.out[0].bits[2] @[Demux.scala 55:10]
    mem.io.portA.input.bits[3] <= inputDemux_x14_demux.io.out[0].bits[3] @[Demux.scala 55:10]
    mem.io.portA.input.bits[4] <= inputDemux_x14_demux.io.out[0].bits[4] @[Demux.scala 55:10]
    mem.io.portA.input.bits[5] <= inputDemux_x14_demux.io.out[0].bits[5] @[Demux.scala 55:10]
    mem.io.portA.input.bits[6] <= inputDemux_x14_demux.io.out[0].bits[6] @[Demux.scala 55:10]
    mem.io.portA.input.bits[7] <= inputDemux_x14_demux.io.out[0].bits[7] @[Demux.scala 55:10]
    mem.io.portA.input.valid <= inputDemux_x14_demux.io.out[0].valid @[Demux.scala 55:10]
    inputDemux_x14_demux.io.out[0].ready <= mem.io.portA.input.ready @[Demux.scala 55:10]
    adder.io.left.bits[0] <= inputDemux_x14_demux.io.out[1].bits[0] @[Demux.scala 56:10]
    adder.io.left.bits[1] <= inputDemux_x14_demux.io.out[1].bits[1] @[Demux.scala 56:10]
    adder.io.left.bits[2] <= inputDemux_x14_demux.io.out[1].bits[2] @[Demux.scala 56:10]
    adder.io.left.bits[3] <= inputDemux_x14_demux.io.out[1].bits[3] @[Demux.scala 56:10]
    adder.io.left.bits[4] <= inputDemux_x14_demux.io.out[1].bits[4] @[Demux.scala 56:10]
    adder.io.left.bits[5] <= inputDemux_x14_demux.io.out[1].bits[5] @[Demux.scala 56:10]
    adder.io.left.bits[6] <= inputDemux_x14_demux.io.out[1].bits[6] @[Demux.scala 56:10]
    adder.io.left.bits[7] <= inputDemux_x14_demux.io.out[1].bits[7] @[Demux.scala 56:10]
    adder.io.left.valid <= inputDemux_x14_demux.io.out[1].valid @[Demux.scala 56:10]
    inputDemux_x14_demux.io.out[1].ready <= adder.io.left.ready @[Demux.scala 56:10]
    inst inputDemux of Queue_16 @[Mem.scala 23:19]
    inputDemux.clock <= clock
    inputDemux.reset <= reset
    inputDemux_x14_demux.io.sel.bits <= inputDemux.io.deq.bits @[Mem.scala 24:7]
    inputDemux_x14_demux.io.sel.valid <= inputDemux.io.deq.valid @[Mem.scala 24:7]
    inputDemux.io.deq.ready <= inputDemux_x14_demux.io.sel.ready @[Mem.scala 24:7]
    inst memOutputDemux_x23_demux of Demux_1 @[Demux.scala 46:23]
    memOutputDemux_x23_demux.clock <= clock
    memOutputDemux_x23_demux.reset <= reset
    memOutputDemux_x23_demux.io.in.bits[0] <= mem.io.portA.output.bits[0] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[1] <= mem.io.portA.output.bits[1] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[2] <= mem.io.portA.output.bits[2] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[3] <= mem.io.portA.output.bits[3] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[4] <= mem.io.portA.output.bits[4] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[5] <= mem.io.portA.output.bits[5] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[6] <= mem.io.portA.output.bits[6] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.bits[7] <= mem.io.portA.output.bits[7] @[Demux.scala 54:17]
    memOutputDemux_x23_demux.io.in.valid <= mem.io.portA.output.valid @[Demux.scala 54:17]
    mem.io.portA.output.ready <= memOutputDemux_x23_demux.io.in.ready @[Demux.scala 54:17]
    io.output.bits[0] <= memOutputDemux_x23_demux.io.out[0].bits[0] @[Demux.scala 55:10]
    io.output.bits[1] <= memOutputDemux_x23_demux.io.out[0].bits[1] @[Demux.scala 55:10]
    io.output.bits[2] <= memOutputDemux_x23_demux.io.out[0].bits[2] @[Demux.scala 55:10]
    io.output.bits[3] <= memOutputDemux_x23_demux.io.out[0].bits[3] @[Demux.scala 55:10]
    io.output.bits[4] <= memOutputDemux_x23_demux.io.out[0].bits[4] @[Demux.scala 55:10]
    io.output.bits[5] <= memOutputDemux_x23_demux.io.out[0].bits[5] @[Demux.scala 55:10]
    io.output.bits[6] <= memOutputDemux_x23_demux.io.out[0].bits[6] @[Demux.scala 55:10]
    io.output.bits[7] <= memOutputDemux_x23_demux.io.out[0].bits[7] @[Demux.scala 55:10]
    io.output.valid <= memOutputDemux_x23_demux.io.out[0].valid @[Demux.scala 55:10]
    memOutputDemux_x23_demux.io.out[0].ready <= io.output.ready @[Demux.scala 55:10]
    adder.io.right.bits[0] <= memOutputDemux_x23_demux.io.out[1].bits[0] @[Demux.scala 56:10]
    adder.io.right.bits[1] <= memOutputDemux_x23_demux.io.out[1].bits[1] @[Demux.scala 56:10]
    adder.io.right.bits[2] <= memOutputDemux_x23_demux.io.out[1].bits[2] @[Demux.scala 56:10]
    adder.io.right.bits[3] <= memOutputDemux_x23_demux.io.out[1].bits[3] @[Demux.scala 56:10]
    adder.io.right.bits[4] <= memOutputDemux_x23_demux.io.out[1].bits[4] @[Demux.scala 56:10]
    adder.io.right.bits[5] <= memOutputDemux_x23_demux.io.out[1].bits[5] @[Demux.scala 56:10]
    adder.io.right.bits[6] <= memOutputDemux_x23_demux.io.out[1].bits[6] @[Demux.scala 56:10]
    adder.io.right.bits[7] <= memOutputDemux_x23_demux.io.out[1].bits[7] @[Demux.scala 56:10]
    adder.io.right.valid <= memOutputDemux_x23_demux.io.out[1].valid @[Demux.scala 56:10]
    memOutputDemux_x23_demux.io.out[1].ready <= adder.io.right.ready @[Demux.scala 56:10]
    inst memOutputDemux of Queue_17 @[Mem.scala 23:19]
    memOutputDemux.clock <= clock
    memOutputDemux.reset <= reset
    memOutputDemux_x23_demux.io.sel.bits <= memOutputDemux.io.deq.bits @[Mem.scala 24:7]
    memOutputDemux_x23_demux.io.sel.valid <= memOutputDemux.io.deq.valid @[Mem.scala 24:7]
    memOutputDemux.io.deq.ready <= memOutputDemux_x23_demux.io.sel.ready @[Mem.scala 24:7]
    wire _inputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 77:41]
    _inputDemux_io_enq_bits_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    inputDemux.io.enq.bits <= _inputDemux_io_enq_bits_WIRE @[package.scala 409:14]
    inputDemux.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _memOutputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 77:41]
    _memOutputDemux_io_enq_bits_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    memOutputDemux.io.enq.bits <= _memOutputDemux_io_enq_bits_WIRE @[package.scala 409:14]
    memOutputDemux.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    reg readEnqueued : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Accumulator.scala 94:29]
    readEnqueued <= UInt<1>("h00") @[Accumulator.scala 95:16]
    inst writeEnqueuer of MultiEnqueue_4 @[MultiEnqueue.scala 160:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    inst readEnqueuer of MultiEnqueue_5 @[MultiEnqueue.scala 160:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst accEnqueuer of MultiEnqueue_6 @[MultiEnqueue.scala 160:43]
    accEnqueuer.clock <= clock
    accEnqueuer.reset <= reset
    writeEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    writeEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    writeEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    readEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    readEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    readEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    accEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accEnqueuer.io.out[3].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    reg writeAccumulating : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Accumulator.scala 105:34]
    writeAccumulating <= UInt<1>("h00") @[Accumulator.scala 106:21]
    when control.io.deq.bits.write : @[Accumulator.scala 108:28]
      when control.io.deq.bits.accumulate : @[Accumulator.scala 109:35]
        writeAccumulating <= UInt<1>("h01") @[Accumulator.scala 110:25]
        wire control_io_deq_ready_w : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[MemControl.scala 76:19]
        control_io_deq_ready_w.address <= control.io.deq.bits.address @[MemControl.scala 77:17]
        control_io_deq_ready_w.write <= UInt<1>("h00") @[MemControl.scala 78:15]
        control_io_deq_ready_w.size <= UInt<1>("h00") @[MemControl.scala 79:14]
        wire control_io_deq_ready_w_1 : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[MemControl.scala 76:19]
        control_io_deq_ready_w_1.address <= control.io.deq.bits.address @[MemControl.scala 77:17]
        control_io_deq_ready_w_1.write <= UInt<1>("h01") @[MemControl.scala 78:15]
        control_io_deq_ready_w_1.size <= UInt<1>("h00") @[MemControl.scala 79:14]
        accEnqueuer.io.in.valid <= control.io.deq.valid @[MultiEnqueue.scala 150:17]
        wire control_io_deq_ready_mem_io_portA_control_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        control_io_deq_ready_mem_io_portA_control_w.bits.size <= control_io_deq_ready_w.size @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w.bits.address <= control_io_deq_ready_w.address @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w.bits.write <= control_io_deq_ready_w.write @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w.valid <= accEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[0].ready <= control_io_deq_ready_mem_io_portA_control_w.ready @[ReadyValid.scala 19:11]
        mem.io.portA.control.bits.size <= control_io_deq_ready_mem_io_portA_control_w.bits.size @[MultiEnqueue.scala 151:10]
        mem.io.portA.control.bits.address <= control_io_deq_ready_mem_io_portA_control_w.bits.address @[MultiEnqueue.scala 151:10]
        mem.io.portA.control.bits.write <= control_io_deq_ready_mem_io_portA_control_w.bits.write @[MultiEnqueue.scala 151:10]
        mem.io.portA.control.valid <= control_io_deq_ready_mem_io_portA_control_w.valid @[MultiEnqueue.scala 151:10]
        control_io_deq_ready_mem_io_portA_control_w.ready <= mem.io.portA.control.ready @[MultiEnqueue.scala 151:10]
        wire control_io_deq_ready_memOutputDemux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        control_io_deq_ready_memOutputDemux_io_enq_w.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
        control_io_deq_ready_memOutputDemux_io_enq_w.valid <= accEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[1].ready <= control_io_deq_ready_memOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
        memOutputDemux.io.enq.bits <= control_io_deq_ready_memOutputDemux_io_enq_w.bits @[MultiEnqueue.scala 152:10]
        memOutputDemux.io.enq.valid <= control_io_deq_ready_memOutputDemux_io_enq_w.valid @[MultiEnqueue.scala 152:10]
        control_io_deq_ready_memOutputDemux_io_enq_w.ready <= memOutputDemux.io.enq.ready @[MultiEnqueue.scala 152:10]
        wire control_io_deq_ready_portBControl_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        control_io_deq_ready_portBControl_io_enq_w.bits.size <= control_io_deq_ready_w_1.size @[ReadyValid.scala 17:12]
        control_io_deq_ready_portBControl_io_enq_w.bits.address <= control_io_deq_ready_w_1.address @[ReadyValid.scala 17:12]
        control_io_deq_ready_portBControl_io_enq_w.bits.write <= control_io_deq_ready_w_1.write @[ReadyValid.scala 17:12]
        control_io_deq_ready_portBControl_io_enq_w.valid <= accEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[2].ready <= control_io_deq_ready_portBControl_io_enq_w.ready @[ReadyValid.scala 19:11]
        portBControl.io.enq.bits.size <= control_io_deq_ready_portBControl_io_enq_w.bits.size @[MultiEnqueue.scala 153:10]
        portBControl.io.enq.bits.address <= control_io_deq_ready_portBControl_io_enq_w.bits.address @[MultiEnqueue.scala 153:10]
        portBControl.io.enq.bits.write <= control_io_deq_ready_portBControl_io_enq_w.bits.write @[MultiEnqueue.scala 153:10]
        portBControl.io.enq.valid <= control_io_deq_ready_portBControl_io_enq_w.valid @[MultiEnqueue.scala 153:10]
        control_io_deq_ready_portBControl_io_enq_w.ready <= portBControl.io.enq.ready @[MultiEnqueue.scala 153:10]
        wire control_io_deq_ready_inputDemux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        control_io_deq_ready_inputDemux_io_enq_w.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
        control_io_deq_ready_inputDemux_io_enq_w.valid <= accEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
        accEnqueuer.io.out[3].ready <= control_io_deq_ready_inputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
        inputDemux.io.enq.bits <= control_io_deq_ready_inputDemux_io_enq_w.bits @[MultiEnqueue.scala 154:10]
        inputDemux.io.enq.valid <= control_io_deq_ready_inputDemux_io_enq_w.valid @[MultiEnqueue.scala 154:10]
        control_io_deq_ready_inputDemux_io_enq_w.ready <= inputDemux.io.enq.ready @[MultiEnqueue.scala 154:10]
        control.io.deq.ready <= accEnqueuer.io.in.ready @[Accumulator.scala 111:21]
        skip @[Accumulator.scala 109:35]
      else : @[Accumulator.scala 124:17]
        wire control_io_deq_ready_w_2 : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[MemControl.scala 76:19]
        control_io_deq_ready_w_2.address <= control.io.deq.bits.address @[MemControl.scala 77:17]
        control_io_deq_ready_w_2.write <= UInt<1>("h01") @[MemControl.scala 78:15]
        control_io_deq_ready_w_2.size <= UInt<1>("h00") @[MemControl.scala 79:14]
        writeEnqueuer.io.in.valid <= control.io.deq.valid @[MultiEnqueue.scala 84:17]
        wire control_io_deq_ready_mem_io_portA_control_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        control_io_deq_ready_mem_io_portA_control_w_1.bits.size <= control_io_deq_ready_w_2.size @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_1.bits.address <= control_io_deq_ready_w_2.address @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_1.bits.write <= control_io_deq_ready_w_2.write @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= control_io_deq_ready_mem_io_portA_control_w_1.ready @[ReadyValid.scala 19:11]
        mem.io.portA.control.bits.size <= control_io_deq_ready_mem_io_portA_control_w_1.bits.size @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.bits.address <= control_io_deq_ready_mem_io_portA_control_w_1.bits.address @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.bits.write <= control_io_deq_ready_mem_io_portA_control_w_1.bits.write @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.valid <= control_io_deq_ready_mem_io_portA_control_w_1.valid @[MultiEnqueue.scala 85:10]
        control_io_deq_ready_mem_io_portA_control_w_1.ready <= mem.io.portA.control.ready @[MultiEnqueue.scala 85:10]
        wire control_io_deq_ready_inputDemux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        control_io_deq_ready_inputDemux_io_enq_w_1.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
        control_io_deq_ready_inputDemux_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= control_io_deq_ready_inputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        inputDemux.io.enq.bits <= control_io_deq_ready_inputDemux_io_enq_w_1.bits @[MultiEnqueue.scala 86:10]
        inputDemux.io.enq.valid <= control_io_deq_ready_inputDemux_io_enq_w_1.valid @[MultiEnqueue.scala 86:10]
        control_io_deq_ready_inputDemux_io_enq_w_1.ready <= inputDemux.io.enq.ready @[MultiEnqueue.scala 86:10]
        control.io.deq.ready <= writeEnqueuer.io.in.ready @[Accumulator.scala 126:21]
        skip @[Accumulator.scala 124:17]
      skip @[Accumulator.scala 108:28]
    else : @[Accumulator.scala 134:15]
      node _T = eq(writeAccumulating, UInt<1>("h00")) @[Accumulator.scala 136:10]
      when _T : @[Accumulator.scala 136:30]
        wire control_io_deq_ready_w_3 : {write : UInt<1>, address : UInt<6>, size : UInt<6>} @[MemControl.scala 76:19]
        control_io_deq_ready_w_3.address <= control.io.deq.bits.address @[MemControl.scala 77:17]
        control_io_deq_ready_w_3.write <= UInt<1>("h00") @[MemControl.scala 78:15]
        control_io_deq_ready_w_3.size <= UInt<1>("h00") @[MemControl.scala 79:14]
        readEnqueuer.io.in.valid <= control.io.deq.valid @[MultiEnqueue.scala 84:17]
        wire control_io_deq_ready_mem_io_portA_control_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        control_io_deq_ready_mem_io_portA_control_w_2.bits.size <= control_io_deq_ready_w_3.size @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_2.bits.address <= control_io_deq_ready_w_3.address @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_2.bits.write <= control_io_deq_ready_w_3.write @[ReadyValid.scala 17:12]
        control_io_deq_ready_mem_io_portA_control_w_2.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[0].ready <= control_io_deq_ready_mem_io_portA_control_w_2.ready @[ReadyValid.scala 19:11]
        mem.io.portA.control.bits.size <= control_io_deq_ready_mem_io_portA_control_w_2.bits.size @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.bits.address <= control_io_deq_ready_mem_io_portA_control_w_2.bits.address @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.bits.write <= control_io_deq_ready_mem_io_portA_control_w_2.bits.write @[MultiEnqueue.scala 85:10]
        mem.io.portA.control.valid <= control_io_deq_ready_mem_io_portA_control_w_2.valid @[MultiEnqueue.scala 85:10]
        control_io_deq_ready_mem_io_portA_control_w_2.ready <= mem.io.portA.control.ready @[MultiEnqueue.scala 85:10]
        wire control_io_deq_ready_memOutputDemux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        control_io_deq_ready_memOutputDemux_io_enq_w_1.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
        control_io_deq_ready_memOutputDemux_io_enq_w_1.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[1].ready <= control_io_deq_ready_memOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
        memOutputDemux.io.enq.bits <= control_io_deq_ready_memOutputDemux_io_enq_w_1.bits @[MultiEnqueue.scala 86:10]
        memOutputDemux.io.enq.valid <= control_io_deq_ready_memOutputDemux_io_enq_w_1.valid @[MultiEnqueue.scala 86:10]
        control_io_deq_ready_memOutputDemux_io_enq_w_1.ready <= memOutputDemux.io.enq.ready @[MultiEnqueue.scala 86:10]
        control.io.deq.ready <= readEnqueuer.io.in.ready @[Accumulator.scala 137:21]
        skip @[Accumulator.scala 136:30]
      else : @[Accumulator.scala 144:17]
        control.io.deq.ready <= UInt<1>("h00") @[Accumulator.scala 146:21]
        skip @[Accumulator.scala 144:17]
      skip @[Accumulator.scala 134:15]
    
  module Queue_18 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module ALU : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALU_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip op : UInt<4>, flip input : Fixed<16><<8>>, flip sourceLeft : UInt<1>, flip sourceRight : UInt<1>, flip dest : UInt<1>, output : Fixed<16><<8>>}
    
    reg op : UInt, clock @[ALU.scala 35:42]
    op <= io.op @[ALU.scala 35:42]
    reg input : Fixed<<8>>, clock @[ALU.scala 36:42]
    input <= io.input @[ALU.scala 36:42]
    reg sourceLeftInput : UInt, clock @[ALU.scala 38:32]
    sourceLeftInput <= io.sourceLeft @[ALU.scala 38:32]
    reg sourceRightInput : UInt, clock @[ALU.scala 40:32]
    sourceRightInput <= io.sourceRight @[ALU.scala 40:32]
    reg destInput : UInt, clock @[ALU.scala 41:46]
    destInput <= io.dest @[ALU.scala 41:46]
    wire _reg_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _reg_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _reg_T_1 = asFixedPoint(_reg_T, 8) @[package.scala 79:56]
    _reg_WIRE <= _reg_T_1 @[package.scala 79:56]
    wire _reg_WIRE_1 : Fixed<16><<8>>[1] @[ALU.scala 43:28]
    _reg_WIRE_1[0] <= _reg_WIRE @[ALU.scala 43:28]
    reg reg : Fixed<16><<8>>[1], clock with : (reset => (reset, _reg_WIRE_1)) @[ALU.scala 43:20]
    node _sourceLeft_T = eq(sourceLeftInput, UInt<1>("h00")) @[ALU.scala 45:25]
    node _sourceLeft_T_1 = sub(sourceLeftInput, UInt<1>("h01")) @[ALU.scala 45:61]
    node _sourceLeft_T_2 = tail(_sourceLeft_T_1, 1) @[ALU.scala 45:61]
    node sourceLeft = mux(_sourceLeft_T, input, reg[UInt<1>("h00")]) @[ALU.scala 45:8]
    node _sourceRight_T = eq(sourceRightInput, UInt<1>("h00")) @[ALU.scala 47:26]
    node _sourceRight_T_1 = sub(sourceRightInput, UInt<1>("h01")) @[ALU.scala 47:63]
    node _sourceRight_T_2 = tail(_sourceRight_T_1, 1) @[ALU.scala 47:63]
    node sourceRight = mux(_sourceRight_T, input, reg[UInt<1>("h00")]) @[ALU.scala 47:8]
    node _dest_T = eq(destInput, UInt<1>("h00")) @[ALU.scala 51:17]
    node _dest_T_1 = eq(op, UInt<1>("h00")) @[ALU.scala 51:31]
    node _dest_T_2 = or(_dest_T, _dest_T_1) @[ALU.scala 51:25]
    node _dest_T_3 = sub(destInput, UInt<1>("h01")) @[ALU.scala 53:21]
    node _dest_T_4 = tail(_dest_T_3, 1) @[ALU.scala 53:21]
    wire dest : Fixed<16><<8>> @[Demux.scala 11:21]
    when _dest_T_2 : @[Demux.scala 12:16]
      io.output <= dest @[Demux.scala 13:11]
      skip @[Demux.scala 12:16]
    else : @[Demux.scala 14:17]
      reg[UInt<1>("h00")] <= dest @[Demux.scala 15:11]
      skip @[Demux.scala 14:17]
    wire result : Fixed<16><<8>> @[ALU.scala 56:20]
    reg output : Fixed<<8>>, clock @[ALU.scala 57:43]
    output <= result @[ALU.scala 57:43]
    io.output <= output @[ALU.scala 58:13]
    dest <= result @[ALU.scala 59:8]
    result <= input @[ALU.scala 62:10]
    node _T = eq(op, UInt<1>("h01")) @[ALU.scala 64:11]
    when _T : @[ALU.scala 64:26]
      wire _result_WIRE : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_1 = asFixedPoint(_result_T, 8) @[package.scala 79:56]
      _result_WIRE <= _result_T_1 @[package.scala 79:56]
      result <= _result_WIRE @[ALU.scala 65:12]
      skip @[ALU.scala 64:26]
    node _T_1 = eq(op, UInt<2>("h02")) @[ALU.scala 67:11]
    when _T_1 : @[ALU.scala 67:26]
      result <= sourceLeft @[ALU.scala 68:12]
      skip @[ALU.scala 67:26]
    node _T_2 = eq(op, UInt<2>("h03")) @[ALU.scala 72:11]
    when _T_2 : @[ALU.scala 72:25]
      wire _result_WIRE_1 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_2 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_3 = asFixedPoint(_result_T_2, 8) @[package.scala 87:56]
      _result_WIRE_1 <= _result_T_3 @[package.scala 87:56]
      result <= _result_WIRE_1 @[ALU.scala 73:12]
      wire _WIRE : Fixed<<8>> @[package.scala 79:56]
      node _T_3 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_4 = asFixedPoint(_T_3, 8) @[package.scala 79:56]
      _WIRE <= _T_4 @[package.scala 79:56]
      node _T_5 = geq(sourceLeft, _WIRE) @[ALU.scala 132:45]
      node _T_6 = geq(_WIRE, sourceLeft) @[ALU.scala 132:63]
      node _T_7 = and(_T_5, _T_6) @[ALU.scala 132:54]
      node _T_8 = eq(_T_7, UInt<1>("h00")) @[ALU.scala 131:40]
      when _T_8 : @[ALU.scala 74:30]
        wire _result_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
        node _result_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
        node _result_T_5 = asFixedPoint(_result_T_4, 8) @[package.scala 79:56]
        _result_WIRE_2 <= _result_T_5 @[package.scala 79:56]
        result <= _result_WIRE_2 @[ALU.scala 75:14]
        skip @[ALU.scala 74:30]
      skip @[ALU.scala 72:25]
    node _T_9 = eq(op, UInt<3>("h04")) @[ALU.scala 78:11]
    when _T_9 : @[ALU.scala 78:25]
      wire _result_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_7 = asFixedPoint(_result_T_6, 8) @[package.scala 79:56]
      _result_WIRE_3 <= _result_T_7 @[package.scala 79:56]
      result <= _result_WIRE_3 @[ALU.scala 79:12]
      wire _WIRE_1 : Fixed<<8>> @[package.scala 79:56]
      node _T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_11 = asFixedPoint(_T_10, 8) @[package.scala 79:56]
      _WIRE_1 <= _T_11 @[package.scala 79:56]
      node _T_12 = geq(sourceLeft, _WIRE_1) @[ALU.scala 132:45]
      node _T_13 = geq(_WIRE_1, sourceLeft) @[ALU.scala 132:63]
      node _T_14 = and(_T_12, _T_13) @[ALU.scala 132:54]
      node _T_15 = eq(_T_14, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_2 : Fixed<<8>> @[package.scala 79:56]
      node _T_16 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_17 = asFixedPoint(_T_16, 8) @[package.scala 79:56]
      _WIRE_2 <= _T_17 @[package.scala 79:56]
      node _T_18 = geq(sourceRight, _WIRE_2) @[ALU.scala 132:45]
      node _T_19 = geq(_WIRE_2, sourceRight) @[ALU.scala 132:63]
      node _T_20 = and(_T_18, _T_19) @[ALU.scala 132:54]
      node _T_21 = eq(_T_20, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_22 = and(_T_15, _T_21) @[ALU.scala 80:29]
      when _T_22 : @[ALU.scala 80:53]
        wire _result_WIRE_4 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_8 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_9 = asFixedPoint(_result_T_8, 8) @[package.scala 87:56]
        _result_WIRE_4 <= _result_T_9 @[package.scala 87:56]
        result <= _result_WIRE_4 @[ALU.scala 81:14]
        skip @[ALU.scala 80:53]
      skip @[ALU.scala 78:25]
    node _T_23 = eq(op, UInt<3>("h05")) @[ALU.scala 84:11]
    when _T_23 : @[ALU.scala 84:24]
      wire _result_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_11 = asFixedPoint(_result_T_10, 8) @[package.scala 79:56]
      _result_WIRE_5 <= _result_T_11 @[package.scala 79:56]
      result <= _result_WIRE_5 @[ALU.scala 85:12]
      wire _WIRE_3 : Fixed<<8>> @[package.scala 79:56]
      node _T_24 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_25 = asFixedPoint(_T_24, 8) @[package.scala 79:56]
      _WIRE_3 <= _T_25 @[package.scala 79:56]
      node _T_26 = geq(sourceLeft, _WIRE_3) @[ALU.scala 132:45]
      node _T_27 = geq(_WIRE_3, sourceLeft) @[ALU.scala 132:63]
      node _T_28 = and(_T_26, _T_27) @[ALU.scala 132:54]
      node _T_29 = eq(_T_28, UInt<1>("h00")) @[ALU.scala 131:40]
      wire _WIRE_4 : Fixed<<8>> @[package.scala 79:56]
      node _T_30 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _T_31 = asFixedPoint(_T_30, 8) @[package.scala 79:56]
      _WIRE_4 <= _T_31 @[package.scala 79:56]
      node _T_32 = geq(sourceRight, _WIRE_4) @[ALU.scala 132:45]
      node _T_33 = geq(_WIRE_4, sourceRight) @[ALU.scala 132:63]
      node _T_34 = and(_T_32, _T_33) @[ALU.scala 132:54]
      node _T_35 = eq(_T_34, UInt<1>("h00")) @[ALU.scala 131:40]
      node _T_36 = or(_T_29, _T_35) @[ALU.scala 86:29]
      when _T_36 : @[ALU.scala 86:53]
        wire _result_WIRE_6 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_12 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_13 = asFixedPoint(_result_T_12, 8) @[package.scala 87:56]
        _result_WIRE_6 <= _result_T_13 @[package.scala 87:56]
        result <= _result_WIRE_6 @[ALU.scala 87:14]
        skip @[ALU.scala 86:53]
      skip @[ALU.scala 84:24]
    node _T_37 = eq(op, UInt<3>("h06")) @[ALU.scala 92:11]
    when _T_37 : @[ALU.scala 92:31]
      wire _result_WIRE_7 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_14 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_15 = asFixedPoint(_result_T_14, 8) @[package.scala 87:56]
      _result_WIRE_7 <= _result_T_15 @[package.scala 87:56]
      node _result_T_16 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_17 = asSInt(_result_WIRE_7) @[package.scala 168:49]
      node _result_T_18 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T = mul(_result_T_16, _result_T_18) @[package.scala 122:18]
      node _result_mac_T_1 = shl(_result_T_17, 8) @[package.scala 122:29]
      node result_mac = add(_result_mac_T, _result_mac_T_1) @[package.scala 122:23]
      node result_mask0 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_1 = sub(_result_mask1_T, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_2 = tail(_result_mask1_T_1, 1) @[package.scala 125:44]
      node result_mask1 = asSInt(_result_mask1_T_2) @[package.scala 125:44]
      node result_mask2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T = and(result_mac, result_mask0) @[package.scala 130:16]
      node _result_adjustment_T_1 = asSInt(_result_adjustment_T) @[package.scala 130:16]
      node _result_adjustment_T_2 = neq(_result_adjustment_T_1, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_3 = and(result_mac, result_mask1) @[package.scala 130:44]
      node _result_adjustment_T_4 = asSInt(_result_adjustment_T_3) @[package.scala 130:44]
      node _result_adjustment_T_5 = neq(_result_adjustment_T_4, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_6 = and(result_mac, result_mask2) @[package.scala 130:71]
      node _result_adjustment_T_7 = asSInt(_result_adjustment_T_6) @[package.scala 130:71]
      node _result_adjustment_T_8 = neq(_result_adjustment_T_7, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_9 = or(_result_adjustment_T_5, _result_adjustment_T_8) @[package.scala 130:62]
      node _result_adjustment_T_10 = and(_result_adjustment_T_2, _result_adjustment_T_9) @[package.scala 130:34]
      node result_adjustment = mux(_result_adjustment_T_10, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T = shr(result_mac, 8) @[package.scala 135:26]
      node _result_adjusted_T_1 = add(_result_adjusted_T, result_adjustment) @[package.scala 135:42]
      node _result_adjusted_T_2 = tail(_result_adjusted_T_1, 1) @[package.scala 135:42]
      node result_adjusted = asSInt(_result_adjusted_T_2) @[package.scala 135:42]
      node _result_saturated_T = gt(result_adjusted, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_1 = lt(result_adjusted, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_2 = mux(_result_saturated_T_1, asSInt(UInt<16>("h08000")), result_adjusted) @[package.scala 103:26]
      node result_saturated = mux(_result_saturated_T, asSInt(UInt<16>("h07fff")), _result_saturated_T_2) @[package.scala 103:8]
      node _result_T_19 = asFixedPoint(result_saturated, 8) @[package.scala 138:27]
      result <= _result_T_19 @[ALU.scala 93:12]
      skip @[ALU.scala 92:31]
    node _T_38 = eq(op, UInt<3>("h07")) @[ALU.scala 95:11]
    when _T_38 : @[ALU.scala 95:31]
      wire _result_WIRE_8 : Fixed<16><<8>> @[package.scala 87:56]
      node _result_T_20 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
      node _result_T_21 = asFixedPoint(_result_T_20, 8) @[package.scala 87:56]
      _result_WIRE_8 <= _result_T_21 @[package.scala 87:56]
      node _result_T_22 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_23 = asSInt(_result_WIRE_8) @[package.scala 176:56]
      node _result_T_24 = sub(asSInt(UInt<1>("h00")), _result_T_23) @[package.scala 176:45]
      node _result_T_25 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_2 = mul(_result_T_22, _result_T_25) @[package.scala 122:18]
      node _result_mac_T_3 = shl(_result_T_24, 8) @[package.scala 122:29]
      node result_mac_1 = add(_result_mac_T_2, _result_mac_T_3) @[package.scala 122:23]
      node result_mask0_1 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_4 = sub(_result_mask1_T_3, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_5 = tail(_result_mask1_T_4, 1) @[package.scala 125:44]
      node result_mask1_1 = asSInt(_result_mask1_T_5) @[package.scala 125:44]
      node result_mask2_1 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_11 = and(result_mac_1, result_mask0_1) @[package.scala 130:16]
      node _result_adjustment_T_12 = asSInt(_result_adjustment_T_11) @[package.scala 130:16]
      node _result_adjustment_T_13 = neq(_result_adjustment_T_12, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_14 = and(result_mac_1, result_mask1_1) @[package.scala 130:44]
      node _result_adjustment_T_15 = asSInt(_result_adjustment_T_14) @[package.scala 130:44]
      node _result_adjustment_T_16 = neq(_result_adjustment_T_15, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_17 = and(result_mac_1, result_mask2_1) @[package.scala 130:71]
      node _result_adjustment_T_18 = asSInt(_result_adjustment_T_17) @[package.scala 130:71]
      node _result_adjustment_T_19 = neq(_result_adjustment_T_18, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_20 = or(_result_adjustment_T_16, _result_adjustment_T_19) @[package.scala 130:62]
      node _result_adjustment_T_21 = and(_result_adjustment_T_13, _result_adjustment_T_20) @[package.scala 130:34]
      node result_adjustment_1 = mux(_result_adjustment_T_21, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_3 = shr(result_mac_1, 8) @[package.scala 135:26]
      node _result_adjusted_T_4 = add(_result_adjusted_T_3, result_adjustment_1) @[package.scala 135:42]
      node _result_adjusted_T_5 = tail(_result_adjusted_T_4, 1) @[package.scala 135:42]
      node result_adjusted_1 = asSInt(_result_adjusted_T_5) @[package.scala 135:42]
      node _result_saturated_T_3 = gt(result_adjusted_1, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_4 = lt(result_adjusted_1, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_5 = mux(_result_saturated_T_4, asSInt(UInt<16>("h08000")), result_adjusted_1) @[package.scala 103:26]
      node result_saturated_1 = mux(_result_saturated_T_3, asSInt(UInt<16>("h07fff")), _result_saturated_T_5) @[package.scala 103:8]
      node _result_T_26 = asFixedPoint(result_saturated_1, 8) @[package.scala 138:27]
      result <= _result_T_26 @[ALU.scala 96:12]
      skip @[ALU.scala 95:31]
    node _T_39 = eq(op, UInt<4>("h08")) @[ALU.scala 98:11]
    when _T_39 : @[ALU.scala 98:25]
      node _result_T_27 = asSInt(sourceLeft) @[package.scala 168:37]
      node _result_T_28 = asSInt(sourceRight) @[package.scala 168:49]
      node _result_T_29 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_4 = mul(_result_T_27, _result_T_29) @[package.scala 122:18]
      node _result_mac_T_5 = shl(_result_T_28, 8) @[package.scala 122:29]
      node result_mac_2 = add(_result_mac_T_4, _result_mac_T_5) @[package.scala 122:23]
      node result_mask0_2 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_6 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_7 = sub(_result_mask1_T_6, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_8 = tail(_result_mask1_T_7, 1) @[package.scala 125:44]
      node result_mask1_2 = asSInt(_result_mask1_T_8) @[package.scala 125:44]
      node result_mask2_2 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_22 = and(result_mac_2, result_mask0_2) @[package.scala 130:16]
      node _result_adjustment_T_23 = asSInt(_result_adjustment_T_22) @[package.scala 130:16]
      node _result_adjustment_T_24 = neq(_result_adjustment_T_23, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_25 = and(result_mac_2, result_mask1_2) @[package.scala 130:44]
      node _result_adjustment_T_26 = asSInt(_result_adjustment_T_25) @[package.scala 130:44]
      node _result_adjustment_T_27 = neq(_result_adjustment_T_26, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_28 = and(result_mac_2, result_mask2_2) @[package.scala 130:71]
      node _result_adjustment_T_29 = asSInt(_result_adjustment_T_28) @[package.scala 130:71]
      node _result_adjustment_T_30 = neq(_result_adjustment_T_29, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_31 = or(_result_adjustment_T_27, _result_adjustment_T_30) @[package.scala 130:62]
      node _result_adjustment_T_32 = and(_result_adjustment_T_24, _result_adjustment_T_31) @[package.scala 130:34]
      node result_adjustment_2 = mux(_result_adjustment_T_32, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_6 = shr(result_mac_2, 8) @[package.scala 135:26]
      node _result_adjusted_T_7 = add(_result_adjusted_T_6, result_adjustment_2) @[package.scala 135:42]
      node _result_adjusted_T_8 = tail(_result_adjusted_T_7, 1) @[package.scala 135:42]
      node result_adjusted_2 = asSInt(_result_adjusted_T_8) @[package.scala 135:42]
      node _result_saturated_T_6 = gt(result_adjusted_2, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_7 = lt(result_adjusted_2, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_8 = mux(_result_saturated_T_7, asSInt(UInt<16>("h08000")), result_adjusted_2) @[package.scala 103:26]
      node result_saturated_2 = mux(_result_saturated_T_6, asSInt(UInt<16>("h07fff")), _result_saturated_T_8) @[package.scala 103:8]
      node _result_T_30 = asFixedPoint(result_saturated_2, 8) @[package.scala 138:27]
      result <= _result_T_30 @[ALU.scala 99:12]
      skip @[ALU.scala 98:25]
    node _T_40 = eq(op, UInt<4>("h09")) @[ALU.scala 101:11]
    when _T_40 : @[ALU.scala 101:30]
      node _result_T_31 = asSInt(sourceLeft) @[package.scala 176:37]
      node _result_T_32 = asSInt(sourceRight) @[package.scala 176:56]
      node _result_T_33 = sub(asSInt(UInt<1>("h00")), _result_T_32) @[package.scala 176:45]
      node _result_T_34 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 146:31]
      node _result_mac_T_6 = mul(_result_T_31, _result_T_34) @[package.scala 122:18]
      node _result_mac_T_7 = shl(_result_T_33, 8) @[package.scala 122:29]
      node result_mac_3 = add(_result_mac_T_6, _result_mac_T_7) @[package.scala 122:23]
      node result_mask0_3 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_9 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_10 = sub(_result_mask1_T_9, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_11 = tail(_result_mask1_T_10, 1) @[package.scala 125:44]
      node result_mask1_3 = asSInt(_result_mask1_T_11) @[package.scala 125:44]
      node result_mask2_3 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_33 = and(result_mac_3, result_mask0_3) @[package.scala 130:16]
      node _result_adjustment_T_34 = asSInt(_result_adjustment_T_33) @[package.scala 130:16]
      node _result_adjustment_T_35 = neq(_result_adjustment_T_34, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_36 = and(result_mac_3, result_mask1_3) @[package.scala 130:44]
      node _result_adjustment_T_37 = asSInt(_result_adjustment_T_36) @[package.scala 130:44]
      node _result_adjustment_T_38 = neq(_result_adjustment_T_37, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_39 = and(result_mac_3, result_mask2_3) @[package.scala 130:71]
      node _result_adjustment_T_40 = asSInt(_result_adjustment_T_39) @[package.scala 130:71]
      node _result_adjustment_T_41 = neq(_result_adjustment_T_40, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_42 = or(_result_adjustment_T_38, _result_adjustment_T_41) @[package.scala 130:62]
      node _result_adjustment_T_43 = and(_result_adjustment_T_35, _result_adjustment_T_42) @[package.scala 130:34]
      node result_adjustment_3 = mux(_result_adjustment_T_43, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_9 = shr(result_mac_3, 8) @[package.scala 135:26]
      node _result_adjusted_T_10 = add(_result_adjusted_T_9, result_adjustment_3) @[package.scala 135:42]
      node _result_adjusted_T_11 = tail(_result_adjusted_T_10, 1) @[package.scala 135:42]
      node result_adjusted_3 = asSInt(_result_adjusted_T_11) @[package.scala 135:42]
      node _result_saturated_T_9 = gt(result_adjusted_3, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_10 = lt(result_adjusted_3, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_11 = mux(_result_saturated_T_10, asSInt(UInt<16>("h08000")), result_adjusted_3) @[package.scala 103:26]
      node result_saturated_3 = mux(_result_saturated_T_9, asSInt(UInt<16>("h07fff")), _result_saturated_T_11) @[package.scala 103:8]
      node _result_T_35 = asFixedPoint(result_saturated_3, 8) @[package.scala 138:27]
      result <= _result_T_35 @[ALU.scala 102:12]
      skip @[ALU.scala 101:30]
    node _T_41 = eq(op, UInt<4>("h0a")) @[ALU.scala 104:11]
    when _T_41 : @[ALU.scala 104:30]
      node _result_T_36 = asSInt(sourceLeft) @[package.scala 160:38]
      node _result_T_37 = asSInt(sourceRight) @[package.scala 160:50]
      node _result_mac_T_8 = mul(_result_T_36, _result_T_37) @[package.scala 122:18]
      node _result_mac_T_9 = shl(asSInt(UInt<1>("h00")), 8) @[package.scala 122:29]
      node result_mac_4 = add(_result_mac_T_8, _result_mac_T_9) @[package.scala 122:23]
      node result_mask0_4 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 124:21]
      node _result_mask1_T_12 = shl(asSInt(UInt<2>("h01")), 7) @[package.scala 125:22]
      node _result_mask1_T_13 = sub(_result_mask1_T_12, asSInt(UInt<2>("h01"))) @[package.scala 125:44]
      node _result_mask1_T_14 = tail(_result_mask1_T_13, 1) @[package.scala 125:44]
      node result_mask1_4 = asSInt(_result_mask1_T_14) @[package.scala 125:44]
      node result_mask2_4 = shl(asSInt(UInt<2>("h01")), 8) @[package.scala 126:21]
      node _result_adjustment_T_44 = and(result_mac_4, result_mask0_4) @[package.scala 130:16]
      node _result_adjustment_T_45 = asSInt(_result_adjustment_T_44) @[package.scala 130:16]
      node _result_adjustment_T_46 = neq(_result_adjustment_T_45, asSInt(UInt<1>("h00"))) @[package.scala 130:25]
      node _result_adjustment_T_47 = and(result_mac_4, result_mask1_4) @[package.scala 130:44]
      node _result_adjustment_T_48 = asSInt(_result_adjustment_T_47) @[package.scala 130:44]
      node _result_adjustment_T_49 = neq(_result_adjustment_T_48, asSInt(UInt<1>("h00"))) @[package.scala 130:53]
      node _result_adjustment_T_50 = and(result_mac_4, result_mask2_4) @[package.scala 130:71]
      node _result_adjustment_T_51 = asSInt(_result_adjustment_T_50) @[package.scala 130:71]
      node _result_adjustment_T_52 = neq(_result_adjustment_T_51, asSInt(UInt<1>("h00"))) @[package.scala 130:80]
      node _result_adjustment_T_53 = or(_result_adjustment_T_49, _result_adjustment_T_52) @[package.scala 130:62]
      node _result_adjustment_T_54 = and(_result_adjustment_T_46, _result_adjustment_T_53) @[package.scala 130:34]
      node result_adjustment_4 = mux(_result_adjustment_T_54, asSInt(UInt<2>("h01")), asSInt(UInt<1>("h00"))) @[package.scala 129:10]
      node _result_adjusted_T_12 = shr(result_mac_4, 8) @[package.scala 135:26]
      node _result_adjusted_T_13 = add(_result_adjusted_T_12, result_adjustment_4) @[package.scala 135:42]
      node _result_adjusted_T_14 = tail(_result_adjusted_T_13, 1) @[package.scala 135:42]
      node result_adjusted_4 = asSInt(_result_adjusted_T_14) @[package.scala 135:42]
      node _result_saturated_T_12 = gt(result_adjusted_4, asSInt(UInt<16>("h07fff"))) @[package.scala 103:11]
      node _result_saturated_T_13 = lt(result_adjusted_4, asSInt(UInt<16>("h08000"))) @[package.scala 103:29]
      node _result_saturated_T_14 = mux(_result_saturated_T_13, asSInt(UInt<16>("h08000")), result_adjusted_4) @[package.scala 103:26]
      node result_saturated_4 = mux(_result_saturated_T_12, asSInt(UInt<16>("h07fff")), _result_saturated_T_14) @[package.scala 103:8]
      node _result_T_38 = asFixedPoint(result_saturated_4, 8) @[package.scala 138:27]
      result <= _result_T_38 @[ALU.scala 105:12]
      skip @[ALU.scala 104:30]
    node _T_42 = eq(op, UInt<4>("h0b")) @[ALU.scala 107:11]
    when _T_42 : @[ALU.scala 107:25]
      node _result_T_39 = lt(sourceLeft, asFixedPoint(UInt<1>("h00"), 0)) @[ALU.scala 108:26]
      node _result_T_40 = sub(asFixedPoint(UInt<1>("h00"), 0), sourceLeft) @[ALU.scala 108:26]
      node _result_T_41 = tail(_result_T_40, 1) @[ALU.scala 108:26]
      node _result_T_42 = asFixedPoint(_result_T_41, 8) @[ALU.scala 108:26]
      node _result_T_43 = mux(_result_T_39, _result_T_42, sourceLeft) @[ALU.scala 108:26]
      result <= _result_T_43 @[ALU.scala 108:12]
      skip @[ALU.scala 107:25]
    node _T_43 = eq(op, UInt<4>("h0c")) @[ALU.scala 112:11]
    when _T_43 : @[ALU.scala 112:33]
      wire _result_WIRE_9 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_44 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_45 = asFixedPoint(_result_T_44, 8) @[package.scala 79:56]
      _result_WIRE_9 <= _result_T_45 @[package.scala 79:56]
      result <= _result_WIRE_9 @[ALU.scala 113:12]
      node _T_44 = gt(sourceLeft, sourceRight) @[ALU.scala 114:21]
      when _T_44 : @[ALU.scala 114:36]
        wire _result_WIRE_10 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_46 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_47 = asFixedPoint(_result_T_46, 8) @[package.scala 87:56]
        _result_WIRE_10 <= _result_T_47 @[package.scala 87:56]
        result <= _result_WIRE_10 @[ALU.scala 115:14]
        skip @[ALU.scala 114:36]
      skip @[ALU.scala 112:33]
    node _T_45 = eq(op, UInt<4>("h0d")) @[ALU.scala 118:11]
    when _T_45 : @[ALU.scala 118:38]
      wire _result_WIRE_11 : Fixed<16><<8>> @[package.scala 79:56]
      node _result_T_48 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
      node _result_T_49 = asFixedPoint(_result_T_48, 8) @[package.scala 79:56]
      _result_WIRE_11 <= _result_T_49 @[package.scala 79:56]
      result <= _result_WIRE_11 @[ALU.scala 119:12]
      node _T_46 = geq(sourceLeft, sourceRight) @[ALU.scala 120:21]
      when _T_46 : @[ALU.scala 120:37]
        wire _result_WIRE_12 : Fixed<16><<8>> @[package.scala 87:56]
        node _result_T_50 = asUInt(asFixedPoint(UInt<10>("h0100"), 8)) @[package.scala 87:56]
        node _result_T_51 = asFixedPoint(_result_T_50, 8) @[package.scala 87:56]
        _result_WIRE_12 <= _result_T_51 @[package.scala 87:56]
        result <= _result_WIRE_12 @[ALU.scala 121:14]
        skip @[ALU.scala 120:37]
      skip @[ALU.scala 118:38]
    node _T_47 = eq(op, UInt<4>("h0e")) @[ALU.scala 124:11]
    when _T_47 : @[ALU.scala 124:25]
      node _result_T_52 = lt(sourceLeft, sourceRight) @[ALU.scala 125:29]
      node _result_T_53 = mux(_result_T_52, sourceLeft, sourceRight) @[ALU.scala 125:29]
      result <= _result_T_53 @[ALU.scala 125:12]
      skip @[ALU.scala 124:25]
    node _T_48 = eq(op, UInt<4>("h0f")) @[ALU.scala 127:11]
    when _T_48 : @[ALU.scala 127:25]
      node _result_T_54 = lt(sourceLeft, sourceRight) @[ALU.scala 128:29]
      node _result_T_55 = mux(_result_T_54, sourceRight, sourceLeft) @[ALU.scala 128:29]
      result <= _result_T_55 @[ALU.scala 128:12]
      skip @[ALU.scala 127:25]
    
  module ALUArray : 
    input clock : Clock
    input reset : Reset
    output io : {flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip instruction : {flip ready : UInt<1>, valid : UInt<1>, bits : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}}}
    
    inst output of Queue_18 @[ALUArray.scala 34:22]
    output.clock <= clock
    output.reset <= reset
    io.output.bits[0] <= output.io.deq.bits[0] @[ALUArray.scala 35:13]
    io.output.bits[1] <= output.io.deq.bits[1] @[ALUArray.scala 35:13]
    io.output.bits[2] <= output.io.deq.bits[2] @[ALUArray.scala 35:13]
    io.output.bits[3] <= output.io.deq.bits[3] @[ALUArray.scala 35:13]
    io.output.bits[4] <= output.io.deq.bits[4] @[ALUArray.scala 35:13]
    io.output.bits[5] <= output.io.deq.bits[5] @[ALUArray.scala 35:13]
    io.output.bits[6] <= output.io.deq.bits[6] @[ALUArray.scala 35:13]
    io.output.bits[7] <= output.io.deq.bits[7] @[ALUArray.scala 35:13]
    io.output.valid <= output.io.deq.valid @[ALUArray.scala 35:13]
    output.io.deq.ready <= io.output.ready @[ALUArray.scala 35:13]
    node _inputNotNeeded_T = eq(io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 38:25]
    node _inputNotNeeded_T_1 = eq(io.instruction.bits.op, UInt<1>("h01")) @[ALUArray.scala 38:62]
    node _inputNotNeeded_T_2 = or(_inputNotNeeded_T, _inputNotNeeded_T_1) @[ALUArray.scala 38:39]
    node _inputNotNeeded_T_3 = eq(io.instruction.bits.op, UInt<2>("h02")) @[Op.scala 40:21]
    node _inputNotNeeded_T_4 = eq(io.instruction.bits.op, UInt<2>("h03")) @[Op.scala 40:21]
    node _inputNotNeeded_T_5 = eq(io.instruction.bits.op, UInt<3>("h06")) @[Op.scala 40:21]
    node _inputNotNeeded_T_6 = eq(io.instruction.bits.op, UInt<3>("h07")) @[Op.scala 40:21]
    node _inputNotNeeded_T_7 = eq(io.instruction.bits.op, UInt<4>("h0b")) @[Op.scala 40:21]
    node _inputNotNeeded_T_8 = and(_inputNotNeeded_T_3, _inputNotNeeded_T_4) @[Op.scala 40:39]
    node _inputNotNeeded_T_9 = and(_inputNotNeeded_T_8, _inputNotNeeded_T_5) @[Op.scala 40:39]
    node _inputNotNeeded_T_10 = and(_inputNotNeeded_T_9, _inputNotNeeded_T_6) @[Op.scala 40:39]
    node _inputNotNeeded_T_11 = and(_inputNotNeeded_T_10, _inputNotNeeded_T_7) @[Op.scala 40:39]
    node _inputNotNeeded_T_12 = neq(io.instruction.bits.sourceLeft, UInt<1>("h00")) @[ALUArray.scala 41:40]
    node _inputNotNeeded_T_13 = and(_inputNotNeeded_T_11, _inputNotNeeded_T_12) @[ALUArray.scala 41:9]
    node _inputNotNeeded_T_14 = or(_inputNotNeeded_T_2, _inputNotNeeded_T_13) @[ALUArray.scala 38:76]
    node _inputNotNeeded_T_15 = neq(io.instruction.bits.sourceLeft, UInt<1>("h00")) @[ALUArray.scala 42:36]
    node _inputNotNeeded_T_16 = neq(io.instruction.bits.sourceRight, UInt<1>("h00")) @[ALUArray.scala 42:76]
    node _inputNotNeeded_T_17 = and(_inputNotNeeded_T_15, _inputNotNeeded_T_16) @[ALUArray.scala 42:44]
    node inputNotNeeded = or(_inputNotNeeded_T_14, _inputNotNeeded_T_17) @[ALUArray.scala 41:49]
    node inputNeeded = eq(inputNotNeeded, UInt<1>("h00")) @[ALUArray.scala 43:21]
    node _io_input_ready_T = and(output.io.enq.ready, io.instruction.valid) @[ALUArray.scala 45:38]
    node _io_input_ready_T_1 = and(_io_input_ready_T, inputNeeded) @[ALUArray.scala 45:59]
    io.input.ready <= _io_input_ready_T_1 @[ALUArray.scala 45:15]
    node _io_instruction_ready_T = eq(inputNeeded, UInt<1>("h00")) @[ALUArray.scala 46:41]
    node _io_instruction_ready_T_1 = or(io.input.valid, _io_instruction_ready_T) @[ALUArray.scala 46:38]
    node _io_instruction_ready_T_2 = and(_io_instruction_ready_T_1, output.io.enq.ready) @[ALUArray.scala 46:55]
    io.instruction.ready <= _io_instruction_ready_T_2 @[ALUArray.scala 46:21]
    node _output_io_enq_valid_T = eq(inputNeeded, UInt<1>("h00")) @[ALUArray.scala 48:21]
    node _output_io_enq_valid_T_1 = or(io.input.valid, _output_io_enq_valid_T) @[ALUArray.scala 48:18]
    node _output_io_enq_valid_T_2 = and(_output_io_enq_valid_T_1, io.instruction.valid) @[ALUArray.scala 48:35]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[2] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h00") @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[1] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr : UInt<1>[2], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[1] <= output_io_enq_valid_sr[0] @[ShiftRegister.scala 13:11]
    output_io_enq_valid_sr[0] <= _output_io_enq_valid_T_2 @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[1] @[ALUArray.scala 47:23]
    inst m of ALU @[ALUArray.scala 53:19]
    m.clock <= clock
    m.reset <= reset
    node _m_io_op_T = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_1 = mux(_m_io_op_T, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m.io.op <= _m_io_op_T_1 @[ALUArray.scala 62:13]
    m.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m.io.input <= io.input.bits[0] @[ALUArray.scala 70:16]
    output.io.enq.bits[0] <= m.io.output @[ALUArray.scala 71:27]
    inst m_1 of ALU_1 @[ALUArray.scala 53:19]
    m_1.clock <= clock
    m_1.reset <= reset
    node _m_io_op_T_2 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_3 = mux(_m_io_op_T_2, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_1.io.op <= _m_io_op_T_3 @[ALUArray.scala 62:13]
    m_1.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_1.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_1.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_1.io.input <= io.input.bits[1] @[ALUArray.scala 70:16]
    output.io.enq.bits[1] <= m_1.io.output @[ALUArray.scala 71:27]
    inst m_2 of ALU_2 @[ALUArray.scala 53:19]
    m_2.clock <= clock
    m_2.reset <= reset
    node _m_io_op_T_4 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_5 = mux(_m_io_op_T_4, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_2.io.op <= _m_io_op_T_5 @[ALUArray.scala 62:13]
    m_2.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_2.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_2.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_2.io.input <= io.input.bits[2] @[ALUArray.scala 70:16]
    output.io.enq.bits[2] <= m_2.io.output @[ALUArray.scala 71:27]
    inst m_3 of ALU_3 @[ALUArray.scala 53:19]
    m_3.clock <= clock
    m_3.reset <= reset
    node _m_io_op_T_6 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_7 = mux(_m_io_op_T_6, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_3.io.op <= _m_io_op_T_7 @[ALUArray.scala 62:13]
    m_3.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_3.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_3.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_3.io.input <= io.input.bits[3] @[ALUArray.scala 70:16]
    output.io.enq.bits[3] <= m_3.io.output @[ALUArray.scala 71:27]
    inst m_4 of ALU_4 @[ALUArray.scala 53:19]
    m_4.clock <= clock
    m_4.reset <= reset
    node _m_io_op_T_8 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_9 = mux(_m_io_op_T_8, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_4.io.op <= _m_io_op_T_9 @[ALUArray.scala 62:13]
    m_4.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_4.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_4.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_4.io.input <= io.input.bits[4] @[ALUArray.scala 70:16]
    output.io.enq.bits[4] <= m_4.io.output @[ALUArray.scala 71:27]
    inst m_5 of ALU_5 @[ALUArray.scala 53:19]
    m_5.clock <= clock
    m_5.reset <= reset
    node _m_io_op_T_10 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_11 = mux(_m_io_op_T_10, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_5.io.op <= _m_io_op_T_11 @[ALUArray.scala 62:13]
    m_5.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_5.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_5.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_5.io.input <= io.input.bits[5] @[ALUArray.scala 70:16]
    output.io.enq.bits[5] <= m_5.io.output @[ALUArray.scala 71:27]
    inst m_6 of ALU_6 @[ALUArray.scala 53:19]
    m_6.clock <= clock
    m_6.reset <= reset
    node _m_io_op_T_12 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_13 = mux(_m_io_op_T_12, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_6.io.op <= _m_io_op_T_13 @[ALUArray.scala 62:13]
    m_6.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_6.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_6.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_6.io.input <= io.input.bits[6] @[ALUArray.scala 70:16]
    output.io.enq.bits[6] <= m_6.io.output @[ALUArray.scala 71:27]
    inst m_7 of ALU_7 @[ALUArray.scala 53:19]
    m_7.clock <= clock
    m_7.reset <= reset
    node _m_io_op_T_14 = and(io.instruction.ready, io.instruction.valid) @[ALUArray.scala 63:25]
    node _m_io_op_T_15 = mux(_m_io_op_T_14, io.instruction.bits.op, UInt<1>("h00")) @[ALUArray.scala 62:19]
    m_7.io.op <= _m_io_op_T_15 @[ALUArray.scala 62:13]
    m_7.io.sourceLeft <= io.instruction.bits.sourceLeft @[ALUArray.scala 67:21]
    m_7.io.sourceRight <= io.instruction.bits.sourceRight @[ALUArray.scala 68:22]
    m_7.io.dest <= io.instruction.bits.dest @[ALUArray.scala 69:15]
    m_7.io.input <= io.input.bits[7] @[ALUArray.scala 70:16]
    output.io.enq.bits[7] <= m_7.io.output @[ALUArray.scala 71:27]
    
  module Sink : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    io.in.ready <= UInt<1>("h01") @[Sink.scala 14:15]
    
  module Demux_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module Queue_19 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}
    
    cmem ram : UInt<1>[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Mux : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0].bits[0] <= io.in[0].bits[0] @[Mux.scala 47:19]
    in[0].bits[1] <= io.in[0].bits[1] @[Mux.scala 47:19]
    in[0].bits[2] <= io.in[0].bits[2] @[Mux.scala 47:19]
    in[0].bits[3] <= io.in[0].bits[3] @[Mux.scala 47:19]
    in[0].bits[4] <= io.in[0].bits[4] @[Mux.scala 47:19]
    in[0].bits[5] <= io.in[0].bits[5] @[Mux.scala 47:19]
    in[0].bits[6] <= io.in[0].bits[6] @[Mux.scala 47:19]
    in[0].bits[7] <= io.in[0].bits[7] @[Mux.scala 47:19]
    in[0].valid <= io.in[0].valid @[Mux.scala 47:19]
    io.in[0].ready <= in[0].ready @[Mux.scala 47:19]
    in[1].bits[0] <= io.in[1].bits[0] @[Mux.scala 47:19]
    in[1].bits[1] <= io.in[1].bits[1] @[Mux.scala 47:19]
    in[1].bits[2] <= io.in[1].bits[2] @[Mux.scala 47:19]
    in[1].bits[3] <= io.in[1].bits[3] @[Mux.scala 47:19]
    in[1].bits[4] <= io.in[1].bits[4] @[Mux.scala 47:19]
    in[1].bits[5] <= io.in[1].bits[5] @[Mux.scala 47:19]
    in[1].bits[6] <= io.in[1].bits[6] @[Mux.scala 47:19]
    in[1].bits[7] <= io.in[1].bits[7] @[Mux.scala 47:19]
    in[1].valid <= io.in[1].valid @[Mux.scala 47:19]
    io.in[1].ready <= in[1].ready @[Mux.scala 47:19]
    in[UInt<1>("h00")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    in[UInt<1>("h01")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    io.out.bits[0] <= in[io.sel.bits].bits[0] @[Mux.scala 57:15]
    io.out.bits[1] <= in[io.sel.bits].bits[1] @[Mux.scala 57:15]
    io.out.bits[2] <= in[io.sel.bits].bits[2] @[Mux.scala 57:15]
    io.out.bits[3] <= in[io.sel.bits].bits[3] @[Mux.scala 57:15]
    io.out.bits[4] <= in[io.sel.bits].bits[4] @[Mux.scala 57:15]
    io.out.bits[5] <= in[io.sel.bits].bits[5] @[Mux.scala 57:15]
    io.out.bits[6] <= in[io.sel.bits].bits[6] @[Mux.scala 57:15]
    io.out.bits[7] <= in[io.sel.bits].bits[7] @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]
    
  module Queue_20 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}
    
    cmem ram : UInt<1>[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Demux_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module Queue_21 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}
    
    cmem ram : UInt<1>[1] @[Decoupled.scala 218:16]
    wire enq_ptr_value : UInt
    enq_ptr_value <= UInt<1>("h00")
    wire deq_ptr_value : UInt
    deq_ptr_value <= UInt<1>("h00")
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[UInt<1>("h00")], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<1>("h01"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module MultiEnqueue_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[3]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[3]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[4]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_3 = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[4]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_3 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = or(io.out[3].ready, enq_3) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_4 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _allEnqueued_T_5 = and(_allEnqueued_T_4, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_5, _allEnqueued_T_3) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_3_valid_T = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_3_valid_T_1 = and(io.in.valid, _io_out_3_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[3].valid <= _io_out_3_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_3 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_3 = eq(enq_3, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_3 : @[MultiEnqueue.scala 31:21]
        node _enq_3_T = and(io.out[3].valid, io.out[3].ready) @[MultiEnqueue.scala 32:35]
        enq_3 <= _enq_3_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module AccumulatorWithALUArray : 
    input clock : Clock
    input reset : Reset
    output io : {flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, computed : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, nooped : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst acc of Accumulator @[AccumulatorWithALUArray.scala 44:19]
    acc.clock <= clock
    acc.reset <= reset
    inst alu of ALUArray @[AccumulatorWithALUArray.scala 45:19]
    alu.clock <= clock
    alu.reset <= reset
    inst aluOutputSink of Sink @[AccumulatorWithALUArray.scala 46:29]
    aluOutputSink.clock <= clock
    aluOutputSink.reset <= reset
    wire aluOutputForAccInput : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]} @[AccumulatorWithALUArray.scala 50:34]
    io.wrote.bits <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 56:17]
    node _io_wrote_valid_T = eq(io.control.bits.instruction.op, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 58:33]
    node _io_wrote_valid_T_1 = mux(_io_wrote_valid_T, acc.io.wrote.valid, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 57:24]
    io.wrote.valid <= _io_wrote_valid_T_1 @[AccumulatorWithALUArray.scala 57:18]
    acc.io.wrote.ready <= io.wrote.ready @[AccumulatorWithALUArray.scala 62:22]
    io.computed.bits <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 63:20]
    io.computed.valid <= alu.io.output.valid @[AccumulatorWithALUArray.scala 64:21]
    io.nooped.bits <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 65:18]
    node _io_nooped_valid_T = eq(io.control.bits.instruction.op, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 66:50]
    node _io_nooped_valid_T_1 = eq(io.control.bits.read, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 66:61]
    node _io_nooped_valid_T_2 = and(_io_nooped_valid_T, _io_nooped_valid_T_1) @[AccumulatorWithALUArray.scala 66:58]
    node _io_nooped_valid_T_3 = eq(io.control.bits.write, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 66:83]
    node _io_nooped_valid_T_4 = and(_io_nooped_valid_T_2, _io_nooped_valid_T_3) @[AccumulatorWithALUArray.scala 66:80]
    node _io_nooped_valid_T_5 = and(_io_nooped_valid_T_4, io.control.ready) @[AccumulatorWithALUArray.scala 66:103]
    io.nooped.valid <= _io_nooped_valid_T_5 @[AccumulatorWithALUArray.scala 66:19]
    acc.io.tracepoint <= io.tracepoint @[AccumulatorWithALUArray.scala 68:21]
    acc.io.programCounter <= io.programCounter @[AccumulatorWithALUArray.scala 69:25]
    inst aluOutputDemux_x6_demux of Demux_2 @[Demux.scala 46:23]
    aluOutputDemux_x6_demux.clock <= clock
    aluOutputDemux_x6_demux.reset <= reset
    aluOutputDemux_x6_demux.io.in.bits[0] <= alu.io.output.bits[0] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[1] <= alu.io.output.bits[1] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[2] <= alu.io.output.bits[2] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[3] <= alu.io.output.bits[3] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[4] <= alu.io.output.bits[4] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[5] <= alu.io.output.bits[5] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[6] <= alu.io.output.bits[6] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.bits[7] <= alu.io.output.bits[7] @[Demux.scala 54:17]
    aluOutputDemux_x6_demux.io.in.valid <= alu.io.output.valid @[Demux.scala 54:17]
    alu.io.output.ready <= aluOutputDemux_x6_demux.io.in.ready @[Demux.scala 54:17]
    aluOutputSink.io.in.bits[0] <= aluOutputDemux_x6_demux.io.out[0].bits[0] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[1] <= aluOutputDemux_x6_demux.io.out[0].bits[1] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[2] <= aluOutputDemux_x6_demux.io.out[0].bits[2] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[3] <= aluOutputDemux_x6_demux.io.out[0].bits[3] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[4] <= aluOutputDemux_x6_demux.io.out[0].bits[4] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[5] <= aluOutputDemux_x6_demux.io.out[0].bits[5] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[6] <= aluOutputDemux_x6_demux.io.out[0].bits[6] @[Demux.scala 55:10]
    aluOutputSink.io.in.bits[7] <= aluOutputDemux_x6_demux.io.out[0].bits[7] @[Demux.scala 55:10]
    aluOutputSink.io.in.valid <= aluOutputDemux_x6_demux.io.out[0].valid @[Demux.scala 55:10]
    aluOutputDemux_x6_demux.io.out[0].ready <= aluOutputSink.io.in.ready @[Demux.scala 55:10]
    aluOutputForAccInput.bits[0] <= aluOutputDemux_x6_demux.io.out[1].bits[0] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[1] <= aluOutputDemux_x6_demux.io.out[1].bits[1] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[2] <= aluOutputDemux_x6_demux.io.out[1].bits[2] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[3] <= aluOutputDemux_x6_demux.io.out[1].bits[3] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[4] <= aluOutputDemux_x6_demux.io.out[1].bits[4] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[5] <= aluOutputDemux_x6_demux.io.out[1].bits[5] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[6] <= aluOutputDemux_x6_demux.io.out[1].bits[6] @[Demux.scala 56:10]
    aluOutputForAccInput.bits[7] <= aluOutputDemux_x6_demux.io.out[1].bits[7] @[Demux.scala 56:10]
    aluOutputForAccInput.valid <= aluOutputDemux_x6_demux.io.out[1].valid @[Demux.scala 56:10]
    aluOutputDemux_x6_demux.io.out[1].ready <= aluOutputForAccInput.ready @[Demux.scala 56:10]
    inst aluOutputDemux of Queue_19 @[Mem.scala 23:19]
    aluOutputDemux.clock <= clock
    aluOutputDemux.reset <= reset
    aluOutputDemux_x6_demux.io.sel.bits <= aluOutputDemux.io.deq.bits @[Mem.scala 24:7]
    aluOutputDemux_x6_demux.io.sel.valid <= aluOutputDemux.io.deq.valid @[Mem.scala 24:7]
    aluOutputDemux.io.deq.ready <= aluOutputDemux_x6_demux.io.sel.ready @[Mem.scala 24:7]
    inst accInputMux_x15_mux of Mux @[Mux.scala 71:21]
    accInputMux_x15_mux.clock <= clock
    accInputMux_x15_mux.reset <= reset
    accInputMux_x15_mux.io.in[0].bits[0] <= io.input.bits[0] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[1] <= io.input.bits[1] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[2] <= io.input.bits[2] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[3] <= io.input.bits[3] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[4] <= io.input.bits[4] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[5] <= io.input.bits[5] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[6] <= io.input.bits[6] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].bits[7] <= io.input.bits[7] @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[0].valid <= io.input.valid @[Mux.scala 79:18]
    io.input.ready <= accInputMux_x15_mux.io.in[0].ready @[Mux.scala 79:18]
    accInputMux_x15_mux.io.in[1].bits[0] <= aluOutputForAccInput.bits[0] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[1] <= aluOutputForAccInput.bits[1] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[2] <= aluOutputForAccInput.bits[2] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[3] <= aluOutputForAccInput.bits[3] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[4] <= aluOutputForAccInput.bits[4] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[5] <= aluOutputForAccInput.bits[5] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[6] <= aluOutputForAccInput.bits[6] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].bits[7] <= aluOutputForAccInput.bits[7] @[Mux.scala 80:18]
    accInputMux_x15_mux.io.in[1].valid <= aluOutputForAccInput.valid @[Mux.scala 80:18]
    aluOutputForAccInput.ready <= accInputMux_x15_mux.io.in[1].ready @[Mux.scala 80:18]
    acc.io.input.bits[0] <= accInputMux_x15_mux.io.out.bits[0] @[Mux.scala 81:9]
    acc.io.input.bits[1] <= accInputMux_x15_mux.io.out.bits[1] @[Mux.scala 81:9]
    acc.io.input.bits[2] <= accInputMux_x15_mux.io.out.bits[2] @[Mux.scala 81:9]
    acc.io.input.bits[3] <= accInputMux_x15_mux.io.out.bits[3] @[Mux.scala 81:9]
    acc.io.input.bits[4] <= accInputMux_x15_mux.io.out.bits[4] @[Mux.scala 81:9]
    acc.io.input.bits[5] <= accInputMux_x15_mux.io.out.bits[5] @[Mux.scala 81:9]
    acc.io.input.bits[6] <= accInputMux_x15_mux.io.out.bits[6] @[Mux.scala 81:9]
    acc.io.input.bits[7] <= accInputMux_x15_mux.io.out.bits[7] @[Mux.scala 81:9]
    acc.io.input.valid <= accInputMux_x15_mux.io.out.valid @[Mux.scala 81:9]
    accInputMux_x15_mux.io.out.ready <= acc.io.input.ready @[Mux.scala 81:9]
    inst accInputMux of Queue_20 @[Mem.scala 23:19]
    accInputMux.clock <= clock
    accInputMux.reset <= reset
    accInputMux_x15_mux.io.sel.bits <= accInputMux.io.deq.bits @[Mem.scala 24:7]
    accInputMux_x15_mux.io.sel.valid <= accInputMux.io.deq.valid @[Mem.scala 24:7]
    accInputMux.io.deq.ready <= accInputMux_x15_mux.io.sel.ready @[Mem.scala 24:7]
    inst accOutputDemux_x24_demux of Demux_3 @[Demux.scala 46:23]
    accOutputDemux_x24_demux.clock <= clock
    accOutputDemux_x24_demux.reset <= reset
    accOutputDemux_x24_demux.io.in.bits[0] <= acc.io.output.bits[0] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[1] <= acc.io.output.bits[1] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[2] <= acc.io.output.bits[2] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[3] <= acc.io.output.bits[3] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[4] <= acc.io.output.bits[4] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[5] <= acc.io.output.bits[5] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[6] <= acc.io.output.bits[6] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.bits[7] <= acc.io.output.bits[7] @[Demux.scala 54:17]
    accOutputDemux_x24_demux.io.in.valid <= acc.io.output.valid @[Demux.scala 54:17]
    acc.io.output.ready <= accOutputDemux_x24_demux.io.in.ready @[Demux.scala 54:17]
    io.output.bits[0] <= accOutputDemux_x24_demux.io.out[0].bits[0] @[Demux.scala 55:10]
    io.output.bits[1] <= accOutputDemux_x24_demux.io.out[0].bits[1] @[Demux.scala 55:10]
    io.output.bits[2] <= accOutputDemux_x24_demux.io.out[0].bits[2] @[Demux.scala 55:10]
    io.output.bits[3] <= accOutputDemux_x24_demux.io.out[0].bits[3] @[Demux.scala 55:10]
    io.output.bits[4] <= accOutputDemux_x24_demux.io.out[0].bits[4] @[Demux.scala 55:10]
    io.output.bits[5] <= accOutputDemux_x24_demux.io.out[0].bits[5] @[Demux.scala 55:10]
    io.output.bits[6] <= accOutputDemux_x24_demux.io.out[0].bits[6] @[Demux.scala 55:10]
    io.output.bits[7] <= accOutputDemux_x24_demux.io.out[0].bits[7] @[Demux.scala 55:10]
    io.output.valid <= accOutputDemux_x24_demux.io.out[0].valid @[Demux.scala 55:10]
    accOutputDemux_x24_demux.io.out[0].ready <= io.output.ready @[Demux.scala 55:10]
    alu.io.input.bits[0] <= accOutputDemux_x24_demux.io.out[1].bits[0] @[Demux.scala 56:10]
    alu.io.input.bits[1] <= accOutputDemux_x24_demux.io.out[1].bits[1] @[Demux.scala 56:10]
    alu.io.input.bits[2] <= accOutputDemux_x24_demux.io.out[1].bits[2] @[Demux.scala 56:10]
    alu.io.input.bits[3] <= accOutputDemux_x24_demux.io.out[1].bits[3] @[Demux.scala 56:10]
    alu.io.input.bits[4] <= accOutputDemux_x24_demux.io.out[1].bits[4] @[Demux.scala 56:10]
    alu.io.input.bits[5] <= accOutputDemux_x24_demux.io.out[1].bits[5] @[Demux.scala 56:10]
    alu.io.input.bits[6] <= accOutputDemux_x24_demux.io.out[1].bits[6] @[Demux.scala 56:10]
    alu.io.input.bits[7] <= accOutputDemux_x24_demux.io.out[1].bits[7] @[Demux.scala 56:10]
    alu.io.input.valid <= accOutputDemux_x24_demux.io.out[1].valid @[Demux.scala 56:10]
    accOutputDemux_x24_demux.io.out[1].ready <= alu.io.input.ready @[Demux.scala 56:10]
    inst accOutputDemux of Queue_21 @[Mem.scala 23:19]
    accOutputDemux.clock <= clock
    accOutputDemux.reset <= reset
    accOutputDemux_x24_demux.io.sel.bits <= accOutputDemux.io.deq.bits @[Mem.scala 24:7]
    accOutputDemux_x24_demux.io.sel.valid <= accOutputDemux.io.deq.valid @[Mem.scala 24:7]
    accOutputDemux.io.deq.ready <= accOutputDemux_x24_demux.io.sel.ready @[Mem.scala 24:7]
    wire _aluOutputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 77:41]
    _aluOutputDemux_io_enq_bits_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    aluOutputDemux.io.enq.bits <= _aluOutputDemux_io_enq_bits_WIRE @[package.scala 409:14]
    aluOutputDemux.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _accInputMux_io_enq_bits_WIRE : UInt<1> @[package.scala 77:41]
    _accInputMux_io_enq_bits_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    accInputMux.io.enq.bits <= _accInputMux_io_enq_bits_WIRE @[package.scala 409:14]
    accInputMux.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _accOutputDemux_io_enq_bits_WIRE : UInt<1> @[package.scala 77:41]
    _accOutputDemux_io_enq_bits_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    accOutputDemux.io.enq.bits <= _accOutputDemux_io_enq_bits_WIRE @[package.scala 409:14]
    accOutputDemux.io.enq.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _acc_io_control_bits_WIRE : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[package.scala 80:57]
    _acc_io_control_bits_WIRE.write <= UInt<1>("h00") @[package.scala 80:57]
    _acc_io_control_bits_WIRE.accumulate <= UInt<1>("h00") @[package.scala 80:57]
    _acc_io_control_bits_WIRE.address <= UInt<6>("h00") @[package.scala 80:57]
    acc.io.control.bits.write <= _acc_io_control_bits_WIRE.write @[package.scala 409:14]
    acc.io.control.bits.accumulate <= _acc_io_control_bits_WIRE.accumulate @[package.scala 409:14]
    acc.io.control.bits.address <= _acc_io_control_bits_WIRE.address @[package.scala 409:14]
    acc.io.control.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _alu_io_instruction_bits_WIRE : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>} @[package.scala 80:57]
    _alu_io_instruction_bits_WIRE.dest <= UInt<1>("h00") @[package.scala 80:57]
    _alu_io_instruction_bits_WIRE.sourceRight <= UInt<1>("h00") @[package.scala 80:57]
    _alu_io_instruction_bits_WIRE.sourceLeft <= UInt<1>("h00") @[package.scala 80:57]
    _alu_io_instruction_bits_WIRE.op <= UInt<4>("h00") @[package.scala 80:57]
    alu.io.instruction.bits.dest <= _alu_io_instruction_bits_WIRE.dest @[package.scala 409:14]
    alu.io.instruction.bits.sourceRight <= _alu_io_instruction_bits_WIRE.sourceRight @[package.scala 409:14]
    alu.io.instruction.bits.sourceLeft <= _alu_io_instruction_bits_WIRE.sourceLeft @[package.scala 409:14]
    alu.io.instruction.bits.op <= _alu_io_instruction_bits_WIRE.op @[package.scala 409:14]
    alu.io.instruction.valid <= UInt<1>("h00") @[package.scala 410:15]
    reg readEnqueued : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AccumulatorWithALUArray.scala 110:29]
    readEnqueued <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 111:16]
    inst accWriteEnqueuer of MultiEnqueue_7 @[MultiEnqueue.scala 160:43]
    accWriteEnqueuer.clock <= clock
    accWriteEnqueuer.reset <= reset
    inst accReadEnqueuer of MultiEnqueue_8 @[MultiEnqueue.scala 160:43]
    accReadEnqueuer.clock <= clock
    accReadEnqueuer.reset <= reset
    inst simdRWWriteEnqueuer of MultiEnqueue_9 @[MultiEnqueue.scala 160:43]
    simdRWWriteEnqueuer.clock <= clock
    simdRWWriteEnqueuer.reset <= reset
    inst simdRWReadEnqueuer of MultiEnqueue_10 @[MultiEnqueue.scala 160:43]
    simdRWReadEnqueuer.clock <= clock
    simdRWReadEnqueuer.reset <= reset
    inst simdWriteEnqueuer of MultiEnqueue_11 @[MultiEnqueue.scala 160:43]
    simdWriteEnqueuer.clock <= clock
    simdWriteEnqueuer.reset <= reset
    inst simdReadEnqueuer of MultiEnqueue_12 @[MultiEnqueue.scala 160:43]
    simdReadEnqueuer.clock <= clock
    simdReadEnqueuer.reset <= reset
    inst simdEnqueuer of MultiEnqueue_13 @[MultiEnqueue.scala 160:43]
    simdEnqueuer.clock <= clock
    simdEnqueuer.reset <= reset
    accWriteEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    accWriteEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accWriteEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accReadEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    accReadEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    accReadEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    simdRWWriteEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWWriteEnqueuer.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    simdRWReadEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdRWReadEnqueuer.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    simdWriteEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdWriteEnqueuer.io.out[3].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    simdReadEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[2].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdReadEnqueuer.io.out[3].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdEnqueuer.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    simdEnqueuer.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    simdEnqueuer.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    node isNoOp = eq(io.control.bits.instruction.op, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 130:44]
    when isNoOp : @[AccumulatorWithALUArray.scala 133:16]
      wire dataPathReady : UInt<1>
      dataPathReady <= UInt<1>("h00")
      when io.control.bits.read : @[AccumulatorWithALUArray.scala 135:29]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 136:32]
          when readEnqueued : @[AccumulatorWithALUArray.scala 137:28]
            wire dataPathReady_w : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
            dataPathReady_w.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
            dataPathReady_w.write <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 263:13]
            dataPathReady_w.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
            accWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
            wire dataPathReady_acc_io_control_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            dataPathReady_acc_io_control_w.bits.write <= dataPathReady_w.write @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w.bits.accumulate <= dataPathReady_w.accumulate @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w.bits.address <= dataPathReady_w.address @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w.valid <= accWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            accWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w.ready @[ReadyValid.scala 19:11]
            acc.io.control.bits.write <= dataPathReady_acc_io_control_w.bits.write @[MultiEnqueue.scala 85:10]
            acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w.bits.accumulate @[MultiEnqueue.scala 85:10]
            acc.io.control.bits.address <= dataPathReady_acc_io_control_w.bits.address @[MultiEnqueue.scala 85:10]
            acc.io.control.valid <= dataPathReady_acc_io_control_w.valid @[MultiEnqueue.scala 85:10]
            dataPathReady_acc_io_control_w.ready <= acc.io.control.ready @[MultiEnqueue.scala 85:10]
            wire dataPathReady_accInputMux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_accInputMux_io_enq_w.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
            dataPathReady_accInputMux_io_enq_w.valid <= accWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            accWriteEnqueuer.io.out[1].ready <= dataPathReady_accInputMux_io_enq_w.ready @[ReadyValid.scala 19:11]
            accInputMux.io.enq.bits <= dataPathReady_accInputMux_io_enq_w.bits @[MultiEnqueue.scala 86:10]
            accInputMux.io.enq.valid <= dataPathReady_accInputMux_io_enq_w.valid @[MultiEnqueue.scala 86:10]
            dataPathReady_accInputMux_io_enq_w.ready <= accInputMux.io.enq.ready @[MultiEnqueue.scala 86:10]
            dataPathReady <= accWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 138:25]
            when dataPathReady : @[AccumulatorWithALUArray.scala 145:31]
              readEnqueued <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 146:26]
              skip @[AccumulatorWithALUArray.scala 145:31]
            else : @[AccumulatorWithALUArray.scala 147:23]
              readEnqueued <= readEnqueued @[AccumulatorWithALUArray.scala 148:26]
              skip @[AccumulatorWithALUArray.scala 147:23]
            skip @[AccumulatorWithALUArray.scala 137:28]
          else : @[AccumulatorWithALUArray.scala 150:21]
            dataPathReady <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 151:25]
            wire readEnqueued_w : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
            readEnqueued_w.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
            readEnqueued_w.write <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 271:13]
            readEnqueued_w.accumulate <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 272:18]
            accReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
            wire readEnqueued_acc_io_control_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            readEnqueued_acc_io_control_w.bits.write <= readEnqueued_w.write @[ReadyValid.scala 17:12]
            readEnqueued_acc_io_control_w.bits.accumulate <= readEnqueued_w.accumulate @[ReadyValid.scala 17:12]
            readEnqueued_acc_io_control_w.bits.address <= readEnqueued_w.address @[ReadyValid.scala 17:12]
            readEnqueued_acc_io_control_w.valid <= accReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            accReadEnqueuer.io.out[0].ready <= readEnqueued_acc_io_control_w.ready @[ReadyValid.scala 19:11]
            acc.io.control.bits.write <= readEnqueued_acc_io_control_w.bits.write @[MultiEnqueue.scala 85:10]
            acc.io.control.bits.accumulate <= readEnqueued_acc_io_control_w.bits.accumulate @[MultiEnqueue.scala 85:10]
            acc.io.control.bits.address <= readEnqueued_acc_io_control_w.bits.address @[MultiEnqueue.scala 85:10]
            acc.io.control.valid <= readEnqueued_acc_io_control_w.valid @[MultiEnqueue.scala 85:10]
            readEnqueued_acc_io_control_w.ready <= acc.io.control.ready @[MultiEnqueue.scala 85:10]
            wire readEnqueued_accOutputDemux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            readEnqueued_accOutputDemux_io_enq_w.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
            readEnqueued_accOutputDemux_io_enq_w.valid <= accReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            accReadEnqueuer.io.out[1].ready <= readEnqueued_accOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
            accOutputDemux.io.enq.bits <= readEnqueued_accOutputDemux_io_enq_w.bits @[MultiEnqueue.scala 86:10]
            accOutputDemux.io.enq.valid <= readEnqueued_accOutputDemux_io_enq_w.valid @[MultiEnqueue.scala 86:10]
            readEnqueued_accOutputDemux_io_enq_w.ready <= accOutputDemux.io.enq.ready @[MultiEnqueue.scala 86:10]
            readEnqueued <= accReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 152:24]
            skip @[AccumulatorWithALUArray.scala 150:21]
          skip @[AccumulatorWithALUArray.scala 136:32]
        else : @[AccumulatorWithALUArray.scala 160:19]
          wire dataPathReady_w_1 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
          dataPathReady_w_1.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
          dataPathReady_w_1.write <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 271:13]
          dataPathReady_w_1.accumulate <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 272:18]
          accReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_acc_io_control_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_1.bits.write <= dataPathReady_w_1.write @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_1.bits.accumulate <= dataPathReady_w_1.accumulate @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_1.bits.address <= dataPathReady_w_1.address @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_1.valid <= accReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          accReadEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_1.ready @[ReadyValid.scala 19:11]
          acc.io.control.bits.write <= dataPathReady_acc_io_control_w_1.bits.write @[MultiEnqueue.scala 85:10]
          acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w_1.bits.accumulate @[MultiEnqueue.scala 85:10]
          acc.io.control.bits.address <= dataPathReady_acc_io_control_w_1.bits.address @[MultiEnqueue.scala 85:10]
          acc.io.control.valid <= dataPathReady_acc_io_control_w_1.valid @[MultiEnqueue.scala 85:10]
          dataPathReady_acc_io_control_w_1.ready <= acc.io.control.ready @[MultiEnqueue.scala 85:10]
          wire dataPathReady_accOutputDemux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accOutputDemux_io_enq_w.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          dataPathReady_accOutputDemux_io_enq_w.valid <= accReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          accReadEnqueuer.io.out[1].ready <= dataPathReady_accOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
          accOutputDemux.io.enq.bits <= dataPathReady_accOutputDemux_io_enq_w.bits @[MultiEnqueue.scala 86:10]
          accOutputDemux.io.enq.valid <= dataPathReady_accOutputDemux_io_enq_w.valid @[MultiEnqueue.scala 86:10]
          dataPathReady_accOutputDemux_io_enq_w.ready <= accOutputDemux.io.enq.ready @[MultiEnqueue.scala 86:10]
          dataPathReady <= accReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 161:23]
          skip @[AccumulatorWithALUArray.scala 160:19]
        skip @[AccumulatorWithALUArray.scala 135:29]
      else : @[AccumulatorWithALUArray.scala 169:17]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 170:32]
          wire dataPathReady_w_2 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
          dataPathReady_w_2.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
          dataPathReady_w_2.write <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 263:13]
          dataPathReady_w_2.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
          accWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_acc_io_control_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_2.bits.write <= dataPathReady_w_2.write @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_2.bits.accumulate <= dataPathReady_w_2.accumulate @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_2.bits.address <= dataPathReady_w_2.address @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_2.valid <= accWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          accWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_2.ready @[ReadyValid.scala 19:11]
          acc.io.control.bits.write <= dataPathReady_acc_io_control_w_2.bits.write @[MultiEnqueue.scala 85:10]
          acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w_2.bits.accumulate @[MultiEnqueue.scala 85:10]
          acc.io.control.bits.address <= dataPathReady_acc_io_control_w_2.bits.address @[MultiEnqueue.scala 85:10]
          acc.io.control.valid <= dataPathReady_acc_io_control_w_2.valid @[MultiEnqueue.scala 85:10]
          dataPathReady_acc_io_control_w_2.ready <= acc.io.control.ready @[MultiEnqueue.scala 85:10]
          wire dataPathReady_accInputMux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accInputMux_io_enq_w_1.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          dataPathReady_accInputMux_io_enq_w_1.valid <= accWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          accWriteEnqueuer.io.out[1].ready <= dataPathReady_accInputMux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          accInputMux.io.enq.bits <= dataPathReady_accInputMux_io_enq_w_1.bits @[MultiEnqueue.scala 86:10]
          accInputMux.io.enq.valid <= dataPathReady_accInputMux_io_enq_w_1.valid @[MultiEnqueue.scala 86:10]
          dataPathReady_accInputMux_io_enq_w_1.ready <= accInputMux.io.enq.ready @[MultiEnqueue.scala 86:10]
          dataPathReady <= accWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 171:23]
          skip @[AccumulatorWithALUArray.scala 170:32]
        else : @[AccumulatorWithALUArray.scala 178:19]
          dataPathReady <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 179:23]
          skip @[AccumulatorWithALUArray.scala 178:19]
        skip @[AccumulatorWithALUArray.scala 169:17]
      io.control.ready <= dataPathReady @[AccumulatorWithALUArray.scala 182:19]
      skip @[AccumulatorWithALUArray.scala 133:16]
    else : @[AccumulatorWithALUArray.scala 183:15]
      wire dataPathReady_1 : UInt<1>
      dataPathReady_1 <= UInt<1>("h00")
      when io.control.bits.read : @[AccumulatorWithALUArray.scala 185:29]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 186:32]
          when readEnqueued : @[AccumulatorWithALUArray.scala 188:28]
            wire dataPathReady_w_3 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
            dataPathReady_w_3.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
            dataPathReady_w_3.write <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 263:13]
            dataPathReady_w_3.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
            simdRWWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 114:17]
            wire dataPathReady_acc_io_control_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
            dataPathReady_acc_io_control_w_3.bits.write <= dataPathReady_w_3.write @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w_3.bits.accumulate <= dataPathReady_w_3.accumulate @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w_3.bits.address <= dataPathReady_w_3.address @[ReadyValid.scala 17:12]
            dataPathReady_acc_io_control_w_3.valid <= simdRWWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_3.ready @[ReadyValid.scala 19:11]
            acc.io.control.bits.write <= dataPathReady_acc_io_control_w_3.bits.write @[MultiEnqueue.scala 115:10]
            acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w_3.bits.accumulate @[MultiEnqueue.scala 115:10]
            acc.io.control.bits.address <= dataPathReady_acc_io_control_w_3.bits.address @[MultiEnqueue.scala 115:10]
            acc.io.control.valid <= dataPathReady_acc_io_control_w_3.valid @[MultiEnqueue.scala 115:10]
            dataPathReady_acc_io_control_w_3.ready <= acc.io.control.ready @[MultiEnqueue.scala 115:10]
            wire dataPathReady_aluOutputDemux_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_aluOutputDemux_io_enq_w.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
            dataPathReady_aluOutputDemux_io_enq_w.valid <= simdRWWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[1].ready <= dataPathReady_aluOutputDemux_io_enq_w.ready @[ReadyValid.scala 19:11]
            aluOutputDemux.io.enq.bits <= dataPathReady_aluOutputDemux_io_enq_w.bits @[MultiEnqueue.scala 116:10]
            aluOutputDemux.io.enq.valid <= dataPathReady_aluOutputDemux_io_enq_w.valid @[MultiEnqueue.scala 116:10]
            dataPathReady_aluOutputDemux_io_enq_w.ready <= aluOutputDemux.io.enq.ready @[MultiEnqueue.scala 116:10]
            wire dataPathReady_accInputMux_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
            dataPathReady_accInputMux_io_enq_w_2.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
            dataPathReady_accInputMux_io_enq_w_2.valid <= simdRWWriteEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
            simdRWWriteEnqueuer.io.out[2].ready <= dataPathReady_accInputMux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
            accInputMux.io.enq.bits <= dataPathReady_accInputMux_io_enq_w_2.bits @[MultiEnqueue.scala 117:10]
            accInputMux.io.enq.valid <= dataPathReady_accInputMux_io_enq_w_2.valid @[MultiEnqueue.scala 117:10]
            dataPathReady_accInputMux_io_enq_w_2.ready <= accInputMux.io.enq.ready @[MultiEnqueue.scala 117:10]
            dataPathReady_1 <= simdRWWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 189:25]
            when dataPathReady_1 : @[AccumulatorWithALUArray.scala 198:31]
              readEnqueued <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 199:26]
              skip @[AccumulatorWithALUArray.scala 198:31]
            else : @[AccumulatorWithALUArray.scala 200:23]
              readEnqueued <= readEnqueued @[AccumulatorWithALUArray.scala 201:26]
              skip @[AccumulatorWithALUArray.scala 200:23]
            skip @[AccumulatorWithALUArray.scala 188:28]
          else : @[AccumulatorWithALUArray.scala 203:21]
            dataPathReady_1 <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 204:25]
            node _T = eq(io.control.bits.instruction.sourceLeft, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 206:49]
            node _T_1 = eq(io.control.bits.instruction.sourceRight, UInt<1>("h00")) @[AccumulatorWithALUArray.scala 206:97]
            node _T_2 = or(_T, _T_1) @[AccumulatorWithALUArray.scala 206:57]
            when _T_2 : @[AccumulatorWithALUArray.scala 207:13]
              wire readEnqueued_w_1 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
              readEnqueued_w_1.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
              readEnqueued_w_1.write <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 271:13]
              readEnqueued_w_1.accumulate <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 272:18]
              simdRWReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 114:17]
              wire readEnqueued_acc_io_control_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
              readEnqueued_acc_io_control_w_1.bits.write <= readEnqueued_w_1.write @[ReadyValid.scala 17:12]
              readEnqueued_acc_io_control_w_1.bits.accumulate <= readEnqueued_w_1.accumulate @[ReadyValid.scala 17:12]
              readEnqueued_acc_io_control_w_1.bits.address <= readEnqueued_w_1.address @[ReadyValid.scala 17:12]
              readEnqueued_acc_io_control_w_1.valid <= simdRWReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[0].ready <= readEnqueued_acc_io_control_w_1.ready @[ReadyValid.scala 19:11]
              acc.io.control.bits.write <= readEnqueued_acc_io_control_w_1.bits.write @[MultiEnqueue.scala 115:10]
              acc.io.control.bits.accumulate <= readEnqueued_acc_io_control_w_1.bits.accumulate @[MultiEnqueue.scala 115:10]
              acc.io.control.bits.address <= readEnqueued_acc_io_control_w_1.bits.address @[MultiEnqueue.scala 115:10]
              acc.io.control.valid <= readEnqueued_acc_io_control_w_1.valid @[MultiEnqueue.scala 115:10]
              readEnqueued_acc_io_control_w_1.ready <= acc.io.control.ready @[MultiEnqueue.scala 115:10]
              wire readEnqueued_accOutputDemux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
              readEnqueued_accOutputDemux_io_enq_w_1.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
              readEnqueued_accOutputDemux_io_enq_w_1.valid <= simdRWReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[1].ready <= readEnqueued_accOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
              accOutputDemux.io.enq.bits <= readEnqueued_accOutputDemux_io_enq_w_1.bits @[MultiEnqueue.scala 116:10]
              accOutputDemux.io.enq.valid <= readEnqueued_accOutputDemux_io_enq_w_1.valid @[MultiEnqueue.scala 116:10]
              readEnqueued_accOutputDemux_io_enq_w_1.ready <= accOutputDemux.io.enq.ready @[MultiEnqueue.scala 116:10]
              wire readEnqueued_alu_io_instruction_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
              readEnqueued_alu_io_instruction_w.bits.dest <= io.control.bits.instruction.dest @[ReadyValid.scala 17:12]
              readEnqueued_alu_io_instruction_w.bits.sourceRight <= io.control.bits.instruction.sourceRight @[ReadyValid.scala 17:12]
              readEnqueued_alu_io_instruction_w.bits.sourceLeft <= io.control.bits.instruction.sourceLeft @[ReadyValid.scala 17:12]
              readEnqueued_alu_io_instruction_w.bits.op <= io.control.bits.instruction.op @[ReadyValid.scala 17:12]
              readEnqueued_alu_io_instruction_w.valid <= simdRWReadEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
              simdRWReadEnqueuer.io.out[2].ready <= readEnqueued_alu_io_instruction_w.ready @[ReadyValid.scala 19:11]
              alu.io.instruction.bits.dest <= readEnqueued_alu_io_instruction_w.bits.dest @[MultiEnqueue.scala 117:10]
              alu.io.instruction.bits.sourceRight <= readEnqueued_alu_io_instruction_w.bits.sourceRight @[MultiEnqueue.scala 117:10]
              alu.io.instruction.bits.sourceLeft <= readEnqueued_alu_io_instruction_w.bits.sourceLeft @[MultiEnqueue.scala 117:10]
              alu.io.instruction.bits.op <= readEnqueued_alu_io_instruction_w.bits.op @[MultiEnqueue.scala 117:10]
              alu.io.instruction.valid <= readEnqueued_alu_io_instruction_w.valid @[MultiEnqueue.scala 117:10]
              readEnqueued_alu_io_instruction_w.ready <= alu.io.instruction.ready @[MultiEnqueue.scala 117:10]
              readEnqueued <= simdRWReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 208:26]
              skip @[AccumulatorWithALUArray.scala 207:13]
            else : @[AccumulatorWithALUArray.scala 217:23]
              readEnqueued <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 218:26]
              skip @[AccumulatorWithALUArray.scala 217:23]
            skip @[AccumulatorWithALUArray.scala 203:21]
          skip @[AccumulatorWithALUArray.scala 186:32]
        else : @[AccumulatorWithALUArray.scala 221:19]
          wire dataPathReady_w_4 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 269:17]
          dataPathReady_w_4.address <= io.control.bits.readAddress @[AccumulatorWithALUArray.scala 270:15]
          dataPathReady_w_4.write <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 271:13]
          dataPathReady_w_4.accumulate <= UInt<1>("h00") @[AccumulatorWithALUArray.scala 272:18]
          simdReadEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
          wire dataPathReady_acc_io_control_w_4 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_4.bits.write <= dataPathReady_w_4.write @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_4.bits.accumulate <= dataPathReady_w_4.accumulate @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_4.bits.address <= dataPathReady_w_4.address @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_4.valid <= simdReadEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_4.ready @[ReadyValid.scala 19:11]
          acc.io.control.bits.write <= dataPathReady_acc_io_control_w_4.bits.write @[MultiEnqueue.scala 151:10]
          acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w_4.bits.accumulate @[MultiEnqueue.scala 151:10]
          acc.io.control.bits.address <= dataPathReady_acc_io_control_w_4.bits.address @[MultiEnqueue.scala 151:10]
          acc.io.control.valid <= dataPathReady_acc_io_control_w_4.valid @[MultiEnqueue.scala 151:10]
          dataPathReady_acc_io_control_w_4.ready <= acc.io.control.ready @[MultiEnqueue.scala 151:10]
          wire dataPathReady_accOutputDemux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accOutputDemux_io_enq_w_1.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
          dataPathReady_accOutputDemux_io_enq_w_1.valid <= simdReadEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[1].ready <= dataPathReady_accOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          accOutputDemux.io.enq.bits <= dataPathReady_accOutputDemux_io_enq_w_1.bits @[MultiEnqueue.scala 152:10]
          accOutputDemux.io.enq.valid <= dataPathReady_accOutputDemux_io_enq_w_1.valid @[MultiEnqueue.scala 152:10]
          dataPathReady_accOutputDemux_io_enq_w_1.ready <= accOutputDemux.io.enq.ready @[MultiEnqueue.scala 152:10]
          wire dataPathReady_aluOutputDemux_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_1.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_1.valid <= simdReadEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[2].ready <= dataPathReady_aluOutputDemux_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq.bits <= dataPathReady_aluOutputDemux_io_enq_w_1.bits @[MultiEnqueue.scala 153:10]
          aluOutputDemux.io.enq.valid <= dataPathReady_aluOutputDemux_io_enq_w_1.valid @[MultiEnqueue.scala 153:10]
          dataPathReady_aluOutputDemux_io_enq_w_1.ready <= aluOutputDemux.io.enq.ready @[MultiEnqueue.scala 153:10]
          wire dataPathReady_alu_io_instruction_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w.bits.dest <= io.control.bits.instruction.dest @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w.bits.sourceRight <= io.control.bits.instruction.sourceRight @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w.bits.sourceLeft <= io.control.bits.instruction.sourceLeft @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w.bits.op <= io.control.bits.instruction.op @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w.valid <= simdReadEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
          simdReadEnqueuer.io.out[3].ready <= dataPathReady_alu_io_instruction_w.ready @[ReadyValid.scala 19:11]
          alu.io.instruction.bits.dest <= dataPathReady_alu_io_instruction_w.bits.dest @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.sourceRight <= dataPathReady_alu_io_instruction_w.bits.sourceRight @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.sourceLeft <= dataPathReady_alu_io_instruction_w.bits.sourceLeft @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.op <= dataPathReady_alu_io_instruction_w.bits.op @[MultiEnqueue.scala 154:10]
          alu.io.instruction.valid <= dataPathReady_alu_io_instruction_w.valid @[MultiEnqueue.scala 154:10]
          dataPathReady_alu_io_instruction_w.ready <= alu.io.instruction.ready @[MultiEnqueue.scala 154:10]
          dataPathReady_1 <= simdReadEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 222:23]
          skip @[AccumulatorWithALUArray.scala 221:19]
        skip @[AccumulatorWithALUArray.scala 185:29]
      else : @[AccumulatorWithALUArray.scala 234:17]
        when io.control.bits.write : @[AccumulatorWithALUArray.scala 235:32]
          wire dataPathReady_w_5 : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>} @[AccumulatorWithALUArray.scala 261:17]
          dataPathReady_w_5.address <= io.control.bits.writeAddress @[AccumulatorWithALUArray.scala 262:15]
          dataPathReady_w_5.write <= UInt<1>("h01") @[AccumulatorWithALUArray.scala 263:13]
          dataPathReady_w_5.accumulate <= io.control.bits.accumulate @[AccumulatorWithALUArray.scala 264:18]
          simdWriteEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 150:17]
          wire dataPathReady_acc_io_control_w_5 : {flip ready : UInt<1>, valid : UInt<1>, bits : {address : UInt<6>, accumulate : UInt<1>, write : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_acc_io_control_w_5.bits.write <= dataPathReady_w_5.write @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_5.bits.accumulate <= dataPathReady_w_5.accumulate @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_5.bits.address <= dataPathReady_w_5.address @[ReadyValid.scala 17:12]
          dataPathReady_acc_io_control_w_5.valid <= simdWriteEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[0].ready <= dataPathReady_acc_io_control_w_5.ready @[ReadyValid.scala 19:11]
          acc.io.control.bits.write <= dataPathReady_acc_io_control_w_5.bits.write @[MultiEnqueue.scala 151:10]
          acc.io.control.bits.accumulate <= dataPathReady_acc_io_control_w_5.bits.accumulate @[MultiEnqueue.scala 151:10]
          acc.io.control.bits.address <= dataPathReady_acc_io_control_w_5.bits.address @[MultiEnqueue.scala 151:10]
          acc.io.control.valid <= dataPathReady_acc_io_control_w_5.valid @[MultiEnqueue.scala 151:10]
          dataPathReady_acc_io_control_w_5.ready <= acc.io.control.ready @[MultiEnqueue.scala 151:10]
          wire dataPathReady_aluOutputDemux_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_2.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_2.valid <= simdWriteEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[1].ready <= dataPathReady_aluOutputDemux_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq.bits <= dataPathReady_aluOutputDemux_io_enq_w_2.bits @[MultiEnqueue.scala 152:10]
          aluOutputDemux.io.enq.valid <= dataPathReady_aluOutputDemux_io_enq_w_2.valid @[MultiEnqueue.scala 152:10]
          dataPathReady_aluOutputDemux_io_enq_w_2.ready <= aluOutputDemux.io.enq.ready @[MultiEnqueue.scala 152:10]
          wire dataPathReady_accInputMux_io_enq_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_accInputMux_io_enq_w_3.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
          dataPathReady_accInputMux_io_enq_w_3.valid <= simdWriteEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[2].ready <= dataPathReady_accInputMux_io_enq_w_3.ready @[ReadyValid.scala 19:11]
          accInputMux.io.enq.bits <= dataPathReady_accInputMux_io_enq_w_3.bits @[MultiEnqueue.scala 153:10]
          accInputMux.io.enq.valid <= dataPathReady_accInputMux_io_enq_w_3.valid @[MultiEnqueue.scala 153:10]
          dataPathReady_accInputMux_io_enq_w_3.ready <= accInputMux.io.enq.ready @[MultiEnqueue.scala 153:10]
          wire dataPathReady_alu_io_instruction_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w_1.bits.dest <= io.control.bits.instruction.dest @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_1.bits.sourceRight <= io.control.bits.instruction.sourceRight @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_1.bits.sourceLeft <= io.control.bits.instruction.sourceLeft @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_1.bits.op <= io.control.bits.instruction.op @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_1.valid <= simdWriteEnqueuer.io.out[3].valid @[ReadyValid.scala 18:13]
          simdWriteEnqueuer.io.out[3].ready <= dataPathReady_alu_io_instruction_w_1.ready @[ReadyValid.scala 19:11]
          alu.io.instruction.bits.dest <= dataPathReady_alu_io_instruction_w_1.bits.dest @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.sourceRight <= dataPathReady_alu_io_instruction_w_1.bits.sourceRight @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.sourceLeft <= dataPathReady_alu_io_instruction_w_1.bits.sourceLeft @[MultiEnqueue.scala 154:10]
          alu.io.instruction.bits.op <= dataPathReady_alu_io_instruction_w_1.bits.op @[MultiEnqueue.scala 154:10]
          alu.io.instruction.valid <= dataPathReady_alu_io_instruction_w_1.valid @[MultiEnqueue.scala 154:10]
          dataPathReady_alu_io_instruction_w_1.ready <= alu.io.instruction.ready @[MultiEnqueue.scala 154:10]
          dataPathReady_1 <= simdWriteEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 236:23]
          skip @[AccumulatorWithALUArray.scala 235:32]
        else : @[AccumulatorWithALUArray.scala 247:19]
          simdEnqueuer.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
          wire dataPathReady_aluOutputDemux_io_enq_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          dataPathReady_aluOutputDemux_io_enq_w_3.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          dataPathReady_aluOutputDemux_io_enq_w_3.valid <= simdEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          simdEnqueuer.io.out[0].ready <= dataPathReady_aluOutputDemux_io_enq_w_3.ready @[ReadyValid.scala 19:11]
          aluOutputDemux.io.enq.bits <= dataPathReady_aluOutputDemux_io_enq_w_3.bits @[MultiEnqueue.scala 85:10]
          aluOutputDemux.io.enq.valid <= dataPathReady_aluOutputDemux_io_enq_w_3.valid @[MultiEnqueue.scala 85:10]
          dataPathReady_aluOutputDemux_io_enq_w_3.ready <= aluOutputDemux.io.enq.ready @[MultiEnqueue.scala 85:10]
          wire dataPathReady_alu_io_instruction_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}} @[ReadyValid.scala 16:17]
          dataPathReady_alu_io_instruction_w_2.bits.dest <= io.control.bits.instruction.dest @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_2.bits.sourceRight <= io.control.bits.instruction.sourceRight @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_2.bits.sourceLeft <= io.control.bits.instruction.sourceLeft @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_2.bits.op <= io.control.bits.instruction.op @[ReadyValid.scala 17:12]
          dataPathReady_alu_io_instruction_w_2.valid <= simdEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          simdEnqueuer.io.out[1].ready <= dataPathReady_alu_io_instruction_w_2.ready @[ReadyValid.scala 19:11]
          alu.io.instruction.bits.dest <= dataPathReady_alu_io_instruction_w_2.bits.dest @[MultiEnqueue.scala 86:10]
          alu.io.instruction.bits.sourceRight <= dataPathReady_alu_io_instruction_w_2.bits.sourceRight @[MultiEnqueue.scala 86:10]
          alu.io.instruction.bits.sourceLeft <= dataPathReady_alu_io_instruction_w_2.bits.sourceLeft @[MultiEnqueue.scala 86:10]
          alu.io.instruction.bits.op <= dataPathReady_alu_io_instruction_w_2.bits.op @[MultiEnqueue.scala 86:10]
          alu.io.instruction.valid <= dataPathReady_alu_io_instruction_w_2.valid @[MultiEnqueue.scala 86:10]
          dataPathReady_alu_io_instruction_w_2.ready <= alu.io.instruction.ready @[MultiEnqueue.scala 86:10]
          dataPathReady_1 <= simdEnqueuer.io.in.ready @[AccumulatorWithALUArray.scala 248:23]
          skip @[AccumulatorWithALUArray.scala 247:19]
        skip @[AccumulatorWithALUArray.scala 234:17]
      io.control.ready <= dataPathReady_1 @[AccumulatorWithALUArray.scala 257:19]
      skip @[AccumulatorWithALUArray.scala 183:15]
    
  extmodule bram_dp_128x64_1 : 
    input clka : UInt<1>
    input wea : UInt<1>
    input ena : UInt<1>
    input addra : UInt<6>
    input dia : UInt<128>
    output doa : UInt<128>
    input clkb : UInt<1>
    input web : UInt<1>
    input enb : UInt<1>
    input addrb : UInt<6>
    input dib : UInt<128>
    output dob : UInt<128>
    
    defname = bram_dp_128x64
    
    
  module InnerDualPortMem_1 : 
    input clock : Clock
    input reset : Reset
    output io : {portA : {flip address : UInt<6>, read : {flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : {flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}, portB : {flip address : UInt<6>, read : {flip enable : UInt<1>, data : Fixed<16><<8>>[8]}, write : {flip enable : UInt<1>, flip data : Fixed<16><<8>>[8]}}}
    
    inst mem of bram_dp_128x64_1 @[DualPortMem.scala 164:25]
    mem.dob is invalid
    mem.dib is invalid
    mem.addrb is invalid
    mem.enb is invalid
    mem.web is invalid
    mem.clkb is invalid
    mem.doa is invalid
    mem.dia is invalid
    mem.addra is invalid
    mem.ena is invalid
    mem.wea is invalid
    mem.clka is invalid
    node _mem_io_clka_T = asUInt(clock) @[DualPortMem.scala 166:30]
    node _mem_io_clka_T_1 = bits(_mem_io_clka_T, 0, 0) @[DualPortMem.scala 166:30]
    mem.clka <= _mem_io_clka_T_1 @[DualPortMem.scala 166:21]
    node _mem_io_ena_T = asUInt(reset) @[DualPortMem.scala 167:30]
    node _mem_io_ena_T_1 = eq(_mem_io_ena_T, UInt<1>("h00")) @[DualPortMem.scala 167:23]
    mem.ena <= _mem_io_ena_T_1 @[DualPortMem.scala 167:20]
    mem.addra <= io.portA.address @[DualPortMem.scala 168:22]
    wire _io_portA_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 169:50]
    wire _io_portA_read_data_WIRE_1 : UInt<128>
    _io_portA_read_data_WIRE_1 <= mem.doa
    node _io_portA_read_data_T = bits(_io_portA_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_1 = asFixedPoint(_io_portA_read_data_T, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[0] <= _io_portA_read_data_T_1 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_2 = bits(_io_portA_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_3 = asFixedPoint(_io_portA_read_data_T_2, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[1] <= _io_portA_read_data_T_3 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_4 = bits(_io_portA_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_5 = asFixedPoint(_io_portA_read_data_T_4, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[2] <= _io_portA_read_data_T_5 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_6 = bits(_io_portA_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_7 = asFixedPoint(_io_portA_read_data_T_6, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[3] <= _io_portA_read_data_T_7 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_8 = bits(_io_portA_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_9 = asFixedPoint(_io_portA_read_data_T_8, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[4] <= _io_portA_read_data_T_9 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_10 = bits(_io_portA_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_11 = asFixedPoint(_io_portA_read_data_T_10, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[5] <= _io_portA_read_data_T_11 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_12 = bits(_io_portA_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_13 = asFixedPoint(_io_portA_read_data_T_12, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[6] <= _io_portA_read_data_T_13 @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_14 = bits(_io_portA_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 169:50]
    node _io_portA_read_data_T_15 = asFixedPoint(_io_portA_read_data_T_14, 8) @[DualPortMem.scala 169:50]
    _io_portA_read_data_WIRE[7] <= _io_portA_read_data_T_15 @[DualPortMem.scala 169:50]
    io.portA.read.data[0] <= _io_portA_read_data_WIRE[0] @[DualPortMem.scala 169:28]
    io.portA.read.data[1] <= _io_portA_read_data_WIRE[1] @[DualPortMem.scala 169:28]
    io.portA.read.data[2] <= _io_portA_read_data_WIRE[2] @[DualPortMem.scala 169:28]
    io.portA.read.data[3] <= _io_portA_read_data_WIRE[3] @[DualPortMem.scala 169:28]
    io.portA.read.data[4] <= _io_portA_read_data_WIRE[4] @[DualPortMem.scala 169:28]
    io.portA.read.data[5] <= _io_portA_read_data_WIRE[5] @[DualPortMem.scala 169:28]
    io.portA.read.data[6] <= _io_portA_read_data_WIRE[6] @[DualPortMem.scala 169:28]
    io.portA.read.data[7] <= _io_portA_read_data_WIRE[7] @[DualPortMem.scala 169:28]
    mem.wea <= io.portA.write.enable @[DualPortMem.scala 170:20]
    wire _mem_io_dia_WIRE : UInt<128> @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo_lo = asUInt(io.portA.write.data[0]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo_hi = asUInt(io.portA.write.data[1]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi_lo = asUInt(io.portA.write.data[2]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi_hi = asUInt(io.portA.write.data[3]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo_lo = asUInt(io.portA.write.data[4]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo_hi = asUInt(io.portA.write.data[5]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi_lo = asUInt(io.portA.write.data[6]) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi_hi = asUInt(io.portA.write.data[7]) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_lo = cat(mem_io_dia_lo_lo_hi, mem_io_dia_lo_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo_hi = cat(mem_io_dia_lo_hi_hi, mem_io_dia_lo_hi_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_lo = cat(mem_io_dia_lo_hi, mem_io_dia_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_lo = cat(mem_io_dia_hi_lo_hi, mem_io_dia_hi_lo_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi_hi = cat(mem_io_dia_hi_hi_hi, mem_io_dia_hi_hi_lo) @[DualPortMem.scala 171:51]
    node mem_io_dia_hi = cat(mem_io_dia_hi_hi, mem_io_dia_hi_lo) @[DualPortMem.scala 171:51]
    node _mem_io_dia_T = cat(mem_io_dia_hi, mem_io_dia_lo) @[DualPortMem.scala 171:51]
    _mem_io_dia_WIRE <= _mem_io_dia_T @[DualPortMem.scala 171:51]
    mem.dia <= _mem_io_dia_WIRE @[DualPortMem.scala 171:20]
    node _mem_io_clkb_T = asUInt(clock) @[DualPortMem.scala 173:30]
    node _mem_io_clkb_T_1 = bits(_mem_io_clkb_T, 0, 0) @[DualPortMem.scala 173:30]
    mem.clkb <= _mem_io_clkb_T_1 @[DualPortMem.scala 173:21]
    node _mem_io_enb_T = asUInt(reset) @[DualPortMem.scala 174:30]
    node _mem_io_enb_T_1 = eq(_mem_io_enb_T, UInt<1>("h00")) @[DualPortMem.scala 174:23]
    mem.enb <= _mem_io_enb_T_1 @[DualPortMem.scala 174:20]
    mem.addrb <= io.portB.address @[DualPortMem.scala 175:22]
    wire _io_portB_read_data_WIRE : Fixed<16><<8>>[8] @[DualPortMem.scala 176:50]
    wire _io_portB_read_data_WIRE_1 : UInt<128>
    _io_portB_read_data_WIRE_1 <= mem.dob
    node _io_portB_read_data_T = bits(_io_portB_read_data_WIRE_1, 15, 0) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_1 = asFixedPoint(_io_portB_read_data_T, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[0] <= _io_portB_read_data_T_1 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_2 = bits(_io_portB_read_data_WIRE_1, 31, 16) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_3 = asFixedPoint(_io_portB_read_data_T_2, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[1] <= _io_portB_read_data_T_3 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_4 = bits(_io_portB_read_data_WIRE_1, 47, 32) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_5 = asFixedPoint(_io_portB_read_data_T_4, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[2] <= _io_portB_read_data_T_5 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_6 = bits(_io_portB_read_data_WIRE_1, 63, 48) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_7 = asFixedPoint(_io_portB_read_data_T_6, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[3] <= _io_portB_read_data_T_7 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_8 = bits(_io_portB_read_data_WIRE_1, 79, 64) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_9 = asFixedPoint(_io_portB_read_data_T_8, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[4] <= _io_portB_read_data_T_9 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_10 = bits(_io_portB_read_data_WIRE_1, 95, 80) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_11 = asFixedPoint(_io_portB_read_data_T_10, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[5] <= _io_portB_read_data_T_11 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_12 = bits(_io_portB_read_data_WIRE_1, 111, 96) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_13 = asFixedPoint(_io_portB_read_data_T_12, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[6] <= _io_portB_read_data_T_13 @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_14 = bits(_io_portB_read_data_WIRE_1, 127, 112) @[DualPortMem.scala 176:50]
    node _io_portB_read_data_T_15 = asFixedPoint(_io_portB_read_data_T_14, 8) @[DualPortMem.scala 176:50]
    _io_portB_read_data_WIRE[7] <= _io_portB_read_data_T_15 @[DualPortMem.scala 176:50]
    io.portB.read.data[0] <= _io_portB_read_data_WIRE[0] @[DualPortMem.scala 176:28]
    io.portB.read.data[1] <= _io_portB_read_data_WIRE[1] @[DualPortMem.scala 176:28]
    io.portB.read.data[2] <= _io_portB_read_data_WIRE[2] @[DualPortMem.scala 176:28]
    io.portB.read.data[3] <= _io_portB_read_data_WIRE[3] @[DualPortMem.scala 176:28]
    io.portB.read.data[4] <= _io_portB_read_data_WIRE[4] @[DualPortMem.scala 176:28]
    io.portB.read.data[5] <= _io_portB_read_data_WIRE[5] @[DualPortMem.scala 176:28]
    io.portB.read.data[6] <= _io_portB_read_data_WIRE[6] @[DualPortMem.scala 176:28]
    io.portB.read.data[7] <= _io_portB_read_data_WIRE[7] @[DualPortMem.scala 176:28]
    mem.web <= io.portB.write.enable @[DualPortMem.scala 177:20]
    wire _mem_io_dib_WIRE : UInt<128> @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo_lo = asUInt(io.portB.write.data[0]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo_hi = asUInt(io.portB.write.data[1]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi_lo = asUInt(io.portB.write.data[2]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi_hi = asUInt(io.portB.write.data[3]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo_lo = asUInt(io.portB.write.data[4]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo_hi = asUInt(io.portB.write.data[5]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi_lo = asUInt(io.portB.write.data[6]) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi_hi = asUInt(io.portB.write.data[7]) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_lo = cat(mem_io_dib_lo_lo_hi, mem_io_dib_lo_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo_hi = cat(mem_io_dib_lo_hi_hi, mem_io_dib_lo_hi_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_lo = cat(mem_io_dib_lo_hi, mem_io_dib_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_lo = cat(mem_io_dib_hi_lo_hi, mem_io_dib_hi_lo_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi_hi = cat(mem_io_dib_hi_hi_hi, mem_io_dib_hi_hi_lo) @[DualPortMem.scala 178:51]
    node mem_io_dib_hi = cat(mem_io_dib_hi_hi, mem_io_dib_hi_lo) @[DualPortMem.scala 178:51]
    node _mem_io_dib_T = cat(mem_io_dib_hi, mem_io_dib_lo) @[DualPortMem.scala 178:51]
    _mem_io_dib_WIRE <= _mem_io_dib_T @[DualPortMem.scala 178:51]
    mem.dib <= _mem_io_dib_WIRE @[DualPortMem.scala 178:20]
    
  module Queue_22 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][3] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      when wrap : @[Counter.scala 86:20]
        enq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      when wrap_1 : @[Counter.scala 86:20]
        deq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h03"), UInt<1>("h00")) @[Decoupled.scala 262:24]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 264:39]
    node _io_count_T_2 = add(UInt<2>("h03"), ptr_diff) @[Decoupled.scala 265:38]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 265:38]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 264:24]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 261:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 261:14]
    
  module Queue_23 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_24 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][3] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<2>, clock with : (reset => (reset, UInt<2>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      when wrap : @[Counter.scala 86:20]
        enq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<2>("h02")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      when wrap_1 : @[Counter.scala 86:20]
        deq_ptr_value <= UInt<1>("h00") @[Counter.scala 86:28]
        skip @[Counter.scala 86:20]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits[0] <= io.enq.bits[0] @[Decoupled.scala 247:19]
      io.deq.bits[1] <= io.enq.bits[1] @[Decoupled.scala 247:19]
      io.deq.bits[2] <= io.enq.bits[2] @[Decoupled.scala 247:19]
      io.deq.bits[3] <= io.enq.bits[3] @[Decoupled.scala 247:19]
      io.deq.bits[4] <= io.enq.bits[4] @[Decoupled.scala 247:19]
      io.deq.bits[5] <= io.enq.bits[5] @[Decoupled.scala 247:19]
      io.deq.bits[6] <= io.enq.bits[6] @[Decoupled.scala 247:19]
      io.deq.bits[7] <= io.enq.bits[7] @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = mux(maybe_full, UInt<2>("h03"), UInt<1>("h00")) @[Decoupled.scala 262:24]
    node _io_count_T_1 = gt(deq_ptr_value, enq_ptr_value) @[Decoupled.scala 264:39]
    node _io_count_T_2 = add(UInt<2>("h03"), ptr_diff) @[Decoupled.scala 265:38]
    node _io_count_T_3 = tail(_io_count_T_2, 1) @[Decoupled.scala 265:38]
    node _io_count_T_4 = mux(_io_count_T_1, _io_count_T_3, ptr_diff) @[Decoupled.scala 264:24]
    node _io_count_T_5 = mux(ptr_match, _io_count_T, _io_count_T_4) @[Decoupled.scala 261:20]
    io.count <= _io_count_T_5 @[Decoupled.scala 261:14]
    
  module Queue_25 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module DualPortMem_1 : 
    input clock : Clock
    input reset : Reset
    output io : {portA : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, inputStatus : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, portB : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, flip input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, wrote : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<6>, size : UInt<6>}}, inputStatus : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst mem of InnerDualPortMem_1 @[DualPortMem.scala 34:19]
    mem.clock <= clock
    mem.reset <= reset
    inst output of Queue_22 @[DualPortMem.scala 49:24]
    output.clock <= clock
    output.reset <= reset
    node outputReady = lt(output.io.count, UInt<2>("h02")) @[DualPortMem.scala 56:39]
    mem.io.portA.address <= io.portA.control.bits.address @[DualPortMem.scala 58:19]
    when io.portA.control.bits.write : @[DualPortMem.scala 60:30]
      io.portA.control.ready <= io.portA.input.valid @[DualPortMem.scala 61:21]
      node _mem_io_portA_write_enable_T = and(io.portA.control.valid, io.portA.input.valid) @[DualPortMem.scala 62:43]
      mem.io.portA.write.enable <= _mem_io_portA_write_enable_T @[DualPortMem.scala 62:26]
      mem.io.portA.read.enable <= UInt<1>("h00") @[DualPortMem.scala 63:25]
      skip @[DualPortMem.scala 60:30]
    else : @[DualPortMem.scala 64:17]
      io.portA.control.ready <= outputReady @[DualPortMem.scala 65:21]
      mem.io.portA.write.enable <= UInt<1>("h00") @[DualPortMem.scala 66:26]
      node _mem_io_portA_read_enable_T = and(io.portA.control.valid, outputReady) @[DualPortMem.scala 67:42]
      mem.io.portA.read.enable <= _mem_io_portA_read_enable_T @[DualPortMem.scala 67:25]
      skip @[DualPortMem.scala 64:17]
    output.io.enq.bits[0] <= mem.io.portA.read.data[0] @[DualPortMem.scala 70:24]
    output.io.enq.bits[1] <= mem.io.portA.read.data[1] @[DualPortMem.scala 70:24]
    output.io.enq.bits[2] <= mem.io.portA.read.data[2] @[DualPortMem.scala 70:24]
    output.io.enq.bits[3] <= mem.io.portA.read.data[3] @[DualPortMem.scala 70:24]
    output.io.enq.bits[4] <= mem.io.portA.read.data[4] @[DualPortMem.scala 70:24]
    output.io.enq.bits[5] <= mem.io.portA.read.data[5] @[DualPortMem.scala 70:24]
    output.io.enq.bits[6] <= mem.io.portA.read.data[6] @[DualPortMem.scala 70:24]
    output.io.enq.bits[7] <= mem.io.portA.read.data[7] @[DualPortMem.scala 70:24]
    wire _output_io_enq_valid_sr_WIRE : UInt<1>[1] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE[0] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr : UInt<1>[1], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr[0] <= mem.io.portA.read.enable @[ShiftRegister.scala 25:12]
    output.io.enq.valid <= output_io_enq_valid_sr[0] @[DualPortMem.scala 71:25]
    io.portA.output.bits[0] <= output.io.deq.bits[0] @[DualPortMem.scala 73:17]
    io.portA.output.bits[1] <= output.io.deq.bits[1] @[DualPortMem.scala 73:17]
    io.portA.output.bits[2] <= output.io.deq.bits[2] @[DualPortMem.scala 73:17]
    io.portA.output.bits[3] <= output.io.deq.bits[3] @[DualPortMem.scala 73:17]
    io.portA.output.bits[4] <= output.io.deq.bits[4] @[DualPortMem.scala 73:17]
    io.portA.output.bits[5] <= output.io.deq.bits[5] @[DualPortMem.scala 73:17]
    io.portA.output.bits[6] <= output.io.deq.bits[6] @[DualPortMem.scala 73:17]
    io.portA.output.bits[7] <= output.io.deq.bits[7] @[DualPortMem.scala 73:17]
    io.portA.output.valid <= output.io.deq.valid @[DualPortMem.scala 73:17]
    output.io.deq.ready <= io.portA.output.ready @[DualPortMem.scala 73:17]
    mem.io.portA.write.data[0] <= io.portA.input.bits[0] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[1] <= io.portA.input.bits[1] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[2] <= io.portA.input.bits[2] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[3] <= io.portA.input.bits[3] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[4] <= io.portA.input.bits[4] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[5] <= io.portA.input.bits[5] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[6] <= io.portA.input.bits[6] @[DualPortMem.scala 75:22]
    mem.io.portA.write.data[7] <= io.portA.input.bits[7] @[DualPortMem.scala 75:22]
    node _io_portA_input_ready_T = and(io.portA.control.valid, io.portA.control.bits.write) @[DualPortMem.scala 76:34]
    io.portA.input.ready <= _io_portA_input_ready_T @[DualPortMem.scala 76:17]
    io.portA.status.bits.size <= io.portA.control.bits.size @[DualPortMem.scala 90:22]
    io.portA.status.bits.address <= io.portA.control.bits.address @[DualPortMem.scala 90:22]
    io.portA.status.bits.write <= io.portA.control.bits.write @[DualPortMem.scala 90:22]
    node _io_portA_status_valid_T = and(io.portA.control.valid, io.portA.control.ready) @[DualPortMem.scala 91:40]
    io.portA.status.valid <= _io_portA_status_valid_T @[DualPortMem.scala 91:23]
    io.portA.inputStatus.bits[0] <= io.portA.input.bits[0] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[1] <= io.portA.input.bits[1] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[2] <= io.portA.input.bits[2] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[3] <= io.portA.input.bits[3] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[4] <= io.portA.input.bits[4] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[5] <= io.portA.input.bits[5] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[6] <= io.portA.input.bits[6] @[DualPortMem.scala 93:27]
    io.portA.inputStatus.bits[7] <= io.portA.input.bits[7] @[DualPortMem.scala 93:27]
    node _io_portA_inputStatus_valid_T = and(io.portA.input.valid, io.portA.input.ready) @[DualPortMem.scala 94:43]
    io.portA.inputStatus.valid <= _io_portA_inputStatus_valid_T @[DualPortMem.scala 94:28]
    inst wrote of Queue_23 @[Mem.scala 23:19]
    wrote.clock <= clock
    wrote.reset <= reset
    io.portA.wrote.bits <= wrote.io.deq.bits @[Mem.scala 24:7]
    io.portA.wrote.valid <= wrote.io.deq.valid @[Mem.scala 24:7]
    wrote.io.deq.ready <= io.portA.wrote.ready @[Mem.scala 24:7]
    wrote.io.enq.bits <= UInt<1>("h01") @[DualPortMem.scala 97:16]
    wrote.io.enq.valid <= mem.io.portA.write.enable @[DualPortMem.scala 98:17]
    inst output_1 of Queue_24 @[DualPortMem.scala 49:24]
    output_1.clock <= clock
    output_1.reset <= reset
    node outputReady_1 = lt(output_1.io.count, UInt<2>("h02")) @[DualPortMem.scala 56:39]
    mem.io.portB.address <= io.portB.control.bits.address @[DualPortMem.scala 58:19]
    when io.portB.control.bits.write : @[DualPortMem.scala 60:30]
      io.portB.control.ready <= io.portB.input.valid @[DualPortMem.scala 61:21]
      node _mem_io_portB_write_enable_T = and(io.portB.control.valid, io.portB.input.valid) @[DualPortMem.scala 62:43]
      mem.io.portB.write.enable <= _mem_io_portB_write_enable_T @[DualPortMem.scala 62:26]
      mem.io.portB.read.enable <= UInt<1>("h00") @[DualPortMem.scala 63:25]
      skip @[DualPortMem.scala 60:30]
    else : @[DualPortMem.scala 64:17]
      io.portB.control.ready <= outputReady_1 @[DualPortMem.scala 65:21]
      mem.io.portB.write.enable <= UInt<1>("h00") @[DualPortMem.scala 66:26]
      node _mem_io_portB_read_enable_T = and(io.portB.control.valid, outputReady_1) @[DualPortMem.scala 67:42]
      mem.io.portB.read.enable <= _mem_io_portB_read_enable_T @[DualPortMem.scala 67:25]
      skip @[DualPortMem.scala 64:17]
    output_1.io.enq.bits[0] <= mem.io.portB.read.data[0] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[1] <= mem.io.portB.read.data[1] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[2] <= mem.io.portB.read.data[2] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[3] <= mem.io.portB.read.data[3] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[4] <= mem.io.portB.read.data[4] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[5] <= mem.io.portB.read.data[5] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[6] <= mem.io.portB.read.data[6] @[DualPortMem.scala 70:24]
    output_1.io.enq.bits[7] <= mem.io.portB.read.data[7] @[DualPortMem.scala 70:24]
    wire _output_io_enq_valid_sr_WIRE_1 : UInt<1>[1] @[package.scala 80:57]
    _output_io_enq_valid_sr_WIRE_1[0] <= UInt<1>("h00") @[package.scala 80:57]
    reg output_io_enq_valid_sr_1 : UInt<1>[1], clock with : (reset => (reset, _output_io_enq_valid_sr_WIRE_1)) @[ShiftRegister.scala 10:22]
    output_io_enq_valid_sr_1[0] <= mem.io.portB.read.enable @[ShiftRegister.scala 25:12]
    output_1.io.enq.valid <= output_io_enq_valid_sr_1[0] @[DualPortMem.scala 71:25]
    io.portB.output.bits[0] <= output_1.io.deq.bits[0] @[DualPortMem.scala 73:17]
    io.portB.output.bits[1] <= output_1.io.deq.bits[1] @[DualPortMem.scala 73:17]
    io.portB.output.bits[2] <= output_1.io.deq.bits[2] @[DualPortMem.scala 73:17]
    io.portB.output.bits[3] <= output_1.io.deq.bits[3] @[DualPortMem.scala 73:17]
    io.portB.output.bits[4] <= output_1.io.deq.bits[4] @[DualPortMem.scala 73:17]
    io.portB.output.bits[5] <= output_1.io.deq.bits[5] @[DualPortMem.scala 73:17]
    io.portB.output.bits[6] <= output_1.io.deq.bits[6] @[DualPortMem.scala 73:17]
    io.portB.output.bits[7] <= output_1.io.deq.bits[7] @[DualPortMem.scala 73:17]
    io.portB.output.valid <= output_1.io.deq.valid @[DualPortMem.scala 73:17]
    output_1.io.deq.ready <= io.portB.output.ready @[DualPortMem.scala 73:17]
    mem.io.portB.write.data[0] <= io.portB.input.bits[0] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[1] <= io.portB.input.bits[1] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[2] <= io.portB.input.bits[2] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[3] <= io.portB.input.bits[3] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[4] <= io.portB.input.bits[4] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[5] <= io.portB.input.bits[5] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[6] <= io.portB.input.bits[6] @[DualPortMem.scala 75:22]
    mem.io.portB.write.data[7] <= io.portB.input.bits[7] @[DualPortMem.scala 75:22]
    node _io_portB_input_ready_T = and(io.portB.control.valid, io.portB.control.bits.write) @[DualPortMem.scala 76:34]
    io.portB.input.ready <= _io_portB_input_ready_T @[DualPortMem.scala 76:17]
    io.portB.status.bits.size <= io.portB.control.bits.size @[DualPortMem.scala 90:22]
    io.portB.status.bits.address <= io.portB.control.bits.address @[DualPortMem.scala 90:22]
    io.portB.status.bits.write <= io.portB.control.bits.write @[DualPortMem.scala 90:22]
    node _io_portB_status_valid_T = and(io.portB.control.valid, io.portB.control.ready) @[DualPortMem.scala 91:40]
    io.portB.status.valid <= _io_portB_status_valid_T @[DualPortMem.scala 91:23]
    io.portB.inputStatus.bits[0] <= io.portB.input.bits[0] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[1] <= io.portB.input.bits[1] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[2] <= io.portB.input.bits[2] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[3] <= io.portB.input.bits[3] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[4] <= io.portB.input.bits[4] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[5] <= io.portB.input.bits[5] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[6] <= io.portB.input.bits[6] @[DualPortMem.scala 93:27]
    io.portB.inputStatus.bits[7] <= io.portB.input.bits[7] @[DualPortMem.scala 93:27]
    node _io_portB_inputStatus_valid_T = and(io.portB.input.valid, io.portB.input.ready) @[DualPortMem.scala 94:43]
    io.portB.inputStatus.valid <= _io_portB_inputStatus_valid_T @[DualPortMem.scala 94:28]
    inst wrote_1 of Queue_25 @[Mem.scala 23:19]
    wrote_1.clock <= clock
    wrote_1.reset <= reset
    io.portB.wrote.bits <= wrote_1.io.deq.bits @[Mem.scala 24:7]
    io.portB.wrote.valid <= wrote_1.io.deq.valid @[Mem.scala 24:7]
    wrote_1.io.deq.ready <= io.portB.wrote.ready @[Mem.scala 24:7]
    wrote_1.io.enq.bits <= UInt<1>("h01") @[DualPortMem.scala 97:16]
    wrote_1.io.enq.valid <= mem.io.portB.write.enable @[DualPortMem.scala 98:17]
    
  module Demux_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[3]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_2_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_2_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[0] <= _io_out_2_bits_T @[package.scala 80:57]
    node _io_out_2_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[1] <= _io_out_2_bits_T_1 @[package.scala 80:57]
    node _io_out_2_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[2] <= _io_out_2_bits_T_2 @[package.scala 80:57]
    node _io_out_2_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[3] <= _io_out_2_bits_T_3 @[package.scala 80:57]
    node _io_out_2_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[4] <= _io_out_2_bits_T_4 @[package.scala 80:57]
    node _io_out_2_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[5] <= _io_out_2_bits_T_5 @[package.scala 80:57]
    node _io_out_2_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[6] <= _io_out_2_bits_T_6 @[package.scala 80:57]
    node _io_out_2_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_2_bits_WIRE[7] <= _io_out_2_bits_T_7 @[package.scala 80:57]
    io.out[2].bits[0] <= _io_out_2_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[2].bits[1] <= _io_out_2_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[2].bits[2] <= _io_out_2_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[2].bits[3] <= _io_out_2_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[2].bits[4] <= _io_out_2_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[2].bits[5] <= _io_out_2_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[2].bits[6] <= _io_out_2_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[2].bits[7] <= _io_out_2_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[2].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module Mux_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0].bits[0] <= io.in[0].bits[0] @[Mux.scala 47:19]
    in[0].bits[1] <= io.in[0].bits[1] @[Mux.scala 47:19]
    in[0].bits[2] <= io.in[0].bits[2] @[Mux.scala 47:19]
    in[0].bits[3] <= io.in[0].bits[3] @[Mux.scala 47:19]
    in[0].bits[4] <= io.in[0].bits[4] @[Mux.scala 47:19]
    in[0].bits[5] <= io.in[0].bits[5] @[Mux.scala 47:19]
    in[0].bits[6] <= io.in[0].bits[6] @[Mux.scala 47:19]
    in[0].bits[7] <= io.in[0].bits[7] @[Mux.scala 47:19]
    in[0].valid <= io.in[0].valid @[Mux.scala 47:19]
    io.in[0].ready <= in[0].ready @[Mux.scala 47:19]
    in[1].bits[0] <= io.in[1].bits[0] @[Mux.scala 47:19]
    in[1].bits[1] <= io.in[1].bits[1] @[Mux.scala 47:19]
    in[1].bits[2] <= io.in[1].bits[2] @[Mux.scala 47:19]
    in[1].bits[3] <= io.in[1].bits[3] @[Mux.scala 47:19]
    in[1].bits[4] <= io.in[1].bits[4] @[Mux.scala 47:19]
    in[1].bits[5] <= io.in[1].bits[5] @[Mux.scala 47:19]
    in[1].bits[6] <= io.in[1].bits[6] @[Mux.scala 47:19]
    in[1].bits[7] <= io.in[1].bits[7] @[Mux.scala 47:19]
    in[1].valid <= io.in[1].valid @[Mux.scala 47:19]
    io.in[1].ready <= in[1].ready @[Mux.scala 47:19]
    in[UInt<1>("h00")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    in[UInt<1>("h01")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    io.out.bits[0] <= in[io.sel.bits].bits[0] @[Mux.scala 57:15]
    io.out.bits[1] <= in[io.sel.bits].bits[1] @[Mux.scala 57:15]
    io.out.bits[2] <= in[io.sel.bits].bits[2] @[Mux.scala 57:15]
    io.out.bits[3] <= in[io.sel.bits].bits[3] @[Mux.scala 57:15]
    io.out.bits[4] <= in[io.sel.bits].bits[4] @[Mux.scala 57:15]
    io.out.bits[5] <= in[io.sel.bits].bits[5] @[Mux.scala 57:15]
    io.out.bits[6] <= in[io.sel.bits].bits[6] @[Mux.scala 57:15]
    io.out.bits[7] <= in[io.sel.bits].bits[7] @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]
    
  module Mux_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0].bits[0] <= io.in[0].bits[0] @[Mux.scala 47:19]
    in[0].bits[1] <= io.in[0].bits[1] @[Mux.scala 47:19]
    in[0].bits[2] <= io.in[0].bits[2] @[Mux.scala 47:19]
    in[0].bits[3] <= io.in[0].bits[3] @[Mux.scala 47:19]
    in[0].bits[4] <= io.in[0].bits[4] @[Mux.scala 47:19]
    in[0].bits[5] <= io.in[0].bits[5] @[Mux.scala 47:19]
    in[0].bits[6] <= io.in[0].bits[6] @[Mux.scala 47:19]
    in[0].bits[7] <= io.in[0].bits[7] @[Mux.scala 47:19]
    in[0].valid <= io.in[0].valid @[Mux.scala 47:19]
    io.in[0].ready <= in[0].ready @[Mux.scala 47:19]
    in[1].bits[0] <= io.in[1].bits[0] @[Mux.scala 47:19]
    in[1].bits[1] <= io.in[1].bits[1] @[Mux.scala 47:19]
    in[1].bits[2] <= io.in[1].bits[2] @[Mux.scala 47:19]
    in[1].bits[3] <= io.in[1].bits[3] @[Mux.scala 47:19]
    in[1].bits[4] <= io.in[1].bits[4] @[Mux.scala 47:19]
    in[1].bits[5] <= io.in[1].bits[5] @[Mux.scala 47:19]
    in[1].bits[6] <= io.in[1].bits[6] @[Mux.scala 47:19]
    in[1].bits[7] <= io.in[1].bits[7] @[Mux.scala 47:19]
    in[1].valid <= io.in[1].valid @[Mux.scala 47:19]
    io.in[1].ready <= in[1].ready @[Mux.scala 47:19]
    in[UInt<1>("h00")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    in[UInt<1>("h01")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    io.out.bits[0] <= in[io.sel.bits].bits[0] @[Mux.scala 57:15]
    io.out.bits[1] <= in[io.sel.bits].bits[1] @[Mux.scala 57:15]
    io.out.bits[2] <= in[io.sel.bits].bits[2] @[Mux.scala 57:15]
    io.out.bits[3] <= in[io.sel.bits].bits[3] @[Mux.scala 57:15]
    io.out.bits[4] <= in[io.sel.bits].bits[4] @[Mux.scala 57:15]
    io.out.bits[5] <= in[io.sel.bits].bits[5] @[Mux.scala 57:15]
    io.out.bits[6] <= in[io.sel.bits].bits[6] @[Mux.scala 57:15]
    io.out.bits[7] <= in[io.sel.bits].bits[7] @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]
    
  module Counter_7 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module SizeHandler_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<2>, size : UInt<6>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<2>}}}
    
    inst sizeCounter of Counter_7 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
      skip @[SizeHandler.scala 34:52]
    else : @[SizeHandler.scala 37:15]
      io.in.ready <= UInt<1>("h00") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]
      skip @[SizeHandler.scala 37:15]
    
  module Counter_8 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module SizeHandler_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>}}}
    
    inst sizeCounter of Counter_8 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
      skip @[SizeHandler.scala 34:52]
    else : @[SizeHandler.scala 37:15]
      io.in.ready <= UInt<1>("h00") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]
      skip @[SizeHandler.scala 37:15]
    
  module Counter_9 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<6>}, flip resetValue : UInt<1>}
    
    reg value : UInt<6>, clock with : (reset => (reset, UInt<6>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<6>("h03f")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module SizeHandler_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>}}}
    
    inst sizeCounter of Counter_9 @[Counter.scala 34:19]
    sizeCounter.clock <= clock
    sizeCounter.reset <= reset
    sizeCounter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    sizeCounter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.valid <= io.in.valid @[SizeHandler.scala 25:16]
    io.out.bits.sel <= io.in.bits.sel @[SizeHandler.scala 28:34]
    node fire = and(io.in.valid, io.out.ready) @[SizeHandler.scala 32:23]
    node _T = eq(sizeCounter.io.value.bits, io.in.bits.size) @[SizeHandler.scala 34:34]
    when _T : @[SizeHandler.scala 34:52]
      io.in.ready <= io.out.ready @[SizeHandler.scala 35:14]
      sizeCounter.io.resetValue <= fire @[SizeHandler.scala 36:31]
      skip @[SizeHandler.scala 34:52]
    else : @[SizeHandler.scala 37:15]
      io.in.ready <= UInt<1>("h00") @[SizeHandler.scala 38:14]
      sizeCounter.io.value.ready <= fire @[SizeHandler.scala 39:32]
      skip @[SizeHandler.scala 37:15]
    
  module MultiEnqueue_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[1]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node allEnqueued = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module LocalRouter : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<4>, size : UInt<6>}}, mem : {flip output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, array : {input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, weightInput : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, acc : {flip output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst memReadDataDemuxModule of Demux_4 @[LocalRouter.scala 55:38]
    memReadDataDemuxModule.clock <= clock
    memReadDataDemuxModule.reset <= reset
    memReadDataDemuxModule.io.in.bits[0] <= io.mem.output.bits[0] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[1] <= io.mem.output.bits[1] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[2] <= io.mem.output.bits[2] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[3] <= io.mem.output.bits[3] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[4] <= io.mem.output.bits[4] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[5] <= io.mem.output.bits[5] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[6] <= io.mem.output.bits[6] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.bits[7] <= io.mem.output.bits[7] @[LocalRouter.scala 62:32]
    memReadDataDemuxModule.io.in.valid <= io.mem.output.valid @[LocalRouter.scala 62:32]
    io.mem.output.ready <= memReadDataDemuxModule.io.in.ready @[LocalRouter.scala 62:32]
    io.array.weightInput.bits[0] <= memReadDataDemuxModule.io.out[0].bits[0] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[1] <= memReadDataDemuxModule.io.out[0].bits[1] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[2] <= memReadDataDemuxModule.io.out[0].bits[2] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[3] <= memReadDataDemuxModule.io.out[0].bits[3] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[4] <= memReadDataDemuxModule.io.out[0].bits[4] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[5] <= memReadDataDemuxModule.io.out[0].bits[5] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[6] <= memReadDataDemuxModule.io.out[0].bits[6] @[LocalRouter.scala 63:24]
    io.array.weightInput.bits[7] <= memReadDataDemuxModule.io.out[0].bits[7] @[LocalRouter.scala 63:24]
    io.array.weightInput.valid <= memReadDataDemuxModule.io.out[0].valid @[LocalRouter.scala 63:24]
    memReadDataDemuxModule.io.out[0].ready <= io.array.weightInput.ready @[LocalRouter.scala 63:24]
    io.array.input.bits[0] <= memReadDataDemuxModule.io.out[1].bits[0] @[LocalRouter.scala 64:18]
    io.array.input.bits[1] <= memReadDataDemuxModule.io.out[1].bits[1] @[LocalRouter.scala 64:18]
    io.array.input.bits[2] <= memReadDataDemuxModule.io.out[1].bits[2] @[LocalRouter.scala 64:18]
    io.array.input.bits[3] <= memReadDataDemuxModule.io.out[1].bits[3] @[LocalRouter.scala 64:18]
    io.array.input.bits[4] <= memReadDataDemuxModule.io.out[1].bits[4] @[LocalRouter.scala 64:18]
    io.array.input.bits[5] <= memReadDataDemuxModule.io.out[1].bits[5] @[LocalRouter.scala 64:18]
    io.array.input.bits[6] <= memReadDataDemuxModule.io.out[1].bits[6] @[LocalRouter.scala 64:18]
    io.array.input.bits[7] <= memReadDataDemuxModule.io.out[1].bits[7] @[LocalRouter.scala 64:18]
    io.array.input.valid <= memReadDataDemuxModule.io.out[1].valid @[LocalRouter.scala 64:18]
    memReadDataDemuxModule.io.out[1].ready <= io.array.input.ready @[LocalRouter.scala 64:18]
    inst memWriteDataMuxModule of Mux_1 @[LocalRouter.scala 66:37]
    memWriteDataMuxModule.clock <= clock
    memWriteDataMuxModule.reset <= reset
    wire _memWriteDataMuxModule_io_in_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[0] <= _memWriteDataMuxModule_io_in_0_bits_T @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[1] <= _memWriteDataMuxModule_io_in_0_bits_T_1 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[2] <= _memWriteDataMuxModule_io_in_0_bits_T_2 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[3] <= _memWriteDataMuxModule_io_in_0_bits_T_3 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[4] <= _memWriteDataMuxModule_io_in_0_bits_T_4 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[5] <= _memWriteDataMuxModule_io_in_0_bits_T_5 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[6] <= _memWriteDataMuxModule_io_in_0_bits_T_6 @[package.scala 80:57]
    node _memWriteDataMuxModule_io_in_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _memWriteDataMuxModule_io_in_0_bits_WIRE[7] <= _memWriteDataMuxModule_io_in_0_bits_T_7 @[package.scala 80:57]
    memWriteDataMuxModule.io.in[0].bits[0] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[0] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[1] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[1] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[2] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[2] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[3] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[3] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[4] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[4] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[5] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[5] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[6] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[6] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].bits[7] <= _memWriteDataMuxModule_io_in_0_bits_WIRE[7] @[package.scala 409:14]
    memWriteDataMuxModule.io.in[0].valid <= UInt<1>("h00") @[package.scala 410:15]
    memWriteDataMuxModule.io.in[1].bits[0] <= io.acc.output.bits[0] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[1] <= io.acc.output.bits[1] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[2] <= io.acc.output.bits[2] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[3] <= io.acc.output.bits[3] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[4] <= io.acc.output.bits[4] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[5] <= io.acc.output.bits[5] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[6] <= io.acc.output.bits[6] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].bits[7] <= io.acc.output.bits[7] @[LocalRouter.scala 74:34]
    memWriteDataMuxModule.io.in[1].valid <= io.acc.output.valid @[LocalRouter.scala 74:34]
    io.acc.output.ready <= memWriteDataMuxModule.io.in[1].ready @[LocalRouter.scala 74:34]
    io.mem.input.bits[0] <= memWriteDataMuxModule.io.out.bits[0] @[LocalRouter.scala 75:16]
    io.mem.input.bits[1] <= memWriteDataMuxModule.io.out.bits[1] @[LocalRouter.scala 75:16]
    io.mem.input.bits[2] <= memWriteDataMuxModule.io.out.bits[2] @[LocalRouter.scala 75:16]
    io.mem.input.bits[3] <= memWriteDataMuxModule.io.out.bits[3] @[LocalRouter.scala 75:16]
    io.mem.input.bits[4] <= memWriteDataMuxModule.io.out.bits[4] @[LocalRouter.scala 75:16]
    io.mem.input.bits[5] <= memWriteDataMuxModule.io.out.bits[5] @[LocalRouter.scala 75:16]
    io.mem.input.bits[6] <= memWriteDataMuxModule.io.out.bits[6] @[LocalRouter.scala 75:16]
    io.mem.input.bits[7] <= memWriteDataMuxModule.io.out.bits[7] @[LocalRouter.scala 75:16]
    io.mem.input.valid <= memWriteDataMuxModule.io.out.valid @[LocalRouter.scala 75:16]
    memWriteDataMuxModule.io.out.ready <= io.mem.input.ready @[LocalRouter.scala 75:16]
    inst accWriteDataMuxModule of Mux_2 @[LocalRouter.scala 77:37]
    accWriteDataMuxModule.clock <= clock
    accWriteDataMuxModule.reset <= reset
    accWriteDataMuxModule.io.in[0].bits[0] <= io.array.output.bits[0] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[1] <= io.array.output.bits[1] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[2] <= io.array.output.bits[2] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[3] <= io.array.output.bits[3] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[4] <= io.array.output.bits[4] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[5] <= io.array.output.bits[5] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[6] <= io.array.output.bits[6] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].bits[7] <= io.array.output.bits[7] @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[0].valid <= io.array.output.valid @[LocalRouter.scala 84:34]
    io.array.output.ready <= accWriteDataMuxModule.io.in[0].ready @[LocalRouter.scala 84:34]
    accWriteDataMuxModule.io.in[1].bits[0] <= memReadDataDemuxModule.io.out[2].bits[0] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[1] <= memReadDataDemuxModule.io.out[2].bits[1] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[2] <= memReadDataDemuxModule.io.out[2].bits[2] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[3] <= memReadDataDemuxModule.io.out[2].bits[3] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[4] <= memReadDataDemuxModule.io.out[2].bits[4] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[5] <= memReadDataDemuxModule.io.out[2].bits[5] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[6] <= memReadDataDemuxModule.io.out[2].bits[6] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].bits[7] <= memReadDataDemuxModule.io.out[2].bits[7] @[LocalRouter.scala 85:34]
    accWriteDataMuxModule.io.in[1].valid <= memReadDataDemuxModule.io.out[2].valid @[LocalRouter.scala 85:34]
    memReadDataDemuxModule.io.out[2].ready <= accWriteDataMuxModule.io.in[1].ready @[LocalRouter.scala 85:34]
    io.acc.input.bits[0] <= accWriteDataMuxModule.io.out.bits[0] @[LocalRouter.scala 86:16]
    io.acc.input.bits[1] <= accWriteDataMuxModule.io.out.bits[1] @[LocalRouter.scala 86:16]
    io.acc.input.bits[2] <= accWriteDataMuxModule.io.out.bits[2] @[LocalRouter.scala 86:16]
    io.acc.input.bits[3] <= accWriteDataMuxModule.io.out.bits[3] @[LocalRouter.scala 86:16]
    io.acc.input.bits[4] <= accWriteDataMuxModule.io.out.bits[4] @[LocalRouter.scala 86:16]
    io.acc.input.bits[5] <= accWriteDataMuxModule.io.out.bits[5] @[LocalRouter.scala 86:16]
    io.acc.input.bits[6] <= accWriteDataMuxModule.io.out.bits[6] @[LocalRouter.scala 86:16]
    io.acc.input.bits[7] <= accWriteDataMuxModule.io.out.bits[7] @[LocalRouter.scala 86:16]
    io.acc.input.valid <= accWriteDataMuxModule.io.out.valid @[LocalRouter.scala 86:16]
    accWriteDataMuxModule.io.out.ready <= io.acc.input.ready @[LocalRouter.scala 86:16]
    inst sizeHandler of SizeHandler_2 @[package.scala 31:29]
    sizeHandler.clock <= clock
    sizeHandler.reset <= reset
    memReadDataDemuxModule.io.sel.bits <= sizeHandler.io.out.bits.sel @[package.scala 35:17]
    memReadDataDemuxModule.io.sel.valid <= sizeHandler.io.out.valid @[package.scala 36:18]
    sizeHandler.io.out.ready <= memReadDataDemuxModule.io.sel.ready @[package.scala 37:30]
    inst sizeHandler_1 of SizeHandler_3 @[package.scala 31:29]
    sizeHandler_1.clock <= clock
    sizeHandler_1.reset <= reset
    memWriteDataMuxModule.io.sel.bits <= sizeHandler_1.io.out.bits.sel @[package.scala 35:17]
    memWriteDataMuxModule.io.sel.valid <= sizeHandler_1.io.out.valid @[package.scala 36:18]
    sizeHandler_1.io.out.ready <= memWriteDataMuxModule.io.sel.ready @[package.scala 37:30]
    inst sizeHandler_2 of SizeHandler_4 @[package.scala 31:29]
    sizeHandler_2.clock <= clock
    sizeHandler_2.reset <= reset
    accWriteDataMuxModule.io.sel.bits <= sizeHandler_2.io.out.bits.sel @[package.scala 35:17]
    accWriteDataMuxModule.io.sel.valid <= sizeHandler_2.io.out.valid @[package.scala 36:18]
    sizeHandler_2.io.out.ready <= accWriteDataMuxModule.io.sel.ready @[package.scala 37:30]
    wire _sizeHandler_io_in_bits_WIRE : {sel : UInt<2>, size : UInt<6>} @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE.size <= UInt<6>("h00") @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE.sel <= UInt<2>("h00") @[package.scala 80:57]
    sizeHandler.io.in.bits.size <= _sizeHandler_io_in_bits_WIRE.size @[package.scala 409:14]
    sizeHandler.io.in.bits.sel <= _sizeHandler_io_in_bits_WIRE.sel @[package.scala 409:14]
    sizeHandler.io.in.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _sizeHandler_io_in_bits_WIRE_1 : {sel : UInt<1>, size : UInt<6>} @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE_1.size <= UInt<6>("h00") @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE_1.sel <= UInt<1>("h00") @[package.scala 80:57]
    sizeHandler_1.io.in.bits.size <= _sizeHandler_io_in_bits_WIRE_1.size @[package.scala 409:14]
    sizeHandler_1.io.in.bits.sel <= _sizeHandler_io_in_bits_WIRE_1.sel @[package.scala 409:14]
    sizeHandler_1.io.in.valid <= UInt<1>("h00") @[package.scala 410:15]
    wire _sizeHandler_io_in_bits_WIRE_2 : {sel : UInt<1>, size : UInt<6>} @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE_2.size <= UInt<6>("h00") @[package.scala 80:57]
    _sizeHandler_io_in_bits_WIRE_2.sel <= UInt<1>("h00") @[package.scala 80:57]
    sizeHandler_2.io.in.bits.size <= _sizeHandler_io_in_bits_WIRE_2.size @[package.scala 409:14]
    sizeHandler_2.io.in.bits.sel <= _sizeHandler_io_in_bits_WIRE_2.sel @[package.scala 409:14]
    sizeHandler_2.io.in.valid <= UInt<1>("h00") @[package.scala 410:15]
    inst enqueuer1 of MultiEnqueue_14 @[MultiEnqueue.scala 160:43]
    enqueuer1.clock <= clock
    enqueuer1.reset <= reset
    inst enqueuer2 of MultiEnqueue_15 @[MultiEnqueue.scala 160:43]
    enqueuer2.clock <= clock
    enqueuer2.reset <= reset
    enqueuer1.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer1.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    enqueuer2.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    enqueuer2.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    node _T = eq(io.control.bits.kind, UInt<1>("h01")) @[LocalRouter.scala 122:26]
    when _T : @[LocalRouter.scala 122:72]
      wire io_control_ready_w : {sel : UInt<2>, size : UInt<6>} @[Mux.scala 20:19]
      io_control_ready_w.sel <= UInt<1>("h00") @[Mux.scala 21:13]
      io_control_ready_w.size <= io.control.bits.size @[Mux.scala 22:14]
      enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
      wire io_control_ready_sizeHandler_io_in_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
      io_control_ready_sizeHandler_io_in_w.bits.size <= io_control_ready_w.size @[ReadyValid.scala 17:12]
      io_control_ready_sizeHandler_io_in_w.bits.sel <= io_control_ready_w.sel @[ReadyValid.scala 17:12]
      io_control_ready_sizeHandler_io_in_w.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
      enqueuer1.io.out[0].ready <= io_control_ready_sizeHandler_io_in_w.ready @[ReadyValid.scala 19:11]
      sizeHandler.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w.bits.size @[MultiEnqueue.scala 61:10]
      sizeHandler.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w.bits.sel @[MultiEnqueue.scala 61:10]
      sizeHandler.io.in.valid <= io_control_ready_sizeHandler_io_in_w.valid @[MultiEnqueue.scala 61:10]
      io_control_ready_sizeHandler_io_in_w.ready <= sizeHandler.io.in.ready @[MultiEnqueue.scala 61:10]
      io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 123:19]
      skip @[LocalRouter.scala 122:72]
    else : @[LocalRouter.scala 128:78]
      node _T_1 = eq(io.control.bits.kind, UInt<2>("h02")) @[LocalRouter.scala 128:32]
      when _T_1 : @[LocalRouter.scala 128:78]
        wire io_control_ready_w_1 : {sel : UInt<2>, size : UInt<6>} @[Mux.scala 20:19]
        io_control_ready_w_1.sel <= UInt<1>("h01") @[Mux.scala 21:13]
        io_control_ready_w_1.size <= io.control.bits.size @[Mux.scala 22:14]
        wire io_control_ready_w_2 : {sel : UInt<1>, size : UInt<6>} @[Mux.scala 20:19]
        io_control_ready_w_2.sel <= UInt<1>("h00") @[Mux.scala 21:13]
        io_control_ready_w_2.size <= io.control.bits.size @[Mux.scala 22:14]
        enqueuer2.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
        wire io_control_ready_sizeHandler_io_in_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        io_control_ready_sizeHandler_io_in_w_1.bits.size <= io_control_ready_w_1.size @[ReadyValid.scala 17:12]
        io_control_ready_sizeHandler_io_in_w_1.bits.sel <= io_control_ready_w_1.sel @[ReadyValid.scala 17:12]
        io_control_ready_sizeHandler_io_in_w_1.valid <= enqueuer2.io.out[0].valid @[ReadyValid.scala 18:13]
        enqueuer2.io.out[0].ready <= io_control_ready_sizeHandler_io_in_w_1.ready @[ReadyValid.scala 19:11]
        sizeHandler.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_1.bits.size @[MultiEnqueue.scala 85:10]
        sizeHandler.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_1.bits.sel @[MultiEnqueue.scala 85:10]
        sizeHandler.io.in.valid <= io_control_ready_sizeHandler_io_in_w_1.valid @[MultiEnqueue.scala 85:10]
        io_control_ready_sizeHandler_io_in_w_1.ready <= sizeHandler.io.in.ready @[MultiEnqueue.scala 85:10]
        wire io_control_ready_sizeHandler_io_in_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
        io_control_ready_sizeHandler_io_in_w_2.bits.size <= io_control_ready_w_2.size @[ReadyValid.scala 17:12]
        io_control_ready_sizeHandler_io_in_w_2.bits.sel <= io_control_ready_w_2.sel @[ReadyValid.scala 17:12]
        io_control_ready_sizeHandler_io_in_w_2.valid <= enqueuer2.io.out[1].valid @[ReadyValid.scala 18:13]
        enqueuer2.io.out[1].ready <= io_control_ready_sizeHandler_io_in_w_2.ready @[ReadyValid.scala 19:11]
        sizeHandler_2.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_2.bits.size @[MultiEnqueue.scala 86:10]
        sizeHandler_2.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_2.bits.sel @[MultiEnqueue.scala 86:10]
        sizeHandler_2.io.in.valid <= io_control_ready_sizeHandler_io_in_w_2.valid @[MultiEnqueue.scala 86:10]
        io_control_ready_sizeHandler_io_in_w_2.ready <= sizeHandler_2.io.in.ready @[MultiEnqueue.scala 86:10]
        io.control.ready <= enqueuer2.io.in.ready @[LocalRouter.scala 129:19]
        skip @[LocalRouter.scala 128:78]
      else : @[LocalRouter.scala 136:70]
        node _T_2 = eq(io.control.bits.kind, UInt<2>("h03")) @[LocalRouter.scala 136:32]
        when _T_2 : @[LocalRouter.scala 136:70]
          wire io_control_ready_w_3 : {sel : UInt<1>, size : UInt<6>} @[Mux.scala 20:19]
          io_control_ready_w_3.sel <= UInt<1>("h00") @[Mux.scala 21:13]
          io_control_ready_w_3.size <= io.control.bits.size @[Mux.scala 22:14]
          enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
          wire io_control_ready_sizeHandler_io_in_w_3 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
          io_control_ready_sizeHandler_io_in_w_3.bits.size <= io_control_ready_w_3.size @[ReadyValid.scala 17:12]
          io_control_ready_sizeHandler_io_in_w_3.bits.sel <= io_control_ready_w_3.sel @[ReadyValid.scala 17:12]
          io_control_ready_sizeHandler_io_in_w_3.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
          enqueuer1.io.out[0].ready <= io_control_ready_sizeHandler_io_in_w_3.ready @[ReadyValid.scala 19:11]
          sizeHandler_2.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_3.bits.size @[MultiEnqueue.scala 61:10]
          sizeHandler_2.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_3.bits.sel @[MultiEnqueue.scala 61:10]
          sizeHandler_2.io.in.valid <= io_control_ready_sizeHandler_io_in_w_3.valid @[MultiEnqueue.scala 61:10]
          io_control_ready_sizeHandler_io_in_w_3.ready <= sizeHandler_2.io.in.ready @[MultiEnqueue.scala 61:10]
          io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 137:19]
          skip @[LocalRouter.scala 136:70]
        else : @[LocalRouter.scala 142:78]
          node _T_3 = eq(io.control.bits.kind, UInt<3>("h04")) @[LocalRouter.scala 142:32]
          when _T_3 : @[LocalRouter.scala 142:78]
            wire io_control_ready_w_4 : {sel : UInt<1>, size : UInt<6>} @[Mux.scala 20:19]
            io_control_ready_w_4.sel <= UInt<1>("h01") @[Mux.scala 21:13]
            io_control_ready_w_4.size <= io.control.bits.size @[Mux.scala 22:14]
            enqueuer1.io.in.valid <= io.control.valid @[MultiEnqueue.scala 60:17]
            wire io_control_ready_sizeHandler_io_in_w_4 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
            io_control_ready_sizeHandler_io_in_w_4.bits.size <= io_control_ready_w_4.size @[ReadyValid.scala 17:12]
            io_control_ready_sizeHandler_io_in_w_4.bits.sel <= io_control_ready_w_4.sel @[ReadyValid.scala 17:12]
            io_control_ready_sizeHandler_io_in_w_4.valid <= enqueuer1.io.out[0].valid @[ReadyValid.scala 18:13]
            enqueuer1.io.out[0].ready <= io_control_ready_sizeHandler_io_in_w_4.ready @[ReadyValid.scala 19:11]
            sizeHandler_1.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_4.bits.size @[MultiEnqueue.scala 61:10]
            sizeHandler_1.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_4.bits.sel @[MultiEnqueue.scala 61:10]
            sizeHandler_1.io.in.valid <= io_control_ready_sizeHandler_io_in_w_4.valid @[MultiEnqueue.scala 61:10]
            io_control_ready_sizeHandler_io_in_w_4.ready <= sizeHandler_1.io.in.ready @[MultiEnqueue.scala 61:10]
            io.control.ready <= enqueuer1.io.in.ready @[LocalRouter.scala 143:19]
            skip @[LocalRouter.scala 142:78]
          else : @[LocalRouter.scala 150:5]
            node _T_4 = eq(io.control.bits.kind, UInt<3>("h05")) @[LocalRouter.scala 149:23]
            when _T_4 : @[LocalRouter.scala 150:5]
              wire io_control_ready_w_5 : {sel : UInt<2>, size : UInt<6>} @[Mux.scala 20:19]
              io_control_ready_w_5.sel <= UInt<2>("h02") @[Mux.scala 21:13]
              io_control_ready_w_5.size <= io.control.bits.size @[Mux.scala 22:14]
              wire io_control_ready_w_6 : {sel : UInt<1>, size : UInt<6>} @[Mux.scala 20:19]
              io_control_ready_w_6.sel <= UInt<1>("h01") @[Mux.scala 21:13]
              io_control_ready_w_6.size <= io.control.bits.size @[Mux.scala 22:14]
              enqueuer2.io.in.valid <= io.control.valid @[MultiEnqueue.scala 84:17]
              wire io_control_ready_sizeHandler_io_in_w_5 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<2>, size : UInt<6>}} @[ReadyValid.scala 16:17]
              io_control_ready_sizeHandler_io_in_w_5.bits.size <= io_control_ready_w_5.size @[ReadyValid.scala 17:12]
              io_control_ready_sizeHandler_io_in_w_5.bits.sel <= io_control_ready_w_5.sel @[ReadyValid.scala 17:12]
              io_control_ready_sizeHandler_io_in_w_5.valid <= enqueuer2.io.out[0].valid @[ReadyValid.scala 18:13]
              enqueuer2.io.out[0].ready <= io_control_ready_sizeHandler_io_in_w_5.ready @[ReadyValid.scala 19:11]
              sizeHandler.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_5.bits.size @[MultiEnqueue.scala 85:10]
              sizeHandler.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_5.bits.sel @[MultiEnqueue.scala 85:10]
              sizeHandler.io.in.valid <= io_control_ready_sizeHandler_io_in_w_5.valid @[MultiEnqueue.scala 85:10]
              io_control_ready_sizeHandler_io_in_w_5.ready <= sizeHandler.io.in.ready @[MultiEnqueue.scala 85:10]
              wire io_control_ready_sizeHandler_io_in_w_6 : {flip ready : UInt<1>, valid : UInt<1>, bits : {sel : UInt<1>, size : UInt<6>}} @[ReadyValid.scala 16:17]
              io_control_ready_sizeHandler_io_in_w_6.bits.size <= io_control_ready_w_6.size @[ReadyValid.scala 17:12]
              io_control_ready_sizeHandler_io_in_w_6.bits.sel <= io_control_ready_w_6.sel @[ReadyValid.scala 17:12]
              io_control_ready_sizeHandler_io_in_w_6.valid <= enqueuer2.io.out[1].valid @[ReadyValid.scala 18:13]
              enqueuer2.io.out[1].ready <= io_control_ready_sizeHandler_io_in_w_6.ready @[ReadyValid.scala 19:11]
              sizeHandler_2.io.in.bits.size <= io_control_ready_sizeHandler_io_in_w_6.bits.size @[MultiEnqueue.scala 86:10]
              sizeHandler_2.io.in.bits.sel <= io_control_ready_sizeHandler_io_in_w_6.bits.sel @[MultiEnqueue.scala 86:10]
              sizeHandler_2.io.in.valid <= io_control_ready_sizeHandler_io_in_w_6.valid @[MultiEnqueue.scala 86:10]
              io_control_ready_sizeHandler_io_in_w_6.ready <= sizeHandler_2.io.in.ready @[MultiEnqueue.scala 86:10]
              io.control.ready <= enqueuer2.io.in.ready @[LocalRouter.scala 151:19]
              skip @[LocalRouter.scala 150:5]
            else : @[LocalRouter.scala 158:15]
              io.control.ready <= UInt<1>("h01") @[LocalRouter.scala 159:19]
              skip @[LocalRouter.scala 158:15]
    
  module Mux_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2], flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2] @[Mux.scala 47:19]
    in[0].bits[0] <= io.in[0].bits[0] @[Mux.scala 47:19]
    in[0].bits[1] <= io.in[0].bits[1] @[Mux.scala 47:19]
    in[0].bits[2] <= io.in[0].bits[2] @[Mux.scala 47:19]
    in[0].bits[3] <= io.in[0].bits[3] @[Mux.scala 47:19]
    in[0].bits[4] <= io.in[0].bits[4] @[Mux.scala 47:19]
    in[0].bits[5] <= io.in[0].bits[5] @[Mux.scala 47:19]
    in[0].bits[6] <= io.in[0].bits[6] @[Mux.scala 47:19]
    in[0].bits[7] <= io.in[0].bits[7] @[Mux.scala 47:19]
    in[0].valid <= io.in[0].valid @[Mux.scala 47:19]
    io.in[0].ready <= in[0].ready @[Mux.scala 47:19]
    in[1].bits[0] <= io.in[1].bits[0] @[Mux.scala 47:19]
    in[1].bits[1] <= io.in[1].bits[1] @[Mux.scala 47:19]
    in[1].bits[2] <= io.in[1].bits[2] @[Mux.scala 47:19]
    in[1].bits[3] <= io.in[1].bits[3] @[Mux.scala 47:19]
    in[1].bits[4] <= io.in[1].bits[4] @[Mux.scala 47:19]
    in[1].bits[5] <= io.in[1].bits[5] @[Mux.scala 47:19]
    in[1].bits[6] <= io.in[1].bits[6] @[Mux.scala 47:19]
    in[1].bits[7] <= io.in[1].bits[7] @[Mux.scala 47:19]
    in[1].valid <= io.in[1].valid @[Mux.scala 47:19]
    io.in[1].ready <= in[1].ready @[Mux.scala 47:19]
    in[UInt<1>("h00")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    in[UInt<1>("h01")].ready <= UInt<1>("h00") @[Mux.scala 52:19]
    io.out.bits[0] <= in[io.sel.bits].bits[0] @[Mux.scala 57:15]
    io.out.bits[1] <= in[io.sel.bits].bits[1] @[Mux.scala 57:15]
    io.out.bits[2] <= in[io.sel.bits].bits[2] @[Mux.scala 57:15]
    io.out.bits[3] <= in[io.sel.bits].bits[3] @[Mux.scala 57:15]
    io.out.bits[4] <= in[io.sel.bits].bits[4] @[Mux.scala 57:15]
    io.out.bits[5] <= in[io.sel.bits].bits[5] @[Mux.scala 57:15]
    io.out.bits[6] <= in[io.sel.bits].bits[6] @[Mux.scala 57:15]
    io.out.bits[7] <= in[io.sel.bits].bits[7] @[Mux.scala 57:15]
    node _io_out_valid_T = and(io.sel.valid, in[io.sel.bits].valid) @[Mux.scala 58:29]
    io.out.valid <= _io_out_valid_T @[Mux.scala 58:16]
    node _io_sel_ready_T = and(in[io.sel.bits].valid, io.out.ready) @[Mux.scala 59:26]
    io.sel.ready <= _io_sel_ready_T @[Mux.scala 59:13]
    node _in_ready_T = and(io.sel.valid, io.out.ready) @[Mux.scala 60:26]
    in[io.sel.bits].ready <= _in_ready_T @[Mux.scala 60:13]
    
  module Demux_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip sel : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}[2]}
    
    wire _io_out_0_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_0_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[0] <= _io_out_0_bits_T @[package.scala 80:57]
    node _io_out_0_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[1] <= _io_out_0_bits_T_1 @[package.scala 80:57]
    node _io_out_0_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[2] <= _io_out_0_bits_T_2 @[package.scala 80:57]
    node _io_out_0_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[3] <= _io_out_0_bits_T_3 @[package.scala 80:57]
    node _io_out_0_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[4] <= _io_out_0_bits_T_4 @[package.scala 80:57]
    node _io_out_0_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[5] <= _io_out_0_bits_T_5 @[package.scala 80:57]
    node _io_out_0_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[6] <= _io_out_0_bits_T_6 @[package.scala 80:57]
    node _io_out_0_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_0_bits_WIRE[7] <= _io_out_0_bits_T_7 @[package.scala 80:57]
    io.out[0].bits[0] <= _io_out_0_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[0].bits[1] <= _io_out_0_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[0].bits[2] <= _io_out_0_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[0].bits[3] <= _io_out_0_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[0].bits[4] <= _io_out_0_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[0].bits[5] <= _io_out_0_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[0].bits[6] <= _io_out_0_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[0].bits[7] <= _io_out_0_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[0].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    wire _io_out_1_bits_WIRE : Fixed<16><<8>>[8] @[package.scala 80:57]
    node _io_out_1_bits_T = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[0] <= _io_out_1_bits_T @[package.scala 80:57]
    node _io_out_1_bits_T_1 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[1] <= _io_out_1_bits_T_1 @[package.scala 80:57]
    node _io_out_1_bits_T_2 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[2] <= _io_out_1_bits_T_2 @[package.scala 80:57]
    node _io_out_1_bits_T_3 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[3] <= _io_out_1_bits_T_3 @[package.scala 80:57]
    node _io_out_1_bits_T_4 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[4] <= _io_out_1_bits_T_4 @[package.scala 80:57]
    node _io_out_1_bits_T_5 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[5] <= _io_out_1_bits_T_5 @[package.scala 80:57]
    node _io_out_1_bits_T_6 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[6] <= _io_out_1_bits_T_6 @[package.scala 80:57]
    node _io_out_1_bits_T_7 = asFixedPoint(UInt<16>("h00"), 8) @[package.scala 80:57]
    _io_out_1_bits_WIRE[7] <= _io_out_1_bits_T_7 @[package.scala 80:57]
    io.out[1].bits[0] <= _io_out_1_bits_WIRE[0] @[Demux.scala 27:14]
    io.out[1].bits[1] <= _io_out_1_bits_WIRE[1] @[Demux.scala 27:14]
    io.out[1].bits[2] <= _io_out_1_bits_WIRE[2] @[Demux.scala 27:14]
    io.out[1].bits[3] <= _io_out_1_bits_WIRE[3] @[Demux.scala 27:14]
    io.out[1].bits[4] <= _io_out_1_bits_WIRE[4] @[Demux.scala 27:14]
    io.out[1].bits[5] <= _io_out_1_bits_WIRE[5] @[Demux.scala 27:14]
    io.out[1].bits[6] <= _io_out_1_bits_WIRE[6] @[Demux.scala 27:14]
    io.out[1].bits[7] <= _io_out_1_bits_WIRE[7] @[Demux.scala 27:14]
    io.out[1].valid <= UInt<1>("h00") @[Demux.scala 28:15]
    io.out[io.sel.bits].bits[0] <= io.in.bits[0] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[1] <= io.in.bits[1] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[2] <= io.in.bits[2] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[3] <= io.in.bits[3] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[4] <= io.in.bits[4] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[5] <= io.in.bits[5] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[6] <= io.in.bits[6] @[Demux.scala 32:12]
    io.out[io.sel.bits].bits[7] <= io.in.bits[7] @[Demux.scala 32:12]
    node _io_out_valid_T = and(io.sel.valid, io.in.valid) @[Demux.scala 33:26]
    io.out[io.sel.bits].valid <= _io_out_valid_T @[Demux.scala 33:13]
    node _io_sel_ready_T = and(io.in.valid, io.out[io.sel.bits].ready) @[Demux.scala 34:25]
    io.sel.ready <= _io_sel_ready_T @[Demux.scala 34:13]
    node _io_in_ready_T = and(io.sel.valid, io.out[io.sel.bits].ready) @[Demux.scala 35:25]
    io.in.ready <= _io_in_ready_T @[Demux.scala 35:12]
    
  module HostRouter : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {kind : UInt<2>}}, dram0 : {flip dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, dram1 : {flip dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, mem : {flip output : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, input : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}}
    
    inst dataIn_mux of Mux_3 @[Mux.scala 71:21]
    dataIn_mux.clock <= clock
    dataIn_mux.reset <= reset
    dataIn_mux.io.in[0].bits[0] <= io.dram0.dataIn.bits[0] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[1] <= io.dram0.dataIn.bits[1] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[2] <= io.dram0.dataIn.bits[2] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[3] <= io.dram0.dataIn.bits[3] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[4] <= io.dram0.dataIn.bits[4] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[5] <= io.dram0.dataIn.bits[5] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[6] <= io.dram0.dataIn.bits[6] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].bits[7] <= io.dram0.dataIn.bits[7] @[Mux.scala 79:18]
    dataIn_mux.io.in[0].valid <= io.dram0.dataIn.valid @[Mux.scala 79:18]
    io.dram0.dataIn.ready <= dataIn_mux.io.in[0].ready @[Mux.scala 79:18]
    dataIn_mux.io.in[1].bits[0] <= io.dram1.dataIn.bits[0] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[1] <= io.dram1.dataIn.bits[1] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[2] <= io.dram1.dataIn.bits[2] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[3] <= io.dram1.dataIn.bits[3] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[4] <= io.dram1.dataIn.bits[4] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[5] <= io.dram1.dataIn.bits[5] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[6] <= io.dram1.dataIn.bits[6] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].bits[7] <= io.dram1.dataIn.bits[7] @[Mux.scala 80:18]
    dataIn_mux.io.in[1].valid <= io.dram1.dataIn.valid @[Mux.scala 80:18]
    io.dram1.dataIn.ready <= dataIn_mux.io.in[1].ready @[Mux.scala 80:18]
    io.mem.input.bits[0] <= dataIn_mux.io.out.bits[0] @[Mux.scala 81:9]
    io.mem.input.bits[1] <= dataIn_mux.io.out.bits[1] @[Mux.scala 81:9]
    io.mem.input.bits[2] <= dataIn_mux.io.out.bits[2] @[Mux.scala 81:9]
    io.mem.input.bits[3] <= dataIn_mux.io.out.bits[3] @[Mux.scala 81:9]
    io.mem.input.bits[4] <= dataIn_mux.io.out.bits[4] @[Mux.scala 81:9]
    io.mem.input.bits[5] <= dataIn_mux.io.out.bits[5] @[Mux.scala 81:9]
    io.mem.input.bits[6] <= dataIn_mux.io.out.bits[6] @[Mux.scala 81:9]
    io.mem.input.bits[7] <= dataIn_mux.io.out.bits[7] @[Mux.scala 81:9]
    io.mem.input.valid <= dataIn_mux.io.out.valid @[Mux.scala 81:9]
    dataIn_mux.io.out.ready <= io.mem.input.ready @[Mux.scala 81:9]
    inst dataOut_demux of Demux_5 @[Demux.scala 46:23]
    dataOut_demux.clock <= clock
    dataOut_demux.reset <= reset
    dataOut_demux.io.in.bits[0] <= io.mem.output.bits[0] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[1] <= io.mem.output.bits[1] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[2] <= io.mem.output.bits[2] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[3] <= io.mem.output.bits[3] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[4] <= io.mem.output.bits[4] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[5] <= io.mem.output.bits[5] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[6] <= io.mem.output.bits[6] @[Demux.scala 54:17]
    dataOut_demux.io.in.bits[7] <= io.mem.output.bits[7] @[Demux.scala 54:17]
    dataOut_demux.io.in.valid <= io.mem.output.valid @[Demux.scala 54:17]
    io.mem.output.ready <= dataOut_demux.io.in.ready @[Demux.scala 54:17]
    io.dram0.dataOut.bits[0] <= dataOut_demux.io.out[0].bits[0] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[1] <= dataOut_demux.io.out[0].bits[1] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[2] <= dataOut_demux.io.out[0].bits[2] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[3] <= dataOut_demux.io.out[0].bits[3] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[4] <= dataOut_demux.io.out[0].bits[4] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[5] <= dataOut_demux.io.out[0].bits[5] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[6] <= dataOut_demux.io.out[0].bits[6] @[Demux.scala 55:10]
    io.dram0.dataOut.bits[7] <= dataOut_demux.io.out[0].bits[7] @[Demux.scala 55:10]
    io.dram0.dataOut.valid <= dataOut_demux.io.out[0].valid @[Demux.scala 55:10]
    dataOut_demux.io.out[0].ready <= io.dram0.dataOut.ready @[Demux.scala 55:10]
    io.dram1.dataOut.bits[0] <= dataOut_demux.io.out[1].bits[0] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[1] <= dataOut_demux.io.out[1].bits[1] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[2] <= dataOut_demux.io.out[1].bits[2] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[3] <= dataOut_demux.io.out[1].bits[3] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[4] <= dataOut_demux.io.out[1].bits[4] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[5] <= dataOut_demux.io.out[1].bits[5] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[6] <= dataOut_demux.io.out[1].bits[6] @[Demux.scala 56:10]
    io.dram1.dataOut.bits[7] <= dataOut_demux.io.out[1].bits[7] @[Demux.scala 56:10]
    io.dram1.dataOut.valid <= dataOut_demux.io.out[1].valid @[Demux.scala 56:10]
    dataOut_demux.io.out[1].ready <= io.dram1.dataOut.ready @[Demux.scala 56:10]
    node _isDataIn_T = eq(io.control.bits.kind, UInt<1>("h00")) @[HostRouter.scala 57:10]
    node _isDataIn_T_1 = eq(io.control.bits.kind, UInt<2>("h02")) @[HostRouter.scala 57:26]
    node isDataIn = or(_isDataIn_T, _isDataIn_T_1) @[HostRouter.scala 57:18]
    node _isDataOut_T = eq(io.control.bits.kind, UInt<1>("h01")) @[HostRouter.scala 61:10]
    node _isDataOut_T_1 = eq(io.control.bits.kind, UInt<2>("h03")) @[HostRouter.scala 61:27]
    node isDataOut = or(_isDataOut_T, _isDataOut_T_1) @[HostRouter.scala 61:19]
    node _io_control_ready_T = and(isDataIn, dataIn_mux.io.sel.ready) @[HostRouter.scala 41:30]
    node _io_control_ready_T_1 = and(isDataOut, dataOut_demux.io.sel.ready) @[HostRouter.scala 41:61]
    node _io_control_ready_T_2 = or(_io_control_ready_T, _io_control_ready_T_1) @[HostRouter.scala 41:47]
    io.control.ready <= _io_control_ready_T_2 @[HostRouter.scala 41:17]
    node _mux_io_sel_valid_T = and(io.control.valid, isDataIn) @[HostRouter.scala 43:33]
    dataIn_mux.io.sel.valid <= _mux_io_sel_valid_T @[HostRouter.scala 43:16]
    node _mux_io_sel_bits_T = bits(io.control.bits.kind, 1, 1) @[HostRouter.scala 44:35]
    dataIn_mux.io.sel.bits <= _mux_io_sel_bits_T @[HostRouter.scala 44:15]
    node _demux_io_sel_valid_T = and(io.control.valid, isDataOut) @[HostRouter.scala 46:34]
    dataOut_demux.io.sel.valid <= _demux_io_sel_valid_T @[HostRouter.scala 46:17]
    node _demux_io_sel_bits_T = bits(io.control.bits.kind, 1, 1) @[HostRouter.scala 47:36]
    dataOut_demux.io.sel.bits <= _demux_io_sel_bits_T @[HostRouter.scala 47:16]
    
  module Queue_26 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {instruction : {op : UInt<4>, sourceLeft : UInt<1>, sourceRight : UInt<1>, dest : UInt<1>}, readAddress : UInt<6>, writeAddress : UInt<6>, accumulate : UInt<1>, write : UInt<1>, read : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.read <= io.enq.bits.read @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      MPORT.accumulate <= io.enq.bits.accumulate @[Decoupled.scala 230:24]
      MPORT.writeAddress <= io.enq.bits.writeAddress @[Decoupled.scala 230:24]
      MPORT.readAddress <= io.enq.bits.readAddress @[Decoupled.scala 230:24]
      MPORT.instruction.dest <= io.enq.bits.instruction.dest @[Decoupled.scala 230:24]
      MPORT.instruction.sourceRight <= io.enq.bits.instruction.sourceRight @[Decoupled.scala 230:24]
      MPORT.instruction.sourceLeft <= io.enq.bits.instruction.sourceLeft @[Decoupled.scala 230:24]
      MPORT.instruction.op <= io.enq.bits.instruction.op @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.read <= io_deq_bits_MPORT.read @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    io.deq.bits.accumulate <= io_deq_bits_MPORT.accumulate @[Decoupled.scala 242:15]
    io.deq.bits.writeAddress <= io_deq_bits_MPORT.writeAddress @[Decoupled.scala 242:15]
    io.deq.bits.readAddress <= io_deq_bits_MPORT.readAddress @[Decoupled.scala 242:15]
    io.deq.bits.instruction.dest <= io_deq_bits_MPORT.instruction.dest @[Decoupled.scala 242:15]
    io.deq.bits.instruction.sourceRight <= io_deq_bits_MPORT.instruction.sourceRight @[Decoupled.scala 242:15]
    io.deq.bits.instruction.sourceLeft <= io_deq_bits_MPORT.instruction.sourceLeft @[Decoupled.scala 242:15]
    io.deq.bits.instruction.op <= io_deq_bits_MPORT.instruction.op @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_27 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {load : UInt<1>, zeroes : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {load : UInt<1>, zeroes : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.zeroes <= io.enq.bits.zeroes @[Decoupled.scala 230:24]
      MPORT.load <= io.enq.bits.load @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.zeroes <= io_deq_bits_MPORT.zeroes @[Decoupled.scala 242:15]
    io.deq.bits.load <= io_deq_bits_MPORT.load @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module TCU : 
    input clock : Clock
    input reset : Reset
    output io : {flip instruction : {flip ready : UInt<1>, valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}, status : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}}, dram0 : {control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, flip dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, dram1 : {control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, flip dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, config : {dram0AddressOffset : UInt<32>, dram0CacheBehaviour : UInt<4>, dram1AddressOffset : UInt<32>, dram1CacheBehaviour : UInt<4>}, timeout : UInt<1>, error : UInt<1>, tracepoint : UInt<1>, programCounter : UInt<32>, sample : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {flags : {instruction : {ready : UInt<1>, valid : UInt<1>}, memPortA : {ready : UInt<1>, valid : UInt<1>}, memPortB : {ready : UInt<1>, valid : UInt<1>}, dram0 : {ready : UInt<1>, valid : UInt<1>}, dram1 : {ready : UInt<1>, valid : UInt<1>}, dataflow : {ready : UInt<1>, valid : UInt<1>}, acc : {ready : UInt<1>, valid : UInt<1>}, array : {ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}}
    
    inst decoder of Decoder @[TCU.scala 62:23]
    decoder.clock <= clock
    decoder.reset <= reset
    inst array of SystolicArray @[TCU.scala 63:21]
    array.clock <= clock
    array.reset <= reset
    inst acc of AccumulatorWithALUArray @[TCU.scala 66:19]
    acc.clock <= clock
    acc.reset <= reset
    inst mem of DualPortMem_1 @[TCU.scala 69:19]
    mem.clock <= clock
    mem.reset <= reset
    inst router of LocalRouter @[TCU.scala 77:22]
    router.clock <= clock
    router.reset <= reset
    inst hostRouter of HostRouter @[TCU.scala 84:26]
    hostRouter.clock <= clock
    hostRouter.reset <= reset
    decoder.io.instruction.bits.arguments <= io.instruction.bits.arguments @[TCU.scala 94:26]
    decoder.io.instruction.bits.flags <= io.instruction.bits.flags @[TCU.scala 94:26]
    decoder.io.instruction.bits.opcode <= io.instruction.bits.opcode @[TCU.scala 94:26]
    decoder.io.instruction.valid <= io.instruction.valid @[TCU.scala 94:26]
    io.instruction.ready <= decoder.io.instruction.ready @[TCU.scala 94:26]
    io.status.bits.bits.arguments <= decoder.io.status.bits.bits.arguments @[TCU.scala 95:13]
    io.status.bits.bits.flags <= decoder.io.status.bits.bits.flags @[TCU.scala 95:13]
    io.status.bits.bits.opcode <= decoder.io.status.bits.bits.opcode @[TCU.scala 95:13]
    io.status.bits.last <= decoder.io.status.bits.last @[TCU.scala 95:13]
    io.status.valid <= decoder.io.status.valid @[TCU.scala 95:13]
    decoder.io.status.ready <= io.status.ready @[TCU.scala 95:13]
    io.dram0.control.bits.size <= decoder.io.dram0.bits.size @[TCU.scala 96:20]
    io.dram0.control.bits.address <= decoder.io.dram0.bits.address @[TCU.scala 96:20]
    io.dram0.control.bits.write <= decoder.io.dram0.bits.write @[TCU.scala 96:20]
    io.dram0.control.valid <= decoder.io.dram0.valid @[TCU.scala 96:20]
    decoder.io.dram0.ready <= io.dram0.control.ready @[TCU.scala 96:20]
    io.dram1.control.bits.size <= decoder.io.dram1.bits.size @[TCU.scala 97:20]
    io.dram1.control.bits.address <= decoder.io.dram1.bits.address @[TCU.scala 97:20]
    io.dram1.control.bits.write <= decoder.io.dram1.bits.write @[TCU.scala 97:20]
    io.dram1.control.valid <= decoder.io.dram1.valid @[TCU.scala 97:20]
    decoder.io.dram1.ready <= io.dram1.control.ready @[TCU.scala 97:20]
    io.config.dram1CacheBehaviour <= decoder.io.config.dram1CacheBehaviour @[TCU.scala 98:13]
    io.config.dram1AddressOffset <= decoder.io.config.dram1AddressOffset @[TCU.scala 98:13]
    io.config.dram0CacheBehaviour <= decoder.io.config.dram0CacheBehaviour @[TCU.scala 98:13]
    io.config.dram0AddressOffset <= decoder.io.config.dram0AddressOffset @[TCU.scala 98:13]
    io.timeout <= decoder.io.timeout @[TCU.scala 99:14]
    io.error <= decoder.io.error @[TCU.scala 100:12]
    io.tracepoint <= decoder.io.tracepoint @[TCU.scala 101:17]
    io.programCounter <= decoder.io.programCounter @[TCU.scala 102:21]
    io.sample.bits.bits.programCounter <= decoder.io.sample.bits.bits.programCounter @[TCU.scala 103:13]
    io.sample.bits.bits.flags.array.valid <= decoder.io.sample.bits.bits.flags.array.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.array.ready <= decoder.io.sample.bits.bits.flags.array.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.acc.valid <= decoder.io.sample.bits.bits.flags.acc.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.acc.ready <= decoder.io.sample.bits.bits.flags.acc.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dataflow.valid <= decoder.io.sample.bits.bits.flags.dataflow.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dataflow.ready <= decoder.io.sample.bits.bits.flags.dataflow.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dram1.valid <= decoder.io.sample.bits.bits.flags.dram1.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dram1.ready <= decoder.io.sample.bits.bits.flags.dram1.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dram0.valid <= decoder.io.sample.bits.bits.flags.dram0.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.dram0.ready <= decoder.io.sample.bits.bits.flags.dram0.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.memPortB.valid <= decoder.io.sample.bits.bits.flags.memPortB.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.memPortB.ready <= decoder.io.sample.bits.bits.flags.memPortB.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.memPortA.valid <= decoder.io.sample.bits.bits.flags.memPortA.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.memPortA.ready <= decoder.io.sample.bits.bits.flags.memPortA.ready @[TCU.scala 103:13]
    io.sample.bits.bits.flags.instruction.valid <= decoder.io.sample.bits.bits.flags.instruction.valid @[TCU.scala 103:13]
    io.sample.bits.bits.flags.instruction.ready <= decoder.io.sample.bits.bits.flags.instruction.ready @[TCU.scala 103:13]
    io.sample.bits.last <= decoder.io.sample.bits.last @[TCU.scala 103:13]
    io.sample.valid <= decoder.io.sample.valid @[TCU.scala 103:13]
    decoder.io.sample.ready <= io.sample.ready @[TCU.scala 103:13]
    decoder.io.nooped.ready <= UInt<1>("h01") @[TCU.scala 104:27]
    decoder.io.skipped.ready <= UInt<1>("h01") @[TCU.scala 105:28]
    inst acc_io_control_q of Queue_26 @[TCU.scala 107:39]
    acc_io_control_q.clock <= clock
    acc_io_control_q.reset <= reset
    acc_io_control_q.io.enq.bits.read <= decoder.io.acc.bits.read @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.write <= decoder.io.acc.bits.write @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.accumulate <= decoder.io.acc.bits.accumulate @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.writeAddress <= decoder.io.acc.bits.writeAddress @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.readAddress <= decoder.io.acc.bits.readAddress @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.instruction.dest <= decoder.io.acc.bits.instruction.dest @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.instruction.sourceRight <= decoder.io.acc.bits.instruction.sourceRight @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.instruction.sourceLeft <= decoder.io.acc.bits.instruction.sourceLeft @[TCU.scala 107:39]
    acc_io_control_q.io.enq.bits.instruction.op <= decoder.io.acc.bits.instruction.op @[TCU.scala 107:39]
    acc_io_control_q.io.enq.valid <= decoder.io.acc.valid @[TCU.scala 107:39]
    decoder.io.acc.ready <= acc_io_control_q.io.enq.ready @[TCU.scala 107:39]
    acc.io.control.bits.read <= acc_io_control_q.io.deq.bits.read @[TCU.scala 107:18]
    acc.io.control.bits.write <= acc_io_control_q.io.deq.bits.write @[TCU.scala 107:18]
    acc.io.control.bits.accumulate <= acc_io_control_q.io.deq.bits.accumulate @[TCU.scala 107:18]
    acc.io.control.bits.writeAddress <= acc_io_control_q.io.deq.bits.writeAddress @[TCU.scala 107:18]
    acc.io.control.bits.readAddress <= acc_io_control_q.io.deq.bits.readAddress @[TCU.scala 107:18]
    acc.io.control.bits.instruction.dest <= acc_io_control_q.io.deq.bits.instruction.dest @[TCU.scala 107:18]
    acc.io.control.bits.instruction.sourceRight <= acc_io_control_q.io.deq.bits.instruction.sourceRight @[TCU.scala 107:18]
    acc.io.control.bits.instruction.sourceLeft <= acc_io_control_q.io.deq.bits.instruction.sourceLeft @[TCU.scala 107:18]
    acc.io.control.bits.instruction.op <= acc_io_control_q.io.deq.bits.instruction.op @[TCU.scala 107:18]
    acc.io.control.valid <= acc_io_control_q.io.deq.valid @[TCU.scala 107:18]
    acc_io_control_q.io.deq.ready <= acc.io.control.ready @[TCU.scala 107:18]
    acc.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 108:21]
    acc.io.programCounter <= decoder.io.programCounter @[TCU.scala 109:25]
    acc.io.nooped.ready <= UInt<1>("h01") @[TCU.scala 110:23]
    acc.io.computed.ready <= UInt<1>("h01") @[TCU.scala 111:25]
    acc.io.wrote.ready <= UInt<1>("h01") @[TCU.scala 112:22]
    inst array_io_control_q of Queue_27 @[TCU.scala 114:41]
    array_io_control_q.clock <= clock
    array_io_control_q.reset <= reset
    array_io_control_q.io.enq.bits.zeroes <= decoder.io.array.bits.zeroes @[TCU.scala 114:41]
    array_io_control_q.io.enq.bits.load <= decoder.io.array.bits.load @[TCU.scala 114:41]
    array_io_control_q.io.enq.valid <= decoder.io.array.valid @[TCU.scala 114:41]
    decoder.io.array.ready <= array_io_control_q.io.enq.ready @[TCU.scala 114:41]
    array.io.control.bits.zeroes <= array_io_control_q.io.deq.bits.zeroes @[TCU.scala 114:20]
    array.io.control.bits.load <= array_io_control_q.io.deq.bits.load @[TCU.scala 114:20]
    array.io.control.valid <= array_io_control_q.io.deq.valid @[TCU.scala 114:20]
    array_io_control_q.io.deq.ready <= array.io.control.ready @[TCU.scala 114:20]
    array.io.loaded.ready <= UInt<1>("h01") @[TCU.scala 115:25]
    array.io.ran.ready <= UInt<1>("h01") @[TCU.scala 116:22]
    mem.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 119:21]
    mem.io.programCounter <= decoder.io.programCounter @[TCU.scala 120:25]
    mem.io.portA.control.bits.size <= decoder.io.memPortA.bits.size @[TCU.scala 121:17]
    mem.io.portA.control.bits.address <= decoder.io.memPortA.bits.address @[TCU.scala 121:17]
    mem.io.portA.control.bits.write <= decoder.io.memPortA.bits.write @[TCU.scala 121:17]
    mem.io.portA.control.valid <= decoder.io.memPortA.valid @[TCU.scala 121:17]
    decoder.io.memPortA.ready <= mem.io.portA.control.ready @[TCU.scala 121:17]
    mem.io.portA.status.ready <= UInt<1>("h01") @[TCU.scala 122:22]
    mem.io.portA.inputStatus.ready <= UInt<1>("h01") @[TCU.scala 123:27]
    mem.io.portA.wrote.ready <= UInt<1>("h01") @[TCU.scala 124:21]
    router.io.timeout <= decoder.io.timeout @[TCU.scala 126:21]
    router.io.tracepoint <= decoder.io.tracepoint @[TCU.scala 127:24]
    router.io.programCounter <= decoder.io.programCounter @[TCU.scala 128:28]
    router.io.control.bits.size <= decoder.io.dataflow.bits.size @[TCU.scala 130:21]
    router.io.control.bits.kind <= decoder.io.dataflow.bits.kind @[TCU.scala 130:21]
    router.io.control.valid <= decoder.io.dataflow.valid @[TCU.scala 130:21]
    decoder.io.dataflow.ready <= router.io.control.ready @[TCU.scala 130:21]
    router.io.mem.output.bits[0] <= mem.io.portA.output.bits[0] @[TCU.scala 132:24]
    router.io.mem.output.bits[1] <= mem.io.portA.output.bits[1] @[TCU.scala 132:24]
    router.io.mem.output.bits[2] <= mem.io.portA.output.bits[2] @[TCU.scala 132:24]
    router.io.mem.output.bits[3] <= mem.io.portA.output.bits[3] @[TCU.scala 132:24]
    router.io.mem.output.bits[4] <= mem.io.portA.output.bits[4] @[TCU.scala 132:24]
    router.io.mem.output.bits[5] <= mem.io.portA.output.bits[5] @[TCU.scala 132:24]
    router.io.mem.output.bits[6] <= mem.io.portA.output.bits[6] @[TCU.scala 132:24]
    router.io.mem.output.bits[7] <= mem.io.portA.output.bits[7] @[TCU.scala 132:24]
    router.io.mem.output.valid <= mem.io.portA.output.valid @[TCU.scala 132:24]
    mem.io.portA.output.ready <= router.io.mem.output.ready @[TCU.scala 132:24]
    mem.io.portA.input.bits[0] <= router.io.mem.input.bits[0] @[TCU.scala 133:15]
    mem.io.portA.input.bits[1] <= router.io.mem.input.bits[1] @[TCU.scala 133:15]
    mem.io.portA.input.bits[2] <= router.io.mem.input.bits[2] @[TCU.scala 133:15]
    mem.io.portA.input.bits[3] <= router.io.mem.input.bits[3] @[TCU.scala 133:15]
    mem.io.portA.input.bits[4] <= router.io.mem.input.bits[4] @[TCU.scala 133:15]
    mem.io.portA.input.bits[5] <= router.io.mem.input.bits[5] @[TCU.scala 133:15]
    mem.io.portA.input.bits[6] <= router.io.mem.input.bits[6] @[TCU.scala 133:15]
    mem.io.portA.input.bits[7] <= router.io.mem.input.bits[7] @[TCU.scala 133:15]
    mem.io.portA.input.valid <= router.io.mem.input.valid @[TCU.scala 133:15]
    router.io.mem.input.ready <= mem.io.portA.input.ready @[TCU.scala 133:15]
    array.io.input.bits[0] <= router.io.array.input.bits[0] @[TCU.scala 135:18]
    array.io.input.bits[1] <= router.io.array.input.bits[1] @[TCU.scala 135:18]
    array.io.input.bits[2] <= router.io.array.input.bits[2] @[TCU.scala 135:18]
    array.io.input.bits[3] <= router.io.array.input.bits[3] @[TCU.scala 135:18]
    array.io.input.bits[4] <= router.io.array.input.bits[4] @[TCU.scala 135:18]
    array.io.input.bits[5] <= router.io.array.input.bits[5] @[TCU.scala 135:18]
    array.io.input.bits[6] <= router.io.array.input.bits[6] @[TCU.scala 135:18]
    array.io.input.bits[7] <= router.io.array.input.bits[7] @[TCU.scala 135:18]
    array.io.input.valid <= router.io.array.input.valid @[TCU.scala 135:18]
    router.io.array.input.ready <= array.io.input.ready @[TCU.scala 135:18]
    router.io.array.output.bits[0] <= array.io.output.bits[0] @[TCU.scala 136:26]
    router.io.array.output.bits[1] <= array.io.output.bits[1] @[TCU.scala 136:26]
    router.io.array.output.bits[2] <= array.io.output.bits[2] @[TCU.scala 136:26]
    router.io.array.output.bits[3] <= array.io.output.bits[3] @[TCU.scala 136:26]
    router.io.array.output.bits[4] <= array.io.output.bits[4] @[TCU.scala 136:26]
    router.io.array.output.bits[5] <= array.io.output.bits[5] @[TCU.scala 136:26]
    router.io.array.output.bits[6] <= array.io.output.bits[6] @[TCU.scala 136:26]
    router.io.array.output.bits[7] <= array.io.output.bits[7] @[TCU.scala 136:26]
    router.io.array.output.valid <= array.io.output.valid @[TCU.scala 136:26]
    array.io.output.ready <= router.io.array.output.ready @[TCU.scala 136:26]
    array.io.weight.bits[0] <= router.io.array.weightInput.bits[0] @[TCU.scala 137:19]
    array.io.weight.bits[1] <= router.io.array.weightInput.bits[1] @[TCU.scala 137:19]
    array.io.weight.bits[2] <= router.io.array.weightInput.bits[2] @[TCU.scala 137:19]
    array.io.weight.bits[3] <= router.io.array.weightInput.bits[3] @[TCU.scala 137:19]
    array.io.weight.bits[4] <= router.io.array.weightInput.bits[4] @[TCU.scala 137:19]
    array.io.weight.bits[5] <= router.io.array.weightInput.bits[5] @[TCU.scala 137:19]
    array.io.weight.bits[6] <= router.io.array.weightInput.bits[6] @[TCU.scala 137:19]
    array.io.weight.bits[7] <= router.io.array.weightInput.bits[7] @[TCU.scala 137:19]
    array.io.weight.valid <= router.io.array.weightInput.valid @[TCU.scala 137:19]
    router.io.array.weightInput.ready <= array.io.weight.ready @[TCU.scala 137:19]
    acc.io.input.bits[0] <= router.io.acc.input.bits[0] @[TCU.scala 139:16]
    acc.io.input.bits[1] <= router.io.acc.input.bits[1] @[TCU.scala 139:16]
    acc.io.input.bits[2] <= router.io.acc.input.bits[2] @[TCU.scala 139:16]
    acc.io.input.bits[3] <= router.io.acc.input.bits[3] @[TCU.scala 139:16]
    acc.io.input.bits[4] <= router.io.acc.input.bits[4] @[TCU.scala 139:16]
    acc.io.input.bits[5] <= router.io.acc.input.bits[5] @[TCU.scala 139:16]
    acc.io.input.bits[6] <= router.io.acc.input.bits[6] @[TCU.scala 139:16]
    acc.io.input.bits[7] <= router.io.acc.input.bits[7] @[TCU.scala 139:16]
    acc.io.input.valid <= router.io.acc.input.valid @[TCU.scala 139:16]
    router.io.acc.input.ready <= acc.io.input.ready @[TCU.scala 139:16]
    router.io.acc.output.bits[0] <= acc.io.output.bits[0] @[TCU.scala 140:24]
    router.io.acc.output.bits[1] <= acc.io.output.bits[1] @[TCU.scala 140:24]
    router.io.acc.output.bits[2] <= acc.io.output.bits[2] @[TCU.scala 140:24]
    router.io.acc.output.bits[3] <= acc.io.output.bits[3] @[TCU.scala 140:24]
    router.io.acc.output.bits[4] <= acc.io.output.bits[4] @[TCU.scala 140:24]
    router.io.acc.output.bits[5] <= acc.io.output.bits[5] @[TCU.scala 140:24]
    router.io.acc.output.bits[6] <= acc.io.output.bits[6] @[TCU.scala 140:24]
    router.io.acc.output.bits[7] <= acc.io.output.bits[7] @[TCU.scala 140:24]
    router.io.acc.output.valid <= acc.io.output.valid @[TCU.scala 140:24]
    acc.io.output.ready <= router.io.acc.output.ready @[TCU.scala 140:24]
    hostRouter.io.control.bits.kind <= decoder.io.hostDataflow.bits.kind @[TCU.scala 143:25]
    hostRouter.io.control.valid <= decoder.io.hostDataflow.valid @[TCU.scala 143:25]
    decoder.io.hostDataflow.ready <= hostRouter.io.control.ready @[TCU.scala 143:25]
    mem.io.portB.control.bits.size <= decoder.io.memPortB.bits.size @[TCU.scala 145:17]
    mem.io.portB.control.bits.address <= decoder.io.memPortB.bits.address @[TCU.scala 145:17]
    mem.io.portB.control.bits.write <= decoder.io.memPortB.bits.write @[TCU.scala 145:17]
    mem.io.portB.control.valid <= decoder.io.memPortB.valid @[TCU.scala 145:17]
    decoder.io.memPortB.ready <= mem.io.portB.control.ready @[TCU.scala 145:17]
    mem.io.portB.input.bits[0] <= hostRouter.io.mem.input.bits[0] @[TCU.scala 146:15]
    mem.io.portB.input.bits[1] <= hostRouter.io.mem.input.bits[1] @[TCU.scala 146:15]
    mem.io.portB.input.bits[2] <= hostRouter.io.mem.input.bits[2] @[TCU.scala 146:15]
    mem.io.portB.input.bits[3] <= hostRouter.io.mem.input.bits[3] @[TCU.scala 146:15]
    mem.io.portB.input.bits[4] <= hostRouter.io.mem.input.bits[4] @[TCU.scala 146:15]
    mem.io.portB.input.bits[5] <= hostRouter.io.mem.input.bits[5] @[TCU.scala 146:15]
    mem.io.portB.input.bits[6] <= hostRouter.io.mem.input.bits[6] @[TCU.scala 146:15]
    mem.io.portB.input.bits[7] <= hostRouter.io.mem.input.bits[7] @[TCU.scala 146:15]
    mem.io.portB.input.valid <= hostRouter.io.mem.input.valid @[TCU.scala 146:15]
    hostRouter.io.mem.input.ready <= mem.io.portB.input.ready @[TCU.scala 146:15]
    hostRouter.io.mem.output.bits[0] <= mem.io.portB.output.bits[0] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[1] <= mem.io.portB.output.bits[1] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[2] <= mem.io.portB.output.bits[2] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[3] <= mem.io.portB.output.bits[3] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[4] <= mem.io.portB.output.bits[4] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[5] <= mem.io.portB.output.bits[5] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[6] <= mem.io.portB.output.bits[6] @[TCU.scala 147:28]
    hostRouter.io.mem.output.bits[7] <= mem.io.portB.output.bits[7] @[TCU.scala 147:28]
    hostRouter.io.mem.output.valid <= mem.io.portB.output.valid @[TCU.scala 147:28]
    mem.io.portB.output.ready <= hostRouter.io.mem.output.ready @[TCU.scala 147:28]
    mem.io.portB.status.ready <= UInt<1>("h01") @[TCU.scala 148:22]
    mem.io.portB.inputStatus.ready <= UInt<1>("h01") @[TCU.scala 149:27]
    mem.io.portB.wrote.ready <= UInt<1>("h01") @[TCU.scala 150:21]
    hostRouter.io.dram0.dataIn.bits[0] <= io.dram0.dataIn.bits[0] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[1] <= io.dram0.dataIn.bits[1] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[2] <= io.dram0.dataIn.bits[2] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[3] <= io.dram0.dataIn.bits[3] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[4] <= io.dram0.dataIn.bits[4] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[5] <= io.dram0.dataIn.bits[5] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[6] <= io.dram0.dataIn.bits[6] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.bits[7] <= io.dram0.dataIn.bits[7] @[TCU.scala 152:30]
    hostRouter.io.dram0.dataIn.valid <= io.dram0.dataIn.valid @[TCU.scala 152:30]
    io.dram0.dataIn.ready <= hostRouter.io.dram0.dataIn.ready @[TCU.scala 152:30]
    io.dram0.dataOut.bits[0] <= hostRouter.io.dram0.dataOut.bits[0] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[1] <= hostRouter.io.dram0.dataOut.bits[1] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[2] <= hostRouter.io.dram0.dataOut.bits[2] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[3] <= hostRouter.io.dram0.dataOut.bits[3] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[4] <= hostRouter.io.dram0.dataOut.bits[4] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[5] <= hostRouter.io.dram0.dataOut.bits[5] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[6] <= hostRouter.io.dram0.dataOut.bits[6] @[TCU.scala 153:20]
    io.dram0.dataOut.bits[7] <= hostRouter.io.dram0.dataOut.bits[7] @[TCU.scala 153:20]
    io.dram0.dataOut.valid <= hostRouter.io.dram0.dataOut.valid @[TCU.scala 153:20]
    hostRouter.io.dram0.dataOut.ready <= io.dram0.dataOut.ready @[TCU.scala 153:20]
    hostRouter.io.dram1.dataIn.bits[0] <= io.dram1.dataIn.bits[0] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[1] <= io.dram1.dataIn.bits[1] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[2] <= io.dram1.dataIn.bits[2] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[3] <= io.dram1.dataIn.bits[3] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[4] <= io.dram1.dataIn.bits[4] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[5] <= io.dram1.dataIn.bits[5] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[6] <= io.dram1.dataIn.bits[6] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.bits[7] <= io.dram1.dataIn.bits[7] @[TCU.scala 155:30]
    hostRouter.io.dram1.dataIn.valid <= io.dram1.dataIn.valid @[TCU.scala 155:30]
    io.dram1.dataIn.ready <= hostRouter.io.dram1.dataIn.ready @[TCU.scala 155:30]
    io.dram1.dataOut.bits[0] <= hostRouter.io.dram1.dataOut.bits[0] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[1] <= hostRouter.io.dram1.dataOut.bits[1] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[2] <= hostRouter.io.dram1.dataOut.bits[2] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[3] <= hostRouter.io.dram1.dataOut.bits[3] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[4] <= hostRouter.io.dram1.dataOut.bits[4] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[5] <= hostRouter.io.dram1.dataOut.bits[5] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[6] <= hostRouter.io.dram1.dataOut.bits[6] @[TCU.scala 156:20]
    io.dram1.dataOut.bits[7] <= hostRouter.io.dram1.dataOut.bits[7] @[TCU.scala 156:20]
    io.dram1.dataOut.valid <= hostRouter.io.dram1.dataOut.valid @[TCU.scala 156:20]
    hostRouter.io.dram1.dataOut.ready <= io.dram1.dataOut.ready @[TCU.scala 156:20]
    
  module Queue_28 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}
    
    cmem ram : UInt<8>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_29 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}
    
    cmem ram : UInt<8>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_30 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Counter_10 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module BurstSplitter : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    
    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_10 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h01") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
      skip @[MemBoundarySplitter.scala 45:51]
    else : @[MemBoundarySplitter.scala 49:15]
      io.out.bits.last <= UInt<1>("h00") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h00") @[MemBoundarySplitter.scala 52:22]
      skip @[MemBoundarySplitter.scala 49:15]
    
  module Counter_11 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module BurstSplitter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}}
    
    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.strb <= io.in.bits.strb @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_11 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h01") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
      skip @[MemBoundarySplitter.scala 45:51]
    else : @[MemBoundarySplitter.scala 49:15]
      io.out.bits.last <= UInt<1>("h00") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h00") @[MemBoundarySplitter.scala 52:22]
      skip @[MemBoundarySplitter.scala 49:15]
    
  module Filter : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}}
    
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 69:15]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 69:15]
    when io.control.bits : @[MemBoundarySplitter.scala 71:25]
      node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 72:38]
      io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 72:18]
      node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 73:37]
      io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 73:17]
      node _io_control_ready_T = and(io.in.valid, io.out.ready) @[MemBoundarySplitter.scala 74:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 74:22]
      skip @[MemBoundarySplitter.scala 71:25]
    else : @[MemBoundarySplitter.scala 75:15]
      io.out.valid <= UInt<1>("h00") @[MemBoundarySplitter.scala 76:18]
      io.in.ready <= io.control.valid @[MemBoundarySplitter.scala 77:17]
      io.control.ready <= io.in.valid @[MemBoundarySplitter.scala 78:22]
      skip @[MemBoundarySplitter.scala 75:15]
    
  module MultiEnqueue_16 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_17 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[3]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MemBoundarySplitter : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}
    
    inst readDataQueue of Queue_28 @[MemBoundarySplitter.scala 111:29]
    readDataQueue.clock <= clock
    readDataQueue.reset <= reset
    inst writeDataQueue of Queue_29 @[MemBoundarySplitter.scala 114:30]
    writeDataQueue.clock <= clock
    writeDataQueue.reset <= reset
    inst writeResponseQueue of Queue_30 @[MemBoundarySplitter.scala 117:34]
    writeResponseQueue.clock <= clock
    writeResponseQueue.reset <= reset
    inst readMerger of BurstSplitter @[MemBoundarySplitter.scala 121:26]
    readMerger.clock <= clock
    readMerger.reset <= reset
    readMerger.io.control.bits <= readDataQueue.io.deq.bits @[MemBoundarySplitter.scala 122:25]
    readMerger.io.control.valid <= readDataQueue.io.deq.valid @[MemBoundarySplitter.scala 122:25]
    readDataQueue.io.deq.ready <= readMerger.io.control.ready @[MemBoundarySplitter.scala 122:25]
    readMerger.io.in.bits.last <= io.out.readData.bits.last @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.resp <= io.out.readData.bits.resp @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.data <= io.out.readData.bits.data @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.id <= io.out.readData.bits.id @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.valid <= io.out.readData.valid @[MemBoundarySplitter.scala 123:20]
    io.out.readData.ready <= readMerger.io.in.ready @[MemBoundarySplitter.scala 123:20]
    io.in.readData.bits.last <= readMerger.io.out.bits.last @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.resp <= readMerger.io.out.bits.resp @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.data <= readMerger.io.out.bits.data @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.id <= readMerger.io.out.bits.id @[MemBoundarySplitter.scala 124:18]
    io.in.readData.valid <= readMerger.io.out.valid @[MemBoundarySplitter.scala 124:18]
    readMerger.io.out.ready <= io.in.readData.ready @[MemBoundarySplitter.scala 124:18]
    inst writeSplitter of BurstSplitter_1 @[MemBoundarySplitter.scala 125:29]
    writeSplitter.clock <= clock
    writeSplitter.reset <= reset
    writeSplitter.io.control.bits <= writeDataQueue.io.deq.bits @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.control.valid <= writeDataQueue.io.deq.valid @[MemBoundarySplitter.scala 126:28]
    writeDataQueue.io.deq.ready <= writeSplitter.io.control.ready @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.in.bits.last <= io.in.writeData.bits.last @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.strb <= io.in.writeData.bits.strb @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.data <= io.in.writeData.bits.data @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.id <= io.in.writeData.bits.id @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.valid <= io.in.writeData.valid @[MemBoundarySplitter.scala 127:23]
    io.in.writeData.ready <= writeSplitter.io.in.ready @[MemBoundarySplitter.scala 127:23]
    io.out.writeData.bits.last <= writeSplitter.io.out.bits.last @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.strb <= writeSplitter.io.out.bits.strb @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.data <= writeSplitter.io.out.bits.data @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.id <= writeSplitter.io.out.bits.id @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.valid <= writeSplitter.io.out.valid @[MemBoundarySplitter.scala 128:20]
    writeSplitter.io.out.ready <= io.out.writeData.ready @[MemBoundarySplitter.scala 128:20]
    inst writeResponseFilter of Filter @[MemBoundarySplitter.scala 129:35]
    writeResponseFilter.clock <= clock
    writeResponseFilter.reset <= reset
    writeResponseFilter.io.control.bits <= writeResponseQueue.io.deq.bits @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.control.valid <= writeResponseQueue.io.deq.valid @[MemBoundarySplitter.scala 130:34]
    writeResponseQueue.io.deq.ready <= writeResponseFilter.io.control.ready @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.in.bits.resp <= io.out.writeResponse.bits.resp @[MemBoundarySplitter.scala 131:29]
    writeResponseFilter.io.in.bits.id <= io.out.writeResponse.bits.id @[MemBoundarySplitter.scala 131:29]
    writeResponseFilter.io.in.valid <= io.out.writeResponse.valid @[MemBoundarySplitter.scala 131:29]
    io.out.writeResponse.ready <= writeResponseFilter.io.in.ready @[MemBoundarySplitter.scala 131:29]
    io.in.writeResponse.bits.resp <= writeResponseFilter.io.out.bits.resp @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.bits.id <= writeResponseFilter.io.out.bits.id @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.valid <= writeResponseFilter.io.out.valid @[MemBoundarySplitter.scala 132:23]
    writeResponseFilter.io.out.ready <= io.in.writeResponse.ready @[MemBoundarySplitter.scala 132:23]
    reg readAddressCounter : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[MemBoundarySplitter.scala 137:35]
    reg readLenCounter : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[MemBoundarySplitter.scala 140:31]
    reg writeAddressCounter : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[MemBoundarySplitter.scala 141:36]
    reg writeLenCounter : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[MemBoundarySplitter.scala 144:32]
    inst readEnqueuer of MultiEnqueue_16 @[MultiEnqueue.scala 160:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst writeEnqueuer of MultiEnqueue_17 @[MultiEnqueue.scala 160:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    node lengthBytes = mul(io.in.readAddress.bits.len, UInt<4>("h08")) @[MemBoundarySplitter.scala 105:30]
    node _T = gt(lengthBytes, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:18]
    node _T_1 = rem(io.in.readAddress.bits.addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:45]
    node _T_2 = sub(UInt<13>("h01001"), lengthBytes) @[MemBoundarySplitter.scala 106:79]
    node _T_3 = tail(_T_2, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_4 = gt(_T_1, _T_3) @[MemBoundarySplitter.scala 106:59]
    node _T_5 = or(_T, _T_4) @[MemBoundarySplitter.scala 106:32]
    when _T_5 : @[MemBoundarySplitter.scala 150:74]
      node _addr_T = add(io.in.readAddress.bits.addr, readAddressCounter) @[MemBoundarySplitter.scala 151:44]
      node addr = tail(_addr_T, 1) @[MemBoundarySplitter.scala 151:44]
      node _availableAddresses_T = rem(addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 153:27]
      node _availableAddresses_T_1 = sub(UInt<13>("h01000"), _availableAddresses_T) @[MemBoundarySplitter.scala 153:19]
      node availableAddresses = tail(_availableAddresses_T_1, 1) @[MemBoundarySplitter.scala 153:19]
      node availableBeats = div(availableAddresses, UInt<4>("h08")) @[MemBoundarySplitter.scala 154:45]
      node _len_T = eq(readLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 156:22]
      node _len_T_1 = gt(availableBeats, readLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_2 = mux(_len_T_1, readLenCounter, availableBeats) @[MemBoundarySplitter.scala 109:40]
      node _len_T_3 = mux(_len_T, availableBeats, _len_T_2) @[MemBoundarySplitter.scala 155:18]
      node _len_T_4 = sub(_len_T_3, UInt<1>("h01")) @[MemBoundarySplitter.scala 159:7]
      node len = tail(_len_T_4, 1) @[MemBoundarySplitter.scala 159:7]
      wire address : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 161:23]
      address.qos <= io.in.readAddress.bits.qos @[MemBoundarySplitter.scala 164:11]
      address.prot <= io.in.readAddress.bits.prot @[MemBoundarySplitter.scala 164:11]
      address.cache <= io.in.readAddress.bits.cache @[MemBoundarySplitter.scala 164:11]
      address.lock <= io.in.readAddress.bits.lock @[MemBoundarySplitter.scala 164:11]
      address.burst <= io.in.readAddress.bits.burst @[MemBoundarySplitter.scala 164:11]
      address.size <= io.in.readAddress.bits.size @[MemBoundarySplitter.scala 164:11]
      address.len <= io.in.readAddress.bits.len @[MemBoundarySplitter.scala 164:11]
      address.addr <= io.in.readAddress.bits.addr @[MemBoundarySplitter.scala 164:11]
      address.id <= io.in.readAddress.bits.id @[MemBoundarySplitter.scala 164:11]
      address.addr <= addr @[MemBoundarySplitter.scala 167:18]
      address.len <= len @[MemBoundarySplitter.scala 168:17]
      node _T_6 = eq(readLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 170:25]
      when _T_6 : @[MemBoundarySplitter.scala 170:34]
        readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
        wire ready_io_out_readAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_readAddress_w.bits.qos <= address.qos @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.prot <= address.prot @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.cache <= address.cache @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.lock <= address.lock @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.burst <= address.burst @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.size <= address.size @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.len <= address.len @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.addr <= address.addr @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.id <= address.id @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[0].ready <= ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.readAddress.bits.qos <= ready_io_out_readAddress_w.bits.qos @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.prot <= ready_io_out_readAddress_w.bits.prot @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.cache <= ready_io_out_readAddress_w.bits.cache @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.lock <= ready_io_out_readAddress_w.bits.lock @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.burst <= ready_io_out_readAddress_w.bits.burst @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.size <= ready_io_out_readAddress_w.bits.size @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.len <= ready_io_out_readAddress_w.bits.len @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.addr <= ready_io_out_readAddress_w.bits.addr @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.id <= ready_io_out_readAddress_w.bits.id @[MultiEnqueue.scala 85:10]
        io.out.readAddress.valid <= ready_io_out_readAddress_w.valid @[MultiEnqueue.scala 85:10]
        ready_io_out_readAddress_w.ready <= io.out.readAddress.ready @[MultiEnqueue.scala 85:10]
        wire ready_readDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
        ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[1].ready <= ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        readDataQueue.io.enq.bits <= ready_readDataQueue_io_enq_w.bits @[MultiEnqueue.scala 86:10]
        readDataQueue.io.enq.valid <= ready_readDataQueue_io_enq_w.valid @[MultiEnqueue.scala 86:10]
        ready_readDataQueue_io_enq_w.ready <= readDataQueue.io.enq.ready @[MultiEnqueue.scala 86:10]
        io.in.readAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
        node _T_7 = and(io.in.readAddress.valid, readEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 180:36]
        when _T_7 : @[MemBoundarySplitter.scala 180:46]
          readAddressCounter <= availableAddresses @[MemBoundarySplitter.scala 181:28]
          node _readLenCounter_T = sub(io.in.readAddress.bits.len, len) @[MemBoundarySplitter.scala 182:54]
          node _readLenCounter_T_1 = tail(_readLenCounter_T, 1) @[MemBoundarySplitter.scala 182:54]
          readLenCounter <= _readLenCounter_T_1 @[MemBoundarySplitter.scala 182:24]
          skip @[MemBoundarySplitter.scala 180:46]
        skip @[MemBoundarySplitter.scala 170:34]
      else : @[MemBoundarySplitter.scala 184:50]
        node _T_8 = leq(readLenCounter, availableBeats) @[MemBoundarySplitter.scala 184:31]
        when _T_8 : @[MemBoundarySplitter.scala 184:50]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 186:32]
          io.in.readAddress.ready <= io.out.readAddress.ready @[MemBoundarySplitter.scala 187:31]
          io.out.readAddress.bits.qos <= address.qos @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.prot <= address.prot @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.cache <= address.cache @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.lock <= address.lock @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.burst <= address.burst @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.size <= address.size @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.len <= address.len @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.addr <= address.addr @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.id <= address.id @[MemBoundarySplitter.scala 188:31]
          readDataQueue.io.enq.valid <= UInt<1>("h00") @[Decoupled.scala 56:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 57:19]
          readEnqueuer.io.in.valid <= UInt<1>("h00") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          node _T_9 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 40:37]
          when _T_9 : @[MemBoundarySplitter.scala 193:39]
            readAddressCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 194:28]
            readLenCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 195:24]
            skip @[MemBoundarySplitter.scala 193:39]
          skip @[MemBoundarySplitter.scala 184:50]
        else : @[MemBoundarySplitter.scala 197:17]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 199:32]
          io.out.readAddress.bits.qos <= address.qos @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.prot <= address.prot @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.cache <= address.cache @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.lock <= address.lock @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.burst <= address.burst @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.size <= address.size @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.len <= address.len @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.addr <= address.addr @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.id <= address.id @[MemBoundarySplitter.scala 200:31]
          readDataQueue.io.enq.valid <= UInt<1>("h00") @[Decoupled.scala 56:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 57:19]
          readEnqueuer.io.in.valid <= UInt<1>("h00") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          io.in.readAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
          node _T_10 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 40:37]
          when _T_10 : @[MemBoundarySplitter.scala 206:39]
            node _readAddressCounter_T = add(readAddressCounter, availableAddresses) @[MemBoundarySplitter.scala 208:50]
            node _readAddressCounter_T_1 = tail(_readAddressCounter_T, 1) @[MemBoundarySplitter.scala 208:50]
            readAddressCounter <= _readAddressCounter_T_1 @[MemBoundarySplitter.scala 208:28]
            node _readLenCounter_T_2 = add(len, UInt<1>("h01")) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_3 = tail(_readLenCounter_T_2, 1) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_4 = sub(readLenCounter, _readLenCounter_T_3) @[MemBoundarySplitter.scala 210:42]
            node _readLenCounter_T_5 = tail(_readLenCounter_T_4, 1) @[MemBoundarySplitter.scala 210:42]
            readLenCounter <= _readLenCounter_T_5 @[MemBoundarySplitter.scala 210:24]
            skip @[MemBoundarySplitter.scala 206:39]
          skip @[MemBoundarySplitter.scala 197:17]
      skip @[MemBoundarySplitter.scala 150:74]
    else : @[MemBoundarySplitter.scala 213:15]
      readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
      wire io_in_readAddress_ready_io_out_readAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_io_out_readAddress_w.bits.qos <= io.in.readAddress.bits.qos @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.prot <= io.in.readAddress.bits.prot @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.cache <= io.in.readAddress.bits.cache @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.lock <= io.in.readAddress.bits.lock @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.burst <= io.in.readAddress.bits.burst @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.size <= io.in.readAddress.bits.size @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.len <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.addr <= io.in.readAddress.bits.addr @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.id <= io.in.readAddress.bits.id @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[0].ready <= io_in_readAddress_ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.readAddress.bits.qos <= io_in_readAddress_ready_io_out_readAddress_w.bits.qos @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.prot <= io_in_readAddress_ready_io_out_readAddress_w.bits.prot @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.cache <= io_in_readAddress_ready_io_out_readAddress_w.bits.cache @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.lock <= io_in_readAddress_ready_io_out_readAddress_w.bits.lock @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.burst <= io_in_readAddress_ready_io_out_readAddress_w.bits.burst @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.size <= io_in_readAddress_ready_io_out_readAddress_w.bits.size @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.len <= io_in_readAddress_ready_io_out_readAddress_w.bits.len @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.addr <= io_in_readAddress_ready_io_out_readAddress_w.bits.addr @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.id <= io_in_readAddress_ready_io_out_readAddress_w.bits.id @[MultiEnqueue.scala 85:10]
      io.out.readAddress.valid <= io_in_readAddress_ready_io_out_readAddress_w.valid @[MultiEnqueue.scala 85:10]
      io_in_readAddress_ready_io_out_readAddress_w.ready <= io.out.readAddress.ready @[MultiEnqueue.scala 85:10]
      wire io_in_readAddress_ready_readDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[1].ready <= io_in_readAddress_ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      readDataQueue.io.enq.bits <= io_in_readAddress_ready_readDataQueue_io_enq_w.bits @[MultiEnqueue.scala 86:10]
      readDataQueue.io.enq.valid <= io_in_readAddress_ready_readDataQueue_io_enq_w.valid @[MultiEnqueue.scala 86:10]
      io_in_readAddress_ready_readDataQueue_io_enq_w.ready <= readDataQueue.io.enq.ready @[MultiEnqueue.scala 86:10]
      io.in.readAddress.ready <= readEnqueuer.io.in.ready @[MemBoundarySplitter.scala 214:29]
      skip @[MemBoundarySplitter.scala 213:15]
    node lengthBytes_1 = mul(io.in.writeAddress.bits.len, UInt<4>("h08")) @[MemBoundarySplitter.scala 105:30]
    node _T_11 = gt(lengthBytes_1, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:18]
    node _T_12 = rem(io.in.writeAddress.bits.addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:45]
    node _T_13 = sub(UInt<13>("h01001"), lengthBytes_1) @[MemBoundarySplitter.scala 106:79]
    node _T_14 = tail(_T_13, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_15 = gt(_T_12, _T_14) @[MemBoundarySplitter.scala 106:59]
    node _T_16 = or(_T_11, _T_15) @[MemBoundarySplitter.scala 106:32]
    when _T_16 : @[MemBoundarySplitter.scala 224:76]
      node _addr_T_1 = add(io.in.writeAddress.bits.addr, writeAddressCounter) @[MemBoundarySplitter.scala 225:45]
      node addr_1 = tail(_addr_T_1, 1) @[MemBoundarySplitter.scala 225:45]
      node _availableAddresses_T_2 = rem(addr_1, UInt<13>("h01000")) @[MemBoundarySplitter.scala 227:27]
      node _availableAddresses_T_3 = sub(UInt<13>("h01000"), _availableAddresses_T_2) @[MemBoundarySplitter.scala 227:19]
      node availableAddresses_1 = tail(_availableAddresses_T_3, 1) @[MemBoundarySplitter.scala 227:19]
      node availableBeats_1 = div(availableAddresses_1, UInt<4>("h08")) @[MemBoundarySplitter.scala 228:45]
      node _len_T_5 = eq(writeLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 230:23]
      node _len_T_6 = gt(availableBeats_1, writeLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_7 = mux(_len_T_6, writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 109:40]
      node _len_T_8 = mux(_len_T_5, availableBeats_1, _len_T_7) @[MemBoundarySplitter.scala 229:18]
      node _len_T_9 = sub(_len_T_8, UInt<1>("h01")) @[MemBoundarySplitter.scala 233:7]
      node len_1 = tail(_len_T_9, 1) @[MemBoundarySplitter.scala 233:7]
      wire address_1 : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 235:23]
      address_1.qos <= io.in.writeAddress.bits.qos @[MemBoundarySplitter.scala 238:11]
      address_1.prot <= io.in.writeAddress.bits.prot @[MemBoundarySplitter.scala 238:11]
      address_1.cache <= io.in.writeAddress.bits.cache @[MemBoundarySplitter.scala 238:11]
      address_1.lock <= io.in.writeAddress.bits.lock @[MemBoundarySplitter.scala 238:11]
      address_1.burst <= io.in.writeAddress.bits.burst @[MemBoundarySplitter.scala 238:11]
      address_1.size <= io.in.writeAddress.bits.size @[MemBoundarySplitter.scala 238:11]
      address_1.len <= io.in.writeAddress.bits.len @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= io.in.writeAddress.bits.addr @[MemBoundarySplitter.scala 238:11]
      address_1.id <= io.in.writeAddress.bits.id @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= addr_1 @[MemBoundarySplitter.scala 241:18]
      address_1.len <= len_1 @[MemBoundarySplitter.scala 242:17]
      node _T_17 = eq(writeLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 244:26]
      when _T_17 : @[MemBoundarySplitter.scala 244:35]
        writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
        wire ready_io_out_writeAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_writeAddress_w.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.size <= address_1.size @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.len <= address_1.len @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.id <= address_1.id @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w.bits.qos @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w.bits.prot @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w.bits.cache @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w.bits.lock @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w.bits.burst @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w.bits.size @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w.bits.len @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w.bits.addr @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w.bits.id @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.valid <= ready_io_out_writeAddress_w.valid @[MultiEnqueue.scala 115:10]
        ready_io_out_writeAddress_w.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
        wire ready_writeDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_writeDataQueue_io_enq_w.bits <= address_1.len @[ReadyValid.scala 17:12]
        ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w.bits @[MultiEnqueue.scala 116:10]
        writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w.valid @[MultiEnqueue.scala 116:10]
        ready_writeDataQueue_io_enq_w.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
        wire ready_writeResponseQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
        ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w.bits @[MultiEnqueue.scala 117:10]
        writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w.valid @[MultiEnqueue.scala 117:10]
        ready_writeResponseQueue_io_enq_w.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
        io.in.writeAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
        node _T_18 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 256:37]
        when _T_18 : @[MemBoundarySplitter.scala 256:47]
          writeAddressCounter <= availableAddresses_1 @[MemBoundarySplitter.scala 257:29]
          node _writeLenCounter_T = sub(io.in.writeAddress.bits.len, len_1) @[MemBoundarySplitter.scala 258:56]
          node _writeLenCounter_T_1 = tail(_writeLenCounter_T, 1) @[MemBoundarySplitter.scala 258:56]
          writeLenCounter <= _writeLenCounter_T_1 @[MemBoundarySplitter.scala 258:25]
          skip @[MemBoundarySplitter.scala 256:47]
        skip @[MemBoundarySplitter.scala 244:35]
      else : @[MemBoundarySplitter.scala 260:51]
        node _T_19 = leq(writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 260:32]
        when _T_19 : @[MemBoundarySplitter.scala 260:51]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_1.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.size <= address_1.size @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.len <= address_1.len @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.id <= address_1.id @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_1.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w_1.bits.qos @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w_1.bits.prot @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w_1.bits.cache @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w_1.bits.lock @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w_1.bits.burst @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w_1.bits.size @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w_1.bits.len @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w_1.bits.addr @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w_1.bits.id @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.valid <= ready_io_out_writeAddress_w_1.valid @[MultiEnqueue.scala 115:10]
          ready_io_out_writeAddress_w_1.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_1.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w_1.bits @[MultiEnqueue.scala 116:10]
          writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w_1.valid @[MultiEnqueue.scala 116:10]
          ready_writeDataQueue_io_enq_w_1.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_1.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w_1.bits @[MultiEnqueue.scala 117:10]
          writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w_1.valid @[MultiEnqueue.scala 117:10]
          ready_writeResponseQueue_io_enq_w_1.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 271:32]
          node _T_20 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 272:37]
          when _T_20 : @[MemBoundarySplitter.scala 272:47]
            writeAddressCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 273:29]
            writeLenCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 274:25]
            skip @[MemBoundarySplitter.scala 272:47]
          skip @[MemBoundarySplitter.scala 260:51]
        else : @[MemBoundarySplitter.scala 276:17]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_2.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.size <= address_1.size @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.len <= address_1.len @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.id <= address_1.id @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_2.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w_2.bits.qos @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w_2.bits.prot @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w_2.bits.cache @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w_2.bits.lock @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w_2.bits.burst @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w_2.bits.size @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w_2.bits.len @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w_2.bits.addr @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w_2.bits.id @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.valid <= ready_io_out_writeAddress_w_2.valid @[MultiEnqueue.scala 115:10]
          ready_io_out_writeAddress_w_2.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_2.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w_2.bits @[MultiEnqueue.scala 116:10]
          writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w_2.valid @[MultiEnqueue.scala 116:10]
          ready_writeDataQueue_io_enq_w_2.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_2.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w_2.bits @[MultiEnqueue.scala 117:10]
          writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w_2.valid @[MultiEnqueue.scala 117:10]
          ready_writeResponseQueue_io_enq_w_2.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
          node _T_21 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 288:37]
          when _T_21 : @[MemBoundarySplitter.scala 288:47]
            node _writeAddressCounter_T = add(writeAddressCounter, availableAddresses_1) @[MemBoundarySplitter.scala 290:52]
            node _writeAddressCounter_T_1 = tail(_writeAddressCounter_T, 1) @[MemBoundarySplitter.scala 290:52]
            writeAddressCounter <= _writeAddressCounter_T_1 @[MemBoundarySplitter.scala 290:29]
            node _writeLenCounter_T_2 = add(len_1, UInt<1>("h01")) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_3 = tail(_writeLenCounter_T_2, 1) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_4 = sub(writeLenCounter, _writeLenCounter_T_3) @[MemBoundarySplitter.scala 292:44]
            node _writeLenCounter_T_5 = tail(_writeLenCounter_T_4, 1) @[MemBoundarySplitter.scala 292:44]
            writeLenCounter <= _writeLenCounter_T_5 @[MemBoundarySplitter.scala 292:25]
            skip @[MemBoundarySplitter.scala 288:47]
          skip @[MemBoundarySplitter.scala 276:17]
      skip @[MemBoundarySplitter.scala 224:76]
    else : @[MemBoundarySplitter.scala 295:15]
      writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
      wire io_in_writeAddress_ready_io_out_writeAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.qos <= io.in.writeAddress.bits.qos @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.prot <= io.in.writeAddress.bits.prot @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.cache <= io.in.writeAddress.bits.cache @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.lock <= io.in.writeAddress.bits.lock @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.burst <= io.in.writeAddress.bits.burst @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.size <= io.in.writeAddress.bits.size @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.len <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.addr <= io.in.writeAddress.bits.addr @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.id <= io.in.writeAddress.bits.id @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[0].ready <= io_in_writeAddress_ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.writeAddress.bits.qos <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.qos @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.prot <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.prot @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.cache <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.cache @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.lock <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.lock @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.burst <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.burst @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.size <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.size @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.len <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.len @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.addr <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.addr @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.id <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.id @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.valid <= io_in_writeAddress_ready_io_out_writeAddress_w.valid @[MultiEnqueue.scala 115:10]
      io_in_writeAddress_ready_io_out_writeAddress_w.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
      wire io_in_writeAddress_ready_writeDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[1].ready <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeDataQueue.io.enq.bits <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits @[MultiEnqueue.scala 116:10]
      writeDataQueue.io.enq.valid <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid @[MultiEnqueue.scala 116:10]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
      wire io_in_writeAddress_ready_writeResponseQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[2].ready <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeResponseQueue.io.enq.bits <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits @[MultiEnqueue.scala 117:10]
      writeResponseQueue.io.enq.valid <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid @[MultiEnqueue.scala 117:10]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
      io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 296:30]
      skip @[MemBoundarySplitter.scala 295:15]
    
  module Queue_31 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}
    
    cmem ram : UInt<8>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_32 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, count : UInt<2>}
    
    cmem ram : UInt<8>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_33 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<2>}
    
    cmem ram : UInt<1>[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT <= io.enq.bits @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits <= io_deq_bits_MPORT @[Decoupled.scala 242:15]
    when io.enq.valid : @[Decoupled.scala 245:25]
      io.deq.valid <= UInt<1>("h01") @[Decoupled.scala 245:40]
      skip @[Decoupled.scala 245:25]
    when empty : @[Decoupled.scala 246:18]
      io.deq.bits <= io.enq.bits @[Decoupled.scala 247:19]
      do_deq <= UInt<1>("h00") @[Decoupled.scala 248:14]
      when io.deq.ready : @[Decoupled.scala 249:27]
        do_enq <= UInt<1>("h00") @[Decoupled.scala 249:36]
        skip @[Decoupled.scala 249:27]
      skip @[Decoupled.scala 246:18]
    when io.deq.ready : @[Decoupled.scala 254:25]
      io.enq.ready <= UInt<1>("h01") @[Decoupled.scala 254:40]
      skip @[Decoupled.scala 254:25]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Counter_12 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module BurstSplitter_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    
    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_12 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h01") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
      skip @[MemBoundarySplitter.scala 45:51]
    else : @[MemBoundarySplitter.scala 49:15]
      io.out.bits.last <= UInt<1>("h00") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h00") @[MemBoundarySplitter.scala 52:22]
      skip @[MemBoundarySplitter.scala 49:15]
    
  module Counter_13 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module BurstSplitter_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}}
    
    io.out.bits.last <= io.in.bits.last @[MemBoundarySplitter.scala 34:34]
    io.out.bits.strb <= io.in.bits.strb @[MemBoundarySplitter.scala 34:34]
    io.out.bits.data <= io.in.bits.data @[MemBoundarySplitter.scala 34:34]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 34:34]
    node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 40:36]
    io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 40:16]
    node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 41:35]
    io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 41:15]
    inst counter of Counter_13 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    node _T = eq(counter.io.value.bits, io.control.bits) @[MemBoundarySplitter.scala 45:30]
    when _T : @[MemBoundarySplitter.scala 45:51]
      io.out.bits.last <= UInt<1>("h01") @[MemBoundarySplitter.scala 46:10]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[MemBoundarySplitter.scala 47:27]
      node _io_control_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 48:22]
      skip @[MemBoundarySplitter.scala 45:51]
    else : @[MemBoundarySplitter.scala 49:15]
      io.out.bits.last <= UInt<1>("h00") @[MemBoundarySplitter.scala 50:10]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[MemBoundarySplitter.scala 51:28]
      io.control.ready <= UInt<1>("h00") @[MemBoundarySplitter.scala 52:22]
      skip @[MemBoundarySplitter.scala 49:15]
    
  module Filter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}}
    
    io.out.bits.resp <= io.in.bits.resp @[MemBoundarySplitter.scala 69:15]
    io.out.bits.id <= io.in.bits.id @[MemBoundarySplitter.scala 69:15]
    when io.control.bits : @[MemBoundarySplitter.scala 71:25]
      node _io_out_valid_T = and(io.control.valid, io.in.valid) @[MemBoundarySplitter.scala 72:38]
      io.out.valid <= _io_out_valid_T @[MemBoundarySplitter.scala 72:18]
      node _io_in_ready_T = and(io.control.valid, io.out.ready) @[MemBoundarySplitter.scala 73:37]
      io.in.ready <= _io_in_ready_T @[MemBoundarySplitter.scala 73:17]
      node _io_control_ready_T = and(io.in.valid, io.out.ready) @[MemBoundarySplitter.scala 74:37]
      io.control.ready <= _io_control_ready_T @[MemBoundarySplitter.scala 74:22]
      skip @[MemBoundarySplitter.scala 71:25]
    else : @[MemBoundarySplitter.scala 75:15]
      io.out.valid <= UInt<1>("h00") @[MemBoundarySplitter.scala 76:18]
      io.in.ready <= io.control.valid @[MemBoundarySplitter.scala 77:17]
      io.control.ready <= io.in.valid @[MemBoundarySplitter.scala 78:22]
      skip @[MemBoundarySplitter.scala 75:15]
    
  module MultiEnqueue_18 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MultiEnqueue_19 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[3]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_2 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_2 = or(io.out[2].ready, enq_2) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_3 = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node allEnqueued = and(_allEnqueued_T_3, _allEnqueued_T_2) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_2_valid_T = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_2_valid_T_1 = and(io.in.valid, _io_out_2_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[2].valid <= _io_out_2_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_2 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_2 = eq(enq_2, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_2 : @[MultiEnqueue.scala 31:21]
        node _enq_2_T = and(io.out[2].valid, io.out[2].ready) @[MultiEnqueue.scala 32:35]
        enq_2 <= _enq_2_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module MemBoundarySplitter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}
    
    inst readDataQueue of Queue_31 @[MemBoundarySplitter.scala 111:29]
    readDataQueue.clock <= clock
    readDataQueue.reset <= reset
    inst writeDataQueue of Queue_32 @[MemBoundarySplitter.scala 114:30]
    writeDataQueue.clock <= clock
    writeDataQueue.reset <= reset
    inst writeResponseQueue of Queue_33 @[MemBoundarySplitter.scala 117:34]
    writeResponseQueue.clock <= clock
    writeResponseQueue.reset <= reset
    inst readMerger of BurstSplitter_2 @[MemBoundarySplitter.scala 121:26]
    readMerger.clock <= clock
    readMerger.reset <= reset
    readMerger.io.control.bits <= readDataQueue.io.deq.bits @[MemBoundarySplitter.scala 122:25]
    readMerger.io.control.valid <= readDataQueue.io.deq.valid @[MemBoundarySplitter.scala 122:25]
    readDataQueue.io.deq.ready <= readMerger.io.control.ready @[MemBoundarySplitter.scala 122:25]
    readMerger.io.in.bits.last <= io.out.readData.bits.last @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.resp <= io.out.readData.bits.resp @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.data <= io.out.readData.bits.data @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.bits.id <= io.out.readData.bits.id @[MemBoundarySplitter.scala 123:20]
    readMerger.io.in.valid <= io.out.readData.valid @[MemBoundarySplitter.scala 123:20]
    io.out.readData.ready <= readMerger.io.in.ready @[MemBoundarySplitter.scala 123:20]
    io.in.readData.bits.last <= readMerger.io.out.bits.last @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.resp <= readMerger.io.out.bits.resp @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.data <= readMerger.io.out.bits.data @[MemBoundarySplitter.scala 124:18]
    io.in.readData.bits.id <= readMerger.io.out.bits.id @[MemBoundarySplitter.scala 124:18]
    io.in.readData.valid <= readMerger.io.out.valid @[MemBoundarySplitter.scala 124:18]
    readMerger.io.out.ready <= io.in.readData.ready @[MemBoundarySplitter.scala 124:18]
    inst writeSplitter of BurstSplitter_3 @[MemBoundarySplitter.scala 125:29]
    writeSplitter.clock <= clock
    writeSplitter.reset <= reset
    writeSplitter.io.control.bits <= writeDataQueue.io.deq.bits @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.control.valid <= writeDataQueue.io.deq.valid @[MemBoundarySplitter.scala 126:28]
    writeDataQueue.io.deq.ready <= writeSplitter.io.control.ready @[MemBoundarySplitter.scala 126:28]
    writeSplitter.io.in.bits.last <= io.in.writeData.bits.last @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.strb <= io.in.writeData.bits.strb @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.data <= io.in.writeData.bits.data @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.bits.id <= io.in.writeData.bits.id @[MemBoundarySplitter.scala 127:23]
    writeSplitter.io.in.valid <= io.in.writeData.valid @[MemBoundarySplitter.scala 127:23]
    io.in.writeData.ready <= writeSplitter.io.in.ready @[MemBoundarySplitter.scala 127:23]
    io.out.writeData.bits.last <= writeSplitter.io.out.bits.last @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.strb <= writeSplitter.io.out.bits.strb @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.data <= writeSplitter.io.out.bits.data @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.bits.id <= writeSplitter.io.out.bits.id @[MemBoundarySplitter.scala 128:20]
    io.out.writeData.valid <= writeSplitter.io.out.valid @[MemBoundarySplitter.scala 128:20]
    writeSplitter.io.out.ready <= io.out.writeData.ready @[MemBoundarySplitter.scala 128:20]
    inst writeResponseFilter of Filter_1 @[MemBoundarySplitter.scala 129:35]
    writeResponseFilter.clock <= clock
    writeResponseFilter.reset <= reset
    writeResponseFilter.io.control.bits <= writeResponseQueue.io.deq.bits @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.control.valid <= writeResponseQueue.io.deq.valid @[MemBoundarySplitter.scala 130:34]
    writeResponseQueue.io.deq.ready <= writeResponseFilter.io.control.ready @[MemBoundarySplitter.scala 130:34]
    writeResponseFilter.io.in.bits.resp <= io.out.writeResponse.bits.resp @[MemBoundarySplitter.scala 131:29]
    writeResponseFilter.io.in.bits.id <= io.out.writeResponse.bits.id @[MemBoundarySplitter.scala 131:29]
    writeResponseFilter.io.in.valid <= io.out.writeResponse.valid @[MemBoundarySplitter.scala 131:29]
    io.out.writeResponse.ready <= writeResponseFilter.io.in.ready @[MemBoundarySplitter.scala 131:29]
    io.in.writeResponse.bits.resp <= writeResponseFilter.io.out.bits.resp @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.bits.id <= writeResponseFilter.io.out.bits.id @[MemBoundarySplitter.scala 132:23]
    io.in.writeResponse.valid <= writeResponseFilter.io.out.valid @[MemBoundarySplitter.scala 132:23]
    writeResponseFilter.io.out.ready <= io.in.writeResponse.ready @[MemBoundarySplitter.scala 132:23]
    reg readAddressCounter : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[MemBoundarySplitter.scala 137:35]
    reg readLenCounter : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[MemBoundarySplitter.scala 140:31]
    reg writeAddressCounter : UInt<11>, clock with : (reset => (reset, UInt<11>("h00"))) @[MemBoundarySplitter.scala 141:36]
    reg writeLenCounter : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[MemBoundarySplitter.scala 144:32]
    inst readEnqueuer of MultiEnqueue_18 @[MultiEnqueue.scala 160:43]
    readEnqueuer.clock <= clock
    readEnqueuer.reset <= reset
    inst writeEnqueuer of MultiEnqueue_19 @[MultiEnqueue.scala 160:43]
    writeEnqueuer.clock <= clock
    writeEnqueuer.reset <= reset
    node lengthBytes = mul(io.in.readAddress.bits.len, UInt<4>("h08")) @[MemBoundarySplitter.scala 105:30]
    node _T = gt(lengthBytes, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:18]
    node _T_1 = rem(io.in.readAddress.bits.addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:45]
    node _T_2 = sub(UInt<13>("h01001"), lengthBytes) @[MemBoundarySplitter.scala 106:79]
    node _T_3 = tail(_T_2, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_4 = gt(_T_1, _T_3) @[MemBoundarySplitter.scala 106:59]
    node _T_5 = or(_T, _T_4) @[MemBoundarySplitter.scala 106:32]
    when _T_5 : @[MemBoundarySplitter.scala 150:74]
      node _addr_T = add(io.in.readAddress.bits.addr, readAddressCounter) @[MemBoundarySplitter.scala 151:44]
      node addr = tail(_addr_T, 1) @[MemBoundarySplitter.scala 151:44]
      node _availableAddresses_T = rem(addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 153:27]
      node _availableAddresses_T_1 = sub(UInt<13>("h01000"), _availableAddresses_T) @[MemBoundarySplitter.scala 153:19]
      node availableAddresses = tail(_availableAddresses_T_1, 1) @[MemBoundarySplitter.scala 153:19]
      node availableBeats = div(availableAddresses, UInt<4>("h08")) @[MemBoundarySplitter.scala 154:45]
      node _len_T = eq(readLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 156:22]
      node _len_T_1 = gt(availableBeats, readLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_2 = mux(_len_T_1, readLenCounter, availableBeats) @[MemBoundarySplitter.scala 109:40]
      node _len_T_3 = mux(_len_T, availableBeats, _len_T_2) @[MemBoundarySplitter.scala 155:18]
      node _len_T_4 = sub(_len_T_3, UInt<1>("h01")) @[MemBoundarySplitter.scala 159:7]
      node len = tail(_len_T_4, 1) @[MemBoundarySplitter.scala 159:7]
      wire address : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 161:23]
      address.qos <= io.in.readAddress.bits.qos @[MemBoundarySplitter.scala 164:11]
      address.prot <= io.in.readAddress.bits.prot @[MemBoundarySplitter.scala 164:11]
      address.cache <= io.in.readAddress.bits.cache @[MemBoundarySplitter.scala 164:11]
      address.lock <= io.in.readAddress.bits.lock @[MemBoundarySplitter.scala 164:11]
      address.burst <= io.in.readAddress.bits.burst @[MemBoundarySplitter.scala 164:11]
      address.size <= io.in.readAddress.bits.size @[MemBoundarySplitter.scala 164:11]
      address.len <= io.in.readAddress.bits.len @[MemBoundarySplitter.scala 164:11]
      address.addr <= io.in.readAddress.bits.addr @[MemBoundarySplitter.scala 164:11]
      address.id <= io.in.readAddress.bits.id @[MemBoundarySplitter.scala 164:11]
      address.addr <= addr @[MemBoundarySplitter.scala 167:18]
      address.len <= len @[MemBoundarySplitter.scala 168:17]
      node _T_6 = eq(readLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 170:25]
      when _T_6 : @[MemBoundarySplitter.scala 170:34]
        readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
        wire ready_io_out_readAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_readAddress_w.bits.qos <= address.qos @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.prot <= address.prot @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.cache <= address.cache @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.lock <= address.lock @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.burst <= address.burst @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.size <= address.size @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.len <= address.len @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.addr <= address.addr @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.bits.id <= address.id @[ReadyValid.scala 17:12]
        ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[0].ready <= ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.readAddress.bits.qos <= ready_io_out_readAddress_w.bits.qos @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.prot <= ready_io_out_readAddress_w.bits.prot @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.cache <= ready_io_out_readAddress_w.bits.cache @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.lock <= ready_io_out_readAddress_w.bits.lock @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.burst <= ready_io_out_readAddress_w.bits.burst @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.size <= ready_io_out_readAddress_w.bits.size @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.len <= ready_io_out_readAddress_w.bits.len @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.addr <= ready_io_out_readAddress_w.bits.addr @[MultiEnqueue.scala 85:10]
        io.out.readAddress.bits.id <= ready_io_out_readAddress_w.bits.id @[MultiEnqueue.scala 85:10]
        io.out.readAddress.valid <= ready_io_out_readAddress_w.valid @[MultiEnqueue.scala 85:10]
        ready_io_out_readAddress_w.ready <= io.out.readAddress.ready @[MultiEnqueue.scala 85:10]
        wire ready_readDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
        ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        readEnqueuer.io.out[1].ready <= ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        readDataQueue.io.enq.bits <= ready_readDataQueue_io_enq_w.bits @[MultiEnqueue.scala 86:10]
        readDataQueue.io.enq.valid <= ready_readDataQueue_io_enq_w.valid @[MultiEnqueue.scala 86:10]
        ready_readDataQueue_io_enq_w.ready <= readDataQueue.io.enq.ready @[MultiEnqueue.scala 86:10]
        io.in.readAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
        node _T_7 = and(io.in.readAddress.valid, readEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 180:36]
        when _T_7 : @[MemBoundarySplitter.scala 180:46]
          readAddressCounter <= availableAddresses @[MemBoundarySplitter.scala 181:28]
          node _readLenCounter_T = sub(io.in.readAddress.bits.len, len) @[MemBoundarySplitter.scala 182:54]
          node _readLenCounter_T_1 = tail(_readLenCounter_T, 1) @[MemBoundarySplitter.scala 182:54]
          readLenCounter <= _readLenCounter_T_1 @[MemBoundarySplitter.scala 182:24]
          skip @[MemBoundarySplitter.scala 180:46]
        skip @[MemBoundarySplitter.scala 170:34]
      else : @[MemBoundarySplitter.scala 184:50]
        node _T_8 = leq(readLenCounter, availableBeats) @[MemBoundarySplitter.scala 184:31]
        when _T_8 : @[MemBoundarySplitter.scala 184:50]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 186:32]
          io.in.readAddress.ready <= io.out.readAddress.ready @[MemBoundarySplitter.scala 187:31]
          io.out.readAddress.bits.qos <= address.qos @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.prot <= address.prot @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.cache <= address.cache @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.lock <= address.lock @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.burst <= address.burst @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.size <= address.size @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.len <= address.len @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.addr <= address.addr @[MemBoundarySplitter.scala 188:31]
          io.out.readAddress.bits.id <= address.id @[MemBoundarySplitter.scala 188:31]
          readDataQueue.io.enq.valid <= UInt<1>("h00") @[Decoupled.scala 56:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 57:19]
          readEnqueuer.io.in.valid <= UInt<1>("h00") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          node _T_9 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 40:37]
          when _T_9 : @[MemBoundarySplitter.scala 193:39]
            readAddressCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 194:28]
            readLenCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 195:24]
            skip @[MemBoundarySplitter.scala 193:39]
          skip @[MemBoundarySplitter.scala 184:50]
        else : @[MemBoundarySplitter.scala 197:17]
          io.out.readAddress.valid <= io.in.readAddress.valid @[MemBoundarySplitter.scala 199:32]
          io.out.readAddress.bits.qos <= address.qos @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.prot <= address.prot @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.cache <= address.cache @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.lock <= address.lock @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.burst <= address.burst @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.size <= address.size @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.len <= address.len @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.addr <= address.addr @[MemBoundarySplitter.scala 200:31]
          io.out.readAddress.bits.id <= address.id @[MemBoundarySplitter.scala 200:31]
          readDataQueue.io.enq.valid <= UInt<1>("h00") @[Decoupled.scala 56:20]
          readDataQueue.io.enq.bits is invalid @[Decoupled.scala 57:19]
          readEnqueuer.io.in.valid <= UInt<1>("h00") @[ReadyValid.scala 24:11]
          readEnqueuer.io.out[0].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          readEnqueuer.io.out[1].ready <= UInt<1>("h00") @[ReadyValid.scala 28:11]
          io.in.readAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
          node _T_10 = and(io.out.readAddress.ready, io.out.readAddress.valid) @[Decoupled.scala 40:37]
          when _T_10 : @[MemBoundarySplitter.scala 206:39]
            node _readAddressCounter_T = add(readAddressCounter, availableAddresses) @[MemBoundarySplitter.scala 208:50]
            node _readAddressCounter_T_1 = tail(_readAddressCounter_T, 1) @[MemBoundarySplitter.scala 208:50]
            readAddressCounter <= _readAddressCounter_T_1 @[MemBoundarySplitter.scala 208:28]
            node _readLenCounter_T_2 = add(len, UInt<1>("h01")) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_3 = tail(_readLenCounter_T_2, 1) @[MemBoundarySplitter.scala 210:49]
            node _readLenCounter_T_4 = sub(readLenCounter, _readLenCounter_T_3) @[MemBoundarySplitter.scala 210:42]
            node _readLenCounter_T_5 = tail(_readLenCounter_T_4, 1) @[MemBoundarySplitter.scala 210:42]
            readLenCounter <= _readLenCounter_T_5 @[MemBoundarySplitter.scala 210:24]
            skip @[MemBoundarySplitter.scala 206:39]
          skip @[MemBoundarySplitter.scala 197:17]
      skip @[MemBoundarySplitter.scala 150:74]
    else : @[MemBoundarySplitter.scala 213:15]
      readEnqueuer.io.in.valid <= io.in.readAddress.valid @[MultiEnqueue.scala 84:17]
      wire io_in_readAddress_ready_io_out_readAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_io_out_readAddress_w.bits.qos <= io.in.readAddress.bits.qos @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.prot <= io.in.readAddress.bits.prot @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.cache <= io.in.readAddress.bits.cache @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.lock <= io.in.readAddress.bits.lock @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.burst <= io.in.readAddress.bits.burst @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.size <= io.in.readAddress.bits.size @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.len <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.addr <= io.in.readAddress.bits.addr @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.bits.id <= io.in.readAddress.bits.id @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_io_out_readAddress_w.valid <= readEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[0].ready <= io_in_readAddress_ready_io_out_readAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.readAddress.bits.qos <= io_in_readAddress_ready_io_out_readAddress_w.bits.qos @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.prot <= io_in_readAddress_ready_io_out_readAddress_w.bits.prot @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.cache <= io_in_readAddress_ready_io_out_readAddress_w.bits.cache @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.lock <= io_in_readAddress_ready_io_out_readAddress_w.bits.lock @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.burst <= io_in_readAddress_ready_io_out_readAddress_w.bits.burst @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.size <= io_in_readAddress_ready_io_out_readAddress_w.bits.size @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.len <= io_in_readAddress_ready_io_out_readAddress_w.bits.len @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.addr <= io_in_readAddress_ready_io_out_readAddress_w.bits.addr @[MultiEnqueue.scala 85:10]
      io.out.readAddress.bits.id <= io_in_readAddress_ready_io_out_readAddress_w.bits.id @[MultiEnqueue.scala 85:10]
      io.out.readAddress.valid <= io_in_readAddress_ready_io_out_readAddress_w.valid @[MultiEnqueue.scala 85:10]
      io_in_readAddress_ready_io_out_readAddress_w.ready <= io.out.readAddress.ready @[MultiEnqueue.scala 85:10]
      wire io_in_readAddress_ready_readDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_readAddress_ready_readDataQueue_io_enq_w.bits <= io.in.readAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_readAddress_ready_readDataQueue_io_enq_w.valid <= readEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      readEnqueuer.io.out[1].ready <= io_in_readAddress_ready_readDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      readDataQueue.io.enq.bits <= io_in_readAddress_ready_readDataQueue_io_enq_w.bits @[MultiEnqueue.scala 86:10]
      readDataQueue.io.enq.valid <= io_in_readAddress_ready_readDataQueue_io_enq_w.valid @[MultiEnqueue.scala 86:10]
      io_in_readAddress_ready_readDataQueue_io_enq_w.ready <= readDataQueue.io.enq.ready @[MultiEnqueue.scala 86:10]
      io.in.readAddress.ready <= readEnqueuer.io.in.ready @[MemBoundarySplitter.scala 214:29]
      skip @[MemBoundarySplitter.scala 213:15]
    node lengthBytes_1 = mul(io.in.writeAddress.bits.len, UInt<4>("h08")) @[MemBoundarySplitter.scala 105:30]
    node _T_11 = gt(lengthBytes_1, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:18]
    node _T_12 = rem(io.in.writeAddress.bits.addr, UInt<13>("h01000")) @[MemBoundarySplitter.scala 106:45]
    node _T_13 = sub(UInt<13>("h01001"), lengthBytes_1) @[MemBoundarySplitter.scala 106:79]
    node _T_14 = tail(_T_13, 1) @[MemBoundarySplitter.scala 106:79]
    node _T_15 = gt(_T_12, _T_14) @[MemBoundarySplitter.scala 106:59]
    node _T_16 = or(_T_11, _T_15) @[MemBoundarySplitter.scala 106:32]
    when _T_16 : @[MemBoundarySplitter.scala 224:76]
      node _addr_T_1 = add(io.in.writeAddress.bits.addr, writeAddressCounter) @[MemBoundarySplitter.scala 225:45]
      node addr_1 = tail(_addr_T_1, 1) @[MemBoundarySplitter.scala 225:45]
      node _availableAddresses_T_2 = rem(addr_1, UInt<13>("h01000")) @[MemBoundarySplitter.scala 227:27]
      node _availableAddresses_T_3 = sub(UInt<13>("h01000"), _availableAddresses_T_2) @[MemBoundarySplitter.scala 227:19]
      node availableAddresses_1 = tail(_availableAddresses_T_3, 1) @[MemBoundarySplitter.scala 227:19]
      node availableBeats_1 = div(availableAddresses_1, UInt<4>("h08")) @[MemBoundarySplitter.scala 228:45]
      node _len_T_5 = eq(writeLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 230:23]
      node _len_T_6 = gt(availableBeats_1, writeLenCounter) @[MemBoundarySplitter.scala 109:43]
      node _len_T_7 = mux(_len_T_6, writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 109:40]
      node _len_T_8 = mux(_len_T_5, availableBeats_1, _len_T_7) @[MemBoundarySplitter.scala 229:18]
      node _len_T_9 = sub(_len_T_8, UInt<1>("h01")) @[MemBoundarySplitter.scala 233:7]
      node len_1 = tail(_len_T_9, 1) @[MemBoundarySplitter.scala 233:7]
      wire address_1 : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>} @[MemBoundarySplitter.scala 235:23]
      address_1.qos <= io.in.writeAddress.bits.qos @[MemBoundarySplitter.scala 238:11]
      address_1.prot <= io.in.writeAddress.bits.prot @[MemBoundarySplitter.scala 238:11]
      address_1.cache <= io.in.writeAddress.bits.cache @[MemBoundarySplitter.scala 238:11]
      address_1.lock <= io.in.writeAddress.bits.lock @[MemBoundarySplitter.scala 238:11]
      address_1.burst <= io.in.writeAddress.bits.burst @[MemBoundarySplitter.scala 238:11]
      address_1.size <= io.in.writeAddress.bits.size @[MemBoundarySplitter.scala 238:11]
      address_1.len <= io.in.writeAddress.bits.len @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= io.in.writeAddress.bits.addr @[MemBoundarySplitter.scala 238:11]
      address_1.id <= io.in.writeAddress.bits.id @[MemBoundarySplitter.scala 238:11]
      address_1.addr <= addr_1 @[MemBoundarySplitter.scala 241:18]
      address_1.len <= len_1 @[MemBoundarySplitter.scala 242:17]
      node _T_17 = eq(writeLenCounter, UInt<1>("h00")) @[MemBoundarySplitter.scala 244:26]
      when _T_17 : @[MemBoundarySplitter.scala 244:35]
        writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
        wire ready_io_out_writeAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
        ready_io_out_writeAddress_w.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.size <= address_1.size @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.len <= address_1.len @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.bits.id <= address_1.id @[ReadyValid.scala 17:12]
        ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
        io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w.bits.qos @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w.bits.prot @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w.bits.cache @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w.bits.lock @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w.bits.burst @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w.bits.size @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w.bits.len @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w.bits.addr @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w.bits.id @[MultiEnqueue.scala 115:10]
        io.out.writeAddress.valid <= ready_io_out_writeAddress_w.valid @[MultiEnqueue.scala 115:10]
        ready_io_out_writeAddress_w.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
        wire ready_writeDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
        ready_writeDataQueue_io_enq_w.bits <= address_1.len @[ReadyValid.scala 17:12]
        ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w.bits @[MultiEnqueue.scala 116:10]
        writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w.valid @[MultiEnqueue.scala 116:10]
        ready_writeDataQueue_io_enq_w.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
        wire ready_writeResponseQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
        ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
        ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
        writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
        writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w.bits @[MultiEnqueue.scala 117:10]
        writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w.valid @[MultiEnqueue.scala 117:10]
        ready_writeResponseQueue_io_enq_w.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
        io.in.writeAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
        node _T_18 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 256:37]
        when _T_18 : @[MemBoundarySplitter.scala 256:47]
          writeAddressCounter <= availableAddresses_1 @[MemBoundarySplitter.scala 257:29]
          node _writeLenCounter_T = sub(io.in.writeAddress.bits.len, len_1) @[MemBoundarySplitter.scala 258:56]
          node _writeLenCounter_T_1 = tail(_writeLenCounter_T, 1) @[MemBoundarySplitter.scala 258:56]
          writeLenCounter <= _writeLenCounter_T_1 @[MemBoundarySplitter.scala 258:25]
          skip @[MemBoundarySplitter.scala 256:47]
        skip @[MemBoundarySplitter.scala 244:35]
      else : @[MemBoundarySplitter.scala 260:51]
        node _T_19 = leq(writeLenCounter, availableBeats_1) @[MemBoundarySplitter.scala 260:32]
        when _T_19 : @[MemBoundarySplitter.scala 260:51]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_1.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.size <= address_1.size @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.len <= address_1.len @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.bits.id <= address_1.id @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_1.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_1.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w_1.bits.qos @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w_1.bits.prot @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w_1.bits.cache @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w_1.bits.lock @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w_1.bits.burst @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w_1.bits.size @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w_1.bits.len @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w_1.bits.addr @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w_1.bits.id @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.valid <= ready_io_out_writeAddress_w_1.valid @[MultiEnqueue.scala 115:10]
          ready_io_out_writeAddress_w_1.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_1.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w_1.bits @[MultiEnqueue.scala 116:10]
          writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w_1.valid @[MultiEnqueue.scala 116:10]
          ready_writeDataQueue_io_enq_w_1.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_1 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_1.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_1.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_1.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w_1.bits @[MultiEnqueue.scala 117:10]
          writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w_1.valid @[MultiEnqueue.scala 117:10]
          ready_writeResponseQueue_io_enq_w_1.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 271:32]
          node _T_20 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 272:37]
          when _T_20 : @[MemBoundarySplitter.scala 272:47]
            writeAddressCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 273:29]
            writeLenCounter <= UInt<1>("h00") @[MemBoundarySplitter.scala 274:25]
            skip @[MemBoundarySplitter.scala 272:47]
          skip @[MemBoundarySplitter.scala 260:51]
        else : @[MemBoundarySplitter.scala 276:17]
          writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
          wire ready_io_out_writeAddress_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
          ready_io_out_writeAddress_w_2.bits.qos <= address_1.qos @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.prot <= address_1.prot @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.cache <= address_1.cache @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.lock <= address_1.lock @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.burst <= address_1.burst @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.size <= address_1.size @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.len <= address_1.len @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.addr <= address_1.addr @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.bits.id <= address_1.id @[ReadyValid.scala 17:12]
          ready_io_out_writeAddress_w_2.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[0].ready <= ready_io_out_writeAddress_w_2.ready @[ReadyValid.scala 19:11]
          io.out.writeAddress.bits.qos <= ready_io_out_writeAddress_w_2.bits.qos @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.prot <= ready_io_out_writeAddress_w_2.bits.prot @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.cache <= ready_io_out_writeAddress_w_2.bits.cache @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.lock <= ready_io_out_writeAddress_w_2.bits.lock @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.burst <= ready_io_out_writeAddress_w_2.bits.burst @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.size <= ready_io_out_writeAddress_w_2.bits.size @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.len <= ready_io_out_writeAddress_w_2.bits.len @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.addr <= ready_io_out_writeAddress_w_2.bits.addr @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.bits.id <= ready_io_out_writeAddress_w_2.bits.id @[MultiEnqueue.scala 115:10]
          io.out.writeAddress.valid <= ready_io_out_writeAddress_w_2.valid @[MultiEnqueue.scala 115:10]
          ready_io_out_writeAddress_w_2.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
          wire ready_writeDataQueue_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
          ready_writeDataQueue_io_enq_w_2.bits <= address_1.len @[ReadyValid.scala 17:12]
          ready_writeDataQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[1].ready <= ready_writeDataQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeDataQueue.io.enq.bits <= ready_writeDataQueue_io_enq_w_2.bits @[MultiEnqueue.scala 116:10]
          writeDataQueue.io.enq.valid <= ready_writeDataQueue_io_enq_w_2.valid @[MultiEnqueue.scala 116:10]
          ready_writeDataQueue_io_enq_w_2.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
          wire ready_writeResponseQueue_io_enq_w_2 : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
          ready_writeResponseQueue_io_enq_w_2.bits <= UInt<1>("h00") @[ReadyValid.scala 17:12]
          ready_writeResponseQueue_io_enq_w_2.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
          writeEnqueuer.io.out[2].ready <= ready_writeResponseQueue_io_enq_w_2.ready @[ReadyValid.scala 19:11]
          writeResponseQueue.io.enq.bits <= ready_writeResponseQueue_io_enq_w_2.bits @[MultiEnqueue.scala 117:10]
          writeResponseQueue.io.enq.valid <= ready_writeResponseQueue_io_enq_w_2.valid @[MultiEnqueue.scala 117:10]
          ready_writeResponseQueue_io_enq_w_2.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
          io.in.writeAddress.ready <= UInt<1>("h00") @[Decoupled.scala 72:20]
          node _T_21 = and(io.in.writeAddress.valid, writeEnqueuer.io.in.ready) @[MemBoundarySplitter.scala 288:37]
          when _T_21 : @[MemBoundarySplitter.scala 288:47]
            node _writeAddressCounter_T = add(writeAddressCounter, availableAddresses_1) @[MemBoundarySplitter.scala 290:52]
            node _writeAddressCounter_T_1 = tail(_writeAddressCounter_T, 1) @[MemBoundarySplitter.scala 290:52]
            writeAddressCounter <= _writeAddressCounter_T_1 @[MemBoundarySplitter.scala 290:29]
            node _writeLenCounter_T_2 = add(len_1, UInt<1>("h01")) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_3 = tail(_writeLenCounter_T_2, 1) @[MemBoundarySplitter.scala 292:51]
            node _writeLenCounter_T_4 = sub(writeLenCounter, _writeLenCounter_T_3) @[MemBoundarySplitter.scala 292:44]
            node _writeLenCounter_T_5 = tail(_writeLenCounter_T_4, 1) @[MemBoundarySplitter.scala 292:44]
            writeLenCounter <= _writeLenCounter_T_5 @[MemBoundarySplitter.scala 292:25]
            skip @[MemBoundarySplitter.scala 288:47]
          skip @[MemBoundarySplitter.scala 276:17]
      skip @[MemBoundarySplitter.scala 224:76]
    else : @[MemBoundarySplitter.scala 295:15]
      writeEnqueuer.io.in.valid <= io.in.writeAddress.valid @[MultiEnqueue.scala 114:17]
      wire io_in_writeAddress_ready_io_out_writeAddress_w : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.qos <= io.in.writeAddress.bits.qos @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.prot <= io.in.writeAddress.bits.prot @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.cache <= io.in.writeAddress.bits.cache @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.lock <= io.in.writeAddress.bits.lock @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.burst <= io.in.writeAddress.bits.burst @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.size <= io.in.writeAddress.bits.size @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.len <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.addr <= io.in.writeAddress.bits.addr @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.bits.id <= io.in.writeAddress.bits.id @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_io_out_writeAddress_w.valid <= writeEnqueuer.io.out[0].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[0].ready <= io_in_writeAddress_ready_io_out_writeAddress_w.ready @[ReadyValid.scala 19:11]
      io.out.writeAddress.bits.qos <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.qos @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.prot <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.prot @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.cache <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.cache @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.lock <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.lock @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.burst <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.burst @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.size <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.size @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.len <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.len @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.addr <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.addr @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.bits.id <= io_in_writeAddress_ready_io_out_writeAddress_w.bits.id @[MultiEnqueue.scala 115:10]
      io.out.writeAddress.valid <= io_in_writeAddress_ready_io_out_writeAddress_w.valid @[MultiEnqueue.scala 115:10]
      io_in_writeAddress_ready_io_out_writeAddress_w.ready <= io.out.writeAddress.ready @[MultiEnqueue.scala 115:10]
      wire io_in_writeAddress_ready_writeDataQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits <= io.in.writeAddress.bits.len @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid <= writeEnqueuer.io.out[1].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[1].ready <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeDataQueue.io.enq.bits <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.bits @[MultiEnqueue.scala 116:10]
      writeDataQueue.io.enq.valid <= io_in_writeAddress_ready_writeDataQueue_io_enq_w.valid @[MultiEnqueue.scala 116:10]
      io_in_writeAddress_ready_writeDataQueue_io_enq_w.ready <= writeDataQueue.io.enq.ready @[MultiEnqueue.scala 116:10]
      wire io_in_writeAddress_ready_writeResponseQueue_io_enq_w : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>} @[ReadyValid.scala 16:17]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits <= UInt<1>("h01") @[ReadyValid.scala 17:12]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid <= writeEnqueuer.io.out[2].valid @[ReadyValid.scala 18:13]
      writeEnqueuer.io.out[2].ready <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready @[ReadyValid.scala 19:11]
      writeResponseQueue.io.enq.bits <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.bits @[MultiEnqueue.scala 117:10]
      writeResponseQueue.io.enq.valid <= io_in_writeAddress_ready_writeResponseQueue_io_enq_w.valid @[MultiEnqueue.scala 117:10]
      io_in_writeAddress_ready_writeResponseQueue_io_enq_w.ready <= writeResponseQueue.io.enq.ready @[MultiEnqueue.scala 117:10]
      io.in.writeAddress.ready <= writeEnqueuer.io.in.ready @[MemBoundarySplitter.scala 296:30]
      skip @[MemBoundarySplitter.scala 295:15]
    
  module Queue_34 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, count : UInt<2>}
    
    cmem ram : {write : UInt<1>, address : UInt<20>, size : UInt<20>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module RequestSplitter : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    wire _sizeCounter_WIRE : UInt<20> @[package.scala 77:41]
    _sizeCounter_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    reg sizeCounter : UInt, clock with : (reset => (reset, _sizeCounter_WIRE)) @[RequestSplitter.scala 21:33]
    reg sizeCounterValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RequestSplitter.scala 22:33]
    wire _addressOffset_WIRE : UInt<20> @[package.scala 77:41]
    _addressOffset_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    reg addressOffset : UInt, clock with : (reset => (reset, _addressOffset_WIRE)) @[RequestSplitter.scala 23:33]
    node _address_T = add(io.in.bits.address, addressOffset) @[RequestSplitter.scala 24:42]
    node address = tail(_address_T, 1) @[RequestSplitter.scala 24:42]
    node _T = lt(io.in.bits.size, UInt<8>("h080")) @[RequestSplitter.scala 26:21]
    when _T : @[RequestSplitter.scala 26:34]
      io.out.bits.size <= io.in.bits.size @[RequestSplitter.scala 27:12]
      io.out.bits.address <= io.in.bits.address @[RequestSplitter.scala 27:12]
      io.out.bits.write <= io.in.bits.write @[RequestSplitter.scala 27:12]
      io.out.valid <= io.in.valid @[RequestSplitter.scala 27:12]
      io.in.ready <= io.out.ready @[RequestSplitter.scala 27:12]
      skip @[RequestSplitter.scala 26:34]
    else : @[RequestSplitter.scala 28:15]
      node _T_1 = lt(sizeCounter, UInt<8>("h080")) @[RequestSplitter.scala 29:42]
      node _T_2 = and(sizeCounterValid, _T_1) @[RequestSplitter.scala 29:27]
      when _T_2 : @[RequestSplitter.scala 29:55]
        wire io_out_bits_w : {write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 76:19]
        io_out_bits_w.address <= address @[MemControl.scala 77:17]
        io_out_bits_w.write <= io.in.bits.write @[MemControl.scala 78:15]
        io_out_bits_w.size <= sizeCounter @[MemControl.scala 79:14]
        io.out.bits.size <= io_out_bits_w.size @[RequestSplitter.scala 30:19]
        io.out.bits.address <= io_out_bits_w.address @[RequestSplitter.scala 30:19]
        io.out.bits.write <= io_out_bits_w.write @[RequestSplitter.scala 30:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 36:20]
        io.in.ready <= io.out.ready @[RequestSplitter.scala 37:16]
        node _T_3 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 38:21]
        when _T_3 : @[RequestSplitter.scala 38:38]
          sizeCounterValid <= UInt<1>("h00") @[RequestSplitter.scala 39:26]
          addressOffset <= UInt<1>("h00") @[RequestSplitter.scala 40:23]
          skip @[RequestSplitter.scala 38:38]
        skip @[RequestSplitter.scala 29:55]
      else : @[RequestSplitter.scala 42:17]
        wire io_out_bits_w_1 : {write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 76:19]
        io_out_bits_w_1.address <= address @[MemControl.scala 77:17]
        io_out_bits_w_1.write <= io.in.bits.write @[MemControl.scala 78:15]
        io_out_bits_w_1.size <= UInt<7>("h07f") @[MemControl.scala 79:14]
        io.out.bits.size <= io_out_bits_w_1.size @[RequestSplitter.scala 43:19]
        io.out.bits.address <= io_out_bits_w_1.address @[RequestSplitter.scala 43:19]
        io.out.bits.write <= io_out_bits_w_1.write @[RequestSplitter.scala 43:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 49:20]
        io.in.ready <= UInt<1>("h00") @[RequestSplitter.scala 50:16]
        node _T_4 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 51:21]
        when _T_4 : @[RequestSplitter.scala 51:38]
          when sizeCounterValid : @[RequestSplitter.scala 52:32]
            node _sizeCounter_T = sub(sizeCounter, UInt<8>("h080")) @[RequestSplitter.scala 53:38]
            node _sizeCounter_T_1 = tail(_sizeCounter_T, 1) @[RequestSplitter.scala 53:38]
            sizeCounter <= _sizeCounter_T_1 @[RequestSplitter.scala 53:23]
            node _addressOffset_T = add(addressOffset, UInt<8>("h080")) @[RequestSplitter.scala 54:42]
            node _addressOffset_T_1 = tail(_addressOffset_T, 1) @[RequestSplitter.scala 54:42]
            addressOffset <= _addressOffset_T_1 @[RequestSplitter.scala 54:25]
            skip @[RequestSplitter.scala 52:32]
          else : @[RequestSplitter.scala 55:21]
            node _sizeCounter_T_2 = sub(io.in.bits.size, UInt<8>("h080")) @[RequestSplitter.scala 56:39]
            node _sizeCounter_T_3 = tail(_sizeCounter_T_2, 1) @[RequestSplitter.scala 56:39]
            sizeCounter <= _sizeCounter_T_3 @[RequestSplitter.scala 56:23]
            addressOffset <= UInt<8>("h080") @[RequestSplitter.scala 57:25]
            sizeCounterValid <= UInt<1>("h01") @[RequestSplitter.scala 58:28]
            skip @[RequestSplitter.scala 55:21]
          skip @[RequestSplitter.scala 51:38]
        skip @[RequestSplitter.scala 42:17]
      skip @[RequestSplitter.scala 28:15]
    
  module Queue_35 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_36 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_37 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, resp : UInt<2>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module VectorSerializer : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    
    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 79:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 79:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 79:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 79:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 79:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 79:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 79:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 79:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 79:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 79:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 79:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 79:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 79:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 79:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 79:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 79:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorSerializer.scala 37:30]
    reg bits : Fixed<16><<8>>[8], clock with : (reset => (reset, _bits_WIRE_8)) @[VectorSerializer.scala 37:22]
    reg valid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[VectorSerializer.scala 38:22]
    node _T = and(valid, io.out.ready) @[VectorSerializer.scala 40:48]
    reg ctr : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h00")
    when _T : @[Counter.scala 118:17]
      node wrap_wrap = eq(ctr, UInt<1>("h01")) @[Counter.scala 72:24]
      node _wrap_value_T = add(ctr, UInt<1>("h01")) @[Counter.scala 76:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 76:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 76:15]
      wrap <= wrap_wrap @[Counter.scala 118:24]
      skip @[Counter.scala 118:17]
    node _out_T = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_1 = add(_out_T, UInt<1>("h00")) @[VectorSerializer.scala 46:40]
    node _out_T_2 = tail(_out_T_1, 1) @[VectorSerializer.scala 46:40]
    node _out_T_3 = bits(_out_T_2, 2, 0)
    node _out_T_4 = asUInt(bits[_out_T_3]) @[VectorSerializer.scala 46:47]
    wire out_0 : UInt<16> @[Extend.scala 40:17]
    out_0 <= _out_T_4 @[Extend.scala 41:7]
    node _out_T_5 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_6 = add(_out_T_5, UInt<1>("h01")) @[VectorSerializer.scala 46:40]
    node _out_T_7 = tail(_out_T_6, 1) @[VectorSerializer.scala 46:40]
    node _out_T_8 = bits(_out_T_7, 2, 0)
    node _out_T_9 = asUInt(bits[_out_T_8]) @[VectorSerializer.scala 46:47]
    wire out_1 : UInt<16> @[Extend.scala 40:17]
    out_1 <= _out_T_9 @[Extend.scala 41:7]
    node _out_T_10 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_11 = add(_out_T_10, UInt<2>("h02")) @[VectorSerializer.scala 46:40]
    node _out_T_12 = tail(_out_T_11, 1) @[VectorSerializer.scala 46:40]
    node _out_T_13 = bits(_out_T_12, 2, 0)
    node _out_T_14 = asUInt(bits[_out_T_13]) @[VectorSerializer.scala 46:47]
    wire out_2 : UInt<16> @[Extend.scala 40:17]
    out_2 <= _out_T_14 @[Extend.scala 41:7]
    node _out_T_15 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_16 = add(_out_T_15, UInt<2>("h03")) @[VectorSerializer.scala 46:40]
    node _out_T_17 = tail(_out_T_16, 1) @[VectorSerializer.scala 46:40]
    node _out_T_18 = bits(_out_T_17, 2, 0)
    node _out_T_19 = asUInt(bits[_out_T_18]) @[VectorSerializer.scala 46:47]
    wire out_3 : UInt<16> @[Extend.scala 40:17]
    out_3 <= _out_T_19 @[Extend.scala 41:7]
    io.out.valid <= valid @[VectorSerializer.scala 50:16]
    node io_out_bits_lo = cat(out_1, out_0) @[Cat.scala 30:58]
    node io_out_bits_hi = cat(out_3, out_2) @[Cat.scala 30:58]
    node _io_out_bits_T = cat(io_out_bits_hi, io_out_bits_lo) @[Cat.scala 30:58]
    wire _io_out_bits_WIRE : UInt<64> @[VectorSerializer.scala 51:43]
    _io_out_bits_WIRE <= _io_out_bits_T @[VectorSerializer.scala 51:43]
    io.out.bits <= _io_out_bits_WIRE @[VectorSerializer.scala 51:15]
    node _io_in_ready_T = eq(valid, UInt<1>("h00")) @[VectorSerializer.scala 52:18]
    node _io_in_ready_T_1 = or(_io_in_ready_T, wrap) @[VectorSerializer.scala 52:25]
    io.in.ready <= _io_in_ready_T_1 @[VectorSerializer.scala 52:15]
    when io.in.ready : @[VectorSerializer.scala 54:21]
      when io.in.valid : @[VectorSerializer.scala 55:23]
        wire _WIRE : Fixed<16><<8>>[8] @[VectorSerializer.scala 56:34]
        node lo_lo_lo = asUInt(io.in.bits[0]) @[VectorSerializer.scala 56:34]
        node lo_lo_hi = asUInt(io.in.bits[1]) @[VectorSerializer.scala 56:34]
        node lo_hi_lo = asUInt(io.in.bits[2]) @[VectorSerializer.scala 56:34]
        node lo_hi_hi = asUInt(io.in.bits[3]) @[VectorSerializer.scala 56:34]
        node hi_lo_lo = asUInt(io.in.bits[4]) @[VectorSerializer.scala 56:34]
        node hi_lo_hi = asUInt(io.in.bits[5]) @[VectorSerializer.scala 56:34]
        node hi_hi_lo = asUInt(io.in.bits[6]) @[VectorSerializer.scala 56:34]
        node hi_hi_hi = asUInt(io.in.bits[7]) @[VectorSerializer.scala 56:34]
        node lo_lo = cat(lo_lo_hi, lo_lo_lo) @[VectorSerializer.scala 56:34]
        node lo_hi = cat(lo_hi_hi, lo_hi_lo) @[VectorSerializer.scala 56:34]
        node lo = cat(lo_hi, lo_lo) @[VectorSerializer.scala 56:34]
        node hi_lo = cat(hi_lo_hi, hi_lo_lo) @[VectorSerializer.scala 56:34]
        node hi_hi = cat(hi_hi_hi, hi_hi_lo) @[VectorSerializer.scala 56:34]
        node hi = cat(hi_hi, hi_lo) @[VectorSerializer.scala 56:34]
        node _T_1 = cat(hi, lo) @[VectorSerializer.scala 56:34]
        wire _WIRE_1 : UInt<128>
        _WIRE_1 <= _T_1
        node _T_2 = bits(_WIRE_1, 15, 0) @[VectorSerializer.scala 56:34]
        node _T_3 = asFixedPoint(_T_2, 8) @[VectorSerializer.scala 56:34]
        _WIRE[0] <= _T_3 @[VectorSerializer.scala 56:34]
        node _T_4 = bits(_WIRE_1, 31, 16) @[VectorSerializer.scala 56:34]
        node _T_5 = asFixedPoint(_T_4, 8) @[VectorSerializer.scala 56:34]
        _WIRE[1] <= _T_5 @[VectorSerializer.scala 56:34]
        node _T_6 = bits(_WIRE_1, 47, 32) @[VectorSerializer.scala 56:34]
        node _T_7 = asFixedPoint(_T_6, 8) @[VectorSerializer.scala 56:34]
        _WIRE[2] <= _T_7 @[VectorSerializer.scala 56:34]
        node _T_8 = bits(_WIRE_1, 63, 48) @[VectorSerializer.scala 56:34]
        node _T_9 = asFixedPoint(_T_8, 8) @[VectorSerializer.scala 56:34]
        _WIRE[3] <= _T_9 @[VectorSerializer.scala 56:34]
        node _T_10 = bits(_WIRE_1, 79, 64) @[VectorSerializer.scala 56:34]
        node _T_11 = asFixedPoint(_T_10, 8) @[VectorSerializer.scala 56:34]
        _WIRE[4] <= _T_11 @[VectorSerializer.scala 56:34]
        node _T_12 = bits(_WIRE_1, 95, 80) @[VectorSerializer.scala 56:34]
        node _T_13 = asFixedPoint(_T_12, 8) @[VectorSerializer.scala 56:34]
        _WIRE[5] <= _T_13 @[VectorSerializer.scala 56:34]
        node _T_14 = bits(_WIRE_1, 111, 96) @[VectorSerializer.scala 56:34]
        node _T_15 = asFixedPoint(_T_14, 8) @[VectorSerializer.scala 56:34]
        _WIRE[6] <= _T_15 @[VectorSerializer.scala 56:34]
        node _T_16 = bits(_WIRE_1, 127, 112) @[VectorSerializer.scala 56:34]
        node _T_17 = asFixedPoint(_T_16, 8) @[VectorSerializer.scala 56:34]
        _WIRE[7] <= _T_17 @[VectorSerializer.scala 56:34]
        bits[0] <= _WIRE[0] @[VectorSerializer.scala 56:12]
        bits[1] <= _WIRE[1] @[VectorSerializer.scala 56:12]
        bits[2] <= _WIRE[2] @[VectorSerializer.scala 56:12]
        bits[3] <= _WIRE[3] @[VectorSerializer.scala 56:12]
        bits[4] <= _WIRE[4] @[VectorSerializer.scala 56:12]
        bits[5] <= _WIRE[5] @[VectorSerializer.scala 56:12]
        bits[6] <= _WIRE[6] @[VectorSerializer.scala 56:12]
        bits[7] <= _WIRE[7] @[VectorSerializer.scala 56:12]
        valid <= UInt<1>("h01") @[VectorSerializer.scala 57:13]
        skip @[VectorSerializer.scala 55:23]
      else : @[VectorSerializer.scala 58:17]
        valid <= UInt<1>("h00") @[VectorSerializer.scala 59:13]
        skip @[VectorSerializer.scala 58:17]
      skip @[VectorSerializer.scala 54:21]
    
  module Counter_14 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module DataCounter : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip len : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, last : UInt<1>}
    
    inst counter of Counter_14 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.bits <= io.in.bits @[DataCounter.scala 25:15]
    node _io_out_valid_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 26:28]
    io.out.valid <= _io_out_valid_T @[DataCounter.scala 26:16]
    node _io_in_ready_T = and(io.len.valid, io.out.ready) @[DataCounter.scala 27:25]
    io.in.ready <= _io_in_ready_T @[DataCounter.scala 27:12]
    node _T = eq(counter.io.value.bits, io.len.bits) @[DataCounter.scala 29:30]
    when _T : @[DataCounter.scala 29:44]
      node _io_last_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 30:25]
      io.last <= _io_last_T @[DataCounter.scala 30:13]
      node _io_len_ready_T = and(io.in.valid, io.out.ready) @[DataCounter.scala 31:27]
      io.len.ready <= _io_len_ready_T @[DataCounter.scala 31:15]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[DataCounter.scala 32:27]
      skip @[DataCounter.scala 29:44]
    else : @[DataCounter.scala 33:15]
      io.len.ready <= UInt<1>("h00") @[DataCounter.scala 34:15]
      io.last <= UInt<1>("h00") @[DataCounter.scala 35:13]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[DataCounter.scala 36:28]
      skip @[DataCounter.scala 33:15]
    
  module VectorDeserializer : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 79:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 79:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 79:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 79:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 79:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 79:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 79:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 79:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 79:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 79:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 79:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 79:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 79:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 79:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 79:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 79:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorDeserializer.scala 41:32]
    reg bits : Fixed<16><<8>>[8], clock with : (reset => (reset, _bits_WIRE_8)) @[VectorDeserializer.scala 41:24]
    reg valid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[VectorDeserializer.scala 42:24]
    node _T = and(io.in.ready, io.in.valid) @[Decoupled.scala 40:37]
    reg ctr : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h00")
    when _T : @[Counter.scala 118:17]
      node wrap_wrap = eq(ctr, UInt<1>("h01")) @[Counter.scala 72:24]
      node _wrap_value_T = add(ctr, UInt<1>("h01")) @[Counter.scala 76:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 76:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 76:15]
      wrap <= wrap_wrap @[Counter.scala 118:24]
      skip @[Counter.scala 118:17]
    io.out.valid <= valid @[VectorDeserializer.scala 47:18]
    io.out.bits[0] <= bits[0] @[VectorDeserializer.scala 48:17]
    io.out.bits[1] <= bits[1] @[VectorDeserializer.scala 48:17]
    io.out.bits[2] <= bits[2] @[VectorDeserializer.scala 48:17]
    io.out.bits[3] <= bits[3] @[VectorDeserializer.scala 48:17]
    io.out.bits[4] <= bits[4] @[VectorDeserializer.scala 48:17]
    io.out.bits[5] <= bits[5] @[VectorDeserializer.scala 48:17]
    io.out.bits[6] <= bits[6] @[VectorDeserializer.scala 48:17]
    io.out.bits[7] <= bits[7] @[VectorDeserializer.scala 48:17]
    node _io_in_ready_T = eq(valid, UInt<1>("h00")) @[VectorDeserializer.scala 50:20]
    node _io_in_ready_T_1 = or(_io_in_ready_T, io.out.ready) @[VectorDeserializer.scala 50:27]
    io.in.ready <= _io_in_ready_T_1 @[VectorDeserializer.scala 50:17]
    node _T_1 = and(io.in.ready, io.in.valid) @[Decoupled.scala 40:37]
    when _T_1 : @[VectorDeserializer.scala 52:24]
      node _T_2 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_3 = add(_T_2, UInt<1>("h00")) @[VectorDeserializer.scala 54:40]
      node _T_4 = tail(_T_3, 1) @[VectorDeserializer.scala 54:40]
      node _T_5 = bits(_T_4, 2, 0)
      node _bits_T_16 = bits(io.in.bits, 15, 0) @[VectorDeserializer.scala 55:30]
      wire bits_w : UInt<16> @[Extend.scala 40:17]
      bits_w <= _bits_T_16 @[Extend.scala 41:7]
      wire _bits_WIRE_9 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_17 = asFixedPoint(bits_w, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_9 <= _bits_T_17 @[VectorDeserializer.scala 37:57]
      bits[_T_5] <= _bits_WIRE_9 @[VectorDeserializer.scala 54:47]
      node _T_6 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_7 = add(_T_6, UInt<1>("h01")) @[VectorDeserializer.scala 54:40]
      node _T_8 = tail(_T_7, 1) @[VectorDeserializer.scala 54:40]
      node _T_9 = bits(_T_8, 2, 0)
      node _bits_T_18 = bits(io.in.bits, 31, 16) @[VectorDeserializer.scala 55:30]
      wire bits_w_1 : UInt<16> @[Extend.scala 40:17]
      bits_w_1 <= _bits_T_18 @[Extend.scala 41:7]
      wire _bits_WIRE_10 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_19 = asFixedPoint(bits_w_1, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_10 <= _bits_T_19 @[VectorDeserializer.scala 37:57]
      bits[_T_9] <= _bits_WIRE_10 @[VectorDeserializer.scala 54:47]
      node _T_10 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_11 = add(_T_10, UInt<2>("h02")) @[VectorDeserializer.scala 54:40]
      node _T_12 = tail(_T_11, 1) @[VectorDeserializer.scala 54:40]
      node _T_13 = bits(_T_12, 2, 0)
      node _bits_T_20 = bits(io.in.bits, 47, 32) @[VectorDeserializer.scala 55:30]
      wire bits_w_2 : UInt<16> @[Extend.scala 40:17]
      bits_w_2 <= _bits_T_20 @[Extend.scala 41:7]
      wire _bits_WIRE_11 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_21 = asFixedPoint(bits_w_2, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_11 <= _bits_T_21 @[VectorDeserializer.scala 37:57]
      bits[_T_13] <= _bits_WIRE_11 @[VectorDeserializer.scala 54:47]
      node _T_14 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_15 = add(_T_14, UInt<2>("h03")) @[VectorDeserializer.scala 54:40]
      node _T_16 = tail(_T_15, 1) @[VectorDeserializer.scala 54:40]
      node _T_17 = bits(_T_16, 2, 0)
      node _bits_T_22 = bits(io.in.bits, 63, 48) @[VectorDeserializer.scala 55:30]
      wire bits_w_3 : UInt<16> @[Extend.scala 40:17]
      bits_w_3 <= _bits_T_22 @[Extend.scala 41:7]
      wire _bits_WIRE_12 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_23 = asFixedPoint(bits_w_3, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_12 <= _bits_T_23 @[VectorDeserializer.scala 37:57]
      bits[_T_17] <= _bits_WIRE_12 @[VectorDeserializer.scala 54:47]
      valid <= wrap @[VectorDeserializer.scala 61:13]
      skip @[VectorDeserializer.scala 52:24]
    node _T_18 = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
    when _T_18 : @[VectorDeserializer.scala 63:25]
      valid <= UInt<1>("h00") @[VectorDeserializer.scala 64:13]
      skip @[VectorDeserializer.scala 63:25]
    
  module MultiEnqueue_20 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module Converter : 
    input clock : Clock
    input reset : Reset
    output io : {mem : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, axi : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, flip addressOffset : UInt<32>, flip cacheBehavior : UInt<4>, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst control_q of Queue_34 @[Converter.scala 66:25]
    control_q.clock <= clock
    control_q.reset <= reset
    control_q.io.enq.bits.size <= io.mem.control.bits.size @[Converter.scala 66:25]
    control_q.io.enq.bits.address <= io.mem.control.bits.address @[Converter.scala 66:25]
    control_q.io.enq.bits.write <= io.mem.control.bits.write @[Converter.scala 66:25]
    control_q.io.enq.valid <= io.mem.control.valid @[Converter.scala 66:25]
    io.mem.control.ready <= control_q.io.enq.ready @[Converter.scala 66:25]
    inst control_splitter of RequestSplitter @[RequestSplitter.scala 69:26]
    control_splitter.clock <= clock
    control_splitter.reset <= reset
    control_splitter.io.in.bits.size <= control_q.io.deq.bits.size @[RequestSplitter.scala 70:20]
    control_splitter.io.in.bits.address <= control_q.io.deq.bits.address @[RequestSplitter.scala 70:20]
    control_splitter.io.in.bits.write <= control_q.io.deq.bits.write @[RequestSplitter.scala 70:20]
    control_splitter.io.in.valid <= control_q.io.deq.valid @[RequestSplitter.scala 70:20]
    control_q.io.deq.ready <= control_splitter.io.in.ready @[RequestSplitter.scala 70:20]
    inst dataOut of Queue_35 @[Converter.scala 68:41]
    dataOut.clock <= clock
    dataOut.reset <= reset
    dataOut.io.enq.bits[0] <= io.mem.dataOut.bits[0] @[Converter.scala 68:41]
    dataOut.io.enq.bits[1] <= io.mem.dataOut.bits[1] @[Converter.scala 68:41]
    dataOut.io.enq.bits[2] <= io.mem.dataOut.bits[2] @[Converter.scala 68:41]
    dataOut.io.enq.bits[3] <= io.mem.dataOut.bits[3] @[Converter.scala 68:41]
    dataOut.io.enq.bits[4] <= io.mem.dataOut.bits[4] @[Converter.scala 68:41]
    dataOut.io.enq.bits[5] <= io.mem.dataOut.bits[5] @[Converter.scala 68:41]
    dataOut.io.enq.bits[6] <= io.mem.dataOut.bits[6] @[Converter.scala 68:41]
    dataOut.io.enq.bits[7] <= io.mem.dataOut.bits[7] @[Converter.scala 68:41]
    dataOut.io.enq.valid <= io.mem.dataOut.valid @[Converter.scala 68:41]
    io.mem.dataOut.ready <= dataOut.io.enq.ready @[Converter.scala 68:41]
    inst readData of Queue_36 @[Converter.scala 69:41]
    readData.clock <= clock
    readData.reset <= reset
    readData.io.enq.bits.last <= io.axi.readData.bits.last @[Converter.scala 69:41]
    readData.io.enq.bits.resp <= io.axi.readData.bits.resp @[Converter.scala 69:41]
    readData.io.enq.bits.data <= io.axi.readData.bits.data @[Converter.scala 69:41]
    readData.io.enq.bits.id <= io.axi.readData.bits.id @[Converter.scala 69:41]
    readData.io.enq.valid <= io.axi.readData.valid @[Converter.scala 69:41]
    io.axi.readData.ready <= readData.io.enq.ready @[Converter.scala 69:41]
    inst writeResponse of Queue_37 @[Converter.scala 70:41]
    writeResponse.clock <= clock
    writeResponse.reset <= reset
    writeResponse.io.enq.bits.resp <= io.axi.writeResponse.bits.resp @[Converter.scala 70:41]
    writeResponse.io.enq.bits.id <= io.axi.writeResponse.bits.id @[Converter.scala 70:41]
    writeResponse.io.enq.valid <= io.axi.writeResponse.valid @[Converter.scala 70:41]
    io.axi.writeResponse.ready <= writeResponse.io.enq.ready @[Converter.scala 70:41]
    node address = mul(control_splitter.io.out.bits.address, UInt<5>("h010")) @[Converter.scala 79:26]
    node _size_T = add(control_splitter.io.out.bits.size, UInt<1>("h01")) @[Converter.scala 82:24]
    node _size_T_1 = tail(_size_T, 1) @[Converter.scala 82:24]
    node _size_T_2 = mul(_size_T_1, UInt<2>("h02")) @[Converter.scala 82:31]
    node _size_T_3 = sub(_size_T_2, UInt<1>("h01")) @[Converter.scala 82:68]
    node size = tail(_size_T_3, 1) @[Converter.scala 82:68]
    inst ser of VectorSerializer @[Converter.scala 90:19]
    ser.clock <= clock
    ser.reset <= reset
    ser.io.in.bits[0] <= dataOut.io.deq.bits[0] @[Converter.scala 98:13]
    ser.io.in.bits[1] <= dataOut.io.deq.bits[1] @[Converter.scala 98:13]
    ser.io.in.bits[2] <= dataOut.io.deq.bits[2] @[Converter.scala 98:13]
    ser.io.in.bits[3] <= dataOut.io.deq.bits[3] @[Converter.scala 98:13]
    ser.io.in.bits[4] <= dataOut.io.deq.bits[4] @[Converter.scala 98:13]
    ser.io.in.bits[5] <= dataOut.io.deq.bits[5] @[Converter.scala 98:13]
    ser.io.in.bits[6] <= dataOut.io.deq.bits[6] @[Converter.scala 98:13]
    ser.io.in.bits[7] <= dataOut.io.deq.bits[7] @[Converter.scala 98:13]
    ser.io.in.valid <= dataOut.io.deq.valid @[Converter.scala 98:13]
    dataOut.io.deq.ready <= ser.io.in.ready @[Converter.scala 98:13]
    inst serCounter of DataCounter @[Converter.scala 100:26]
    serCounter.clock <= clock
    serCounter.reset <= reset
    serCounter.io.in.bits <= ser.io.out.bits @[Converter.scala 103:20]
    serCounter.io.in.valid <= ser.io.out.valid @[Converter.scala 103:20]
    ser.io.out.ready <= serCounter.io.in.ready @[Converter.scala 103:20]
    serCounter.io.len.bits <= size @[Converter.scala 104:26]
    serCounter.io.len.valid <= UInt<1>("h00") @[Converter.scala 105:27]
    inst des of VectorDeserializer @[Converter.scala 109:19]
    des.clock <= clock
    des.reset <= reset
    io.mem.dataIn.bits[0] <= des.io.out.bits[0] @[Converter.scala 117:17]
    io.mem.dataIn.bits[1] <= des.io.out.bits[1] @[Converter.scala 117:17]
    io.mem.dataIn.bits[2] <= des.io.out.bits[2] @[Converter.scala 117:17]
    io.mem.dataIn.bits[3] <= des.io.out.bits[3] @[Converter.scala 117:17]
    io.mem.dataIn.bits[4] <= des.io.out.bits[4] @[Converter.scala 117:17]
    io.mem.dataIn.bits[5] <= des.io.out.bits[5] @[Converter.scala 117:17]
    io.mem.dataIn.bits[6] <= des.io.out.bits[6] @[Converter.scala 117:17]
    io.mem.dataIn.bits[7] <= des.io.out.bits[7] @[Converter.scala 117:17]
    io.mem.dataIn.valid <= des.io.out.valid @[Converter.scala 117:17]
    des.io.out.ready <= io.mem.dataIn.ready @[Converter.scala 117:17]
    reg writeResponseCount : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Converter.scala 124:35]
    reg readResponseCount : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Converter.scala 125:35]
    node _canWrite_T = eq(readResponseCount, UInt<1>("h00")) @[Converter.scala 127:24]
    node _canWrite_T_1 = lt(writeResponseCount, UInt<8>("h0ff")) @[Converter.scala 127:56]
    node canWrite = and(_canWrite_T, _canWrite_T_1) @[Converter.scala 127:33]
    node _canRead_T = eq(writeResponseCount, UInt<1>("h00")) @[Converter.scala 129:25]
    node _canRead_T_1 = lt(readResponseCount, UInt<8>("h0ff")) @[Converter.scala 129:56]
    node canRead = and(_canRead_T, _canRead_T_1) @[Converter.scala 129:34]
    node writeRequested = and(io.axi.writeAddress.ready, io.axi.writeAddress.valid) @[Converter.scala 130:50]
    node writeResponded = and(writeResponse.io.deq.ready, writeResponse.io.deq.valid) @[Converter.scala 131:44]
    node readRequested = and(io.axi.readAddress.ready, io.axi.readAddress.valid) @[Converter.scala 132:49]
    node _readResponded_T = and(readData.io.deq.ready, readData.io.deq.valid) @[Converter.scala 133:39]
    node readResponded = and(_readResponded_T, readData.io.deq.bits.last) @[Converter.scala 133:57]
    when writeRequested : @[Converter.scala 134:24]
      when writeResponded : @[Converter.scala 135:26]
        skip @[Converter.scala 135:26]
      else : @[Converter.scala 137:17]
        node _T = lt(writeResponseCount, UInt<8>("h0ff")) @[Converter.scala 138:31]
        when _T : @[Converter.scala 138:62]
          node _writeResponseCount_T = add(writeResponseCount, UInt<1>("h01")) @[Converter.scala 139:50]
          node _writeResponseCount_T_1 = tail(_writeResponseCount_T, 1) @[Converter.scala 139:50]
          writeResponseCount <= _writeResponseCount_T_1 @[Converter.scala 139:28]
          skip @[Converter.scala 138:62]
        skip @[Converter.scala 137:17]
      skip @[Converter.scala 134:24]
    else : @[Converter.scala 142:15]
      node _T_1 = gt(writeResponseCount, UInt<1>("h00")) @[Converter.scala 143:47]
      node _T_2 = and(writeResponded, _T_1) @[Converter.scala 143:25]
      when _T_2 : @[Converter.scala 143:54]
        node _writeResponseCount_T_2 = sub(writeResponseCount, UInt<1>("h01")) @[Converter.scala 144:48]
        node _writeResponseCount_T_3 = tail(_writeResponseCount_T_2, 1) @[Converter.scala 144:48]
        writeResponseCount <= _writeResponseCount_T_3 @[Converter.scala 144:26]
        skip @[Converter.scala 143:54]
      else : @[Converter.scala 145:17]
        skip @[Converter.scala 145:17]
      skip @[Converter.scala 142:15]
    when readRequested : @[Converter.scala 149:23]
      when readResponded : @[Converter.scala 150:25]
        skip @[Converter.scala 150:25]
      else : @[Converter.scala 152:17]
        node _T_3 = lt(readResponseCount, UInt<8>("h0ff")) @[Converter.scala 153:30]
        when _T_3 : @[Converter.scala 153:61]
          node _readResponseCount_T = add(readResponseCount, UInt<1>("h01")) @[Converter.scala 154:48]
          node _readResponseCount_T_1 = tail(_readResponseCount_T, 1) @[Converter.scala 154:48]
          readResponseCount <= _readResponseCount_T_1 @[Converter.scala 154:27]
          skip @[Converter.scala 153:61]
        skip @[Converter.scala 152:17]
      skip @[Converter.scala 149:23]
    else : @[Converter.scala 157:15]
      node _T_4 = gt(readResponseCount, UInt<1>("h00")) @[Converter.scala 158:45]
      node _T_5 = and(readResponded, _T_4) @[Converter.scala 158:24]
      when _T_5 : @[Converter.scala 158:52]
        node _readResponseCount_T_2 = sub(readResponseCount, UInt<1>("h01")) @[Converter.scala 159:46]
        node _readResponseCount_T_3 = tail(_readResponseCount_T_2, 1) @[Converter.scala 159:46]
        readResponseCount <= _readResponseCount_T_3 @[Converter.scala 159:25]
        skip @[Converter.scala 158:52]
      else : @[Converter.scala 160:17]
        skip @[Converter.scala 160:17]
      skip @[Converter.scala 157:15]
    io.axi.writeAddress.bits.id <= UInt<1>("h00") @[Address.scala 43:8]
    io.axi.writeAddress.bits.size <= UInt<2>("h03") @[Address.scala 47:10]
    io.axi.writeAddress.bits.burst <= UInt<1>("h01") @[Address.scala 51:11]
    io.axi.writeAddress.bits.lock <= UInt<1>("h00") @[Address.scala 55:10]
    io.axi.writeAddress.bits.cache <= UInt<1>("h00") @[Address.scala 56:11]
    io.axi.writeAddress.bits.prot <= UInt<1>("h00") @[Address.scala 57:10]
    io.axi.writeAddress.bits.qos <= UInt<1>("h00") @[Address.scala 58:9]
    node _T_6 = add(address, io.addressOffset) @[Converter.scala 169:15]
    node _T_7 = tail(_T_6, 1) @[Converter.scala 169:15]
    io.axi.writeAddress.bits.addr <= _T_7 @[Address.scala 27:10]
    io.axi.writeAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.writeAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.writeAddress.valid <= UInt<1>("h00") @[Converter.scala 173:29]
    io.axi.writeData.bits.id <= UInt<1>("h00") @[WriteData.scala 31:8]
    io.axi.writeData.bits.strb <= UInt<8>("h0ff") @[WriteData.scala 39:14]
    io.axi.writeData.bits.data <= serCounter.io.out.bits @[WriteData.scala 20:15]
    io.axi.writeData.bits.last <= serCounter.io.last @[WriteData.scala 21:15]
    io.axi.writeData.valid <= UInt<1>("h00") @[Converter.scala 179:26]
    io.axi.writeData.valid <= serCounter.io.out.valid @[Converter.scala 180:26]
    serCounter.io.out.ready <= io.axi.writeData.ready @[Converter.scala 181:16]
    writeResponse.io.deq.ready <= UInt<1>("h01") @[Converter.scala 185:23]
    io.axi.readAddress.bits.id <= UInt<1>("h00") @[Address.scala 43:8]
    io.axi.readAddress.bits.size <= UInt<2>("h03") @[Address.scala 47:10]
    io.axi.readAddress.bits.burst <= UInt<1>("h01") @[Address.scala 51:11]
    io.axi.readAddress.bits.lock <= UInt<1>("h00") @[Address.scala 55:10]
    io.axi.readAddress.bits.cache <= UInt<1>("h00") @[Address.scala 56:11]
    io.axi.readAddress.bits.prot <= UInt<1>("h00") @[Address.scala 57:10]
    io.axi.readAddress.bits.qos <= UInt<1>("h00") @[Address.scala 58:9]
    node _T_8 = add(address, io.addressOffset) @[Converter.scala 191:15]
    node _T_9 = tail(_T_8, 1) @[Converter.scala 191:15]
    io.axi.readAddress.bits.addr <= _T_9 @[Address.scala 27:10]
    io.axi.readAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.readAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.readAddress.valid <= UInt<1>("h00") @[Converter.scala 195:28]
    des.io.in.bits <= readData.io.deq.bits.data @[Converter.scala 200:18]
    des.io.in.valid <= readData.io.deq.valid @[Converter.scala 201:19]
    readData.io.deq.ready <= des.io.in.ready @[Converter.scala 202:18]
    inst writeEnqueue of MultiEnqueue_20 @[MultiEnqueue.scala 160:43]
    writeEnqueue.clock <= clock
    writeEnqueue.reset <= reset
    writeEnqueue.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    writeEnqueue.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    writeEnqueue.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    when control_splitter.io.out.bits.write : @[Converter.scala 208:28]
      node _writeEnqueue_io_in_valid_T = and(control_splitter.io.out.valid, canWrite) @[Converter.scala 209:47]
      writeEnqueue.io.in.valid <= _writeEnqueue_io_in_valid_T @[Converter.scala 209:30]
      control_splitter.io.out.ready <= writeEnqueue.io.in.ready @[Converter.scala 210:19]
      writeEnqueue.io.out[0].ready <= io.axi.writeAddress.ready @[Converter.scala 212:34]
      io.axi.writeAddress.valid <= writeEnqueue.io.out[0].valid @[Converter.scala 213:31]
      writeEnqueue.io.out[1].ready <= serCounter.io.len.ready @[Converter.scala 214:34]
      serCounter.io.len.valid <= writeEnqueue.io.out[1].valid @[Converter.scala 215:29]
      skip @[Converter.scala 208:28]
    else : @[Converter.scala 216:15]
      node _io_axi_readAddress_valid_T = and(control_splitter.io.out.valid, canRead) @[Converter.scala 217:47]
      io.axi.readAddress.valid <= _io_axi_readAddress_valid_T @[Converter.scala 217:30]
      node _splitter_io_out_ready_T = and(io.axi.readAddress.ready, canRead) @[Converter.scala 218:47]
      control_splitter.io.out.ready <= _splitter_io_out_ready_T @[Converter.scala 218:19]
      skip @[Converter.scala 216:15]
    
  module Queue_38 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.qos <= io.enq.bits.qos @[Decoupled.scala 230:24]
      MPORT.prot <= io.enq.bits.prot @[Decoupled.scala 230:24]
      MPORT.cache <= io.enq.bits.cache @[Decoupled.scala 230:24]
      MPORT.lock <= io.enq.bits.lock @[Decoupled.scala 230:24]
      MPORT.burst <= io.enq.bits.burst @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.len <= io.enq.bits.len @[Decoupled.scala 230:24]
      MPORT.addr <= io.enq.bits.addr @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.qos <= io_deq_bits_MPORT.qos @[Decoupled.scala 242:15]
    io.deq.bits.prot <= io_deq_bits_MPORT.prot @[Decoupled.scala 242:15]
    io.deq.bits.cache <= io_deq_bits_MPORT.cache @[Decoupled.scala 242:15]
    io.deq.bits.lock <= io_deq_bits_MPORT.lock @[Decoupled.scala 242:15]
    io.deq.bits.burst <= io_deq_bits_MPORT.burst @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.len <= io_deq_bits_MPORT.len @[Decoupled.scala 242:15]
    io.deq.bits.addr <= io_deq_bits_MPORT.addr @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_39 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.qos <= io.enq.bits.qos @[Decoupled.scala 230:24]
      MPORT.prot <= io.enq.bits.prot @[Decoupled.scala 230:24]
      MPORT.cache <= io.enq.bits.cache @[Decoupled.scala 230:24]
      MPORT.lock <= io.enq.bits.lock @[Decoupled.scala 230:24]
      MPORT.burst <= io.enq.bits.burst @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.len <= io.enq.bits.len @[Decoupled.scala 230:24]
      MPORT.addr <= io.enq.bits.addr @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.qos <= io_deq_bits_MPORT.qos @[Decoupled.scala 242:15]
    io.deq.bits.prot <= io_deq_bits_MPORT.prot @[Decoupled.scala 242:15]
    io.deq.bits.cache <= io_deq_bits_MPORT.cache @[Decoupled.scala 242:15]
    io.deq.bits.lock <= io_deq_bits_MPORT.lock @[Decoupled.scala 242:15]
    io.deq.bits.burst <= io_deq_bits_MPORT.burst @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.len <= io_deq_bits_MPORT.len @[Decoupled.scala 242:15]
    io.deq.bits.addr <= io_deq_bits_MPORT.addr @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_40 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.strb <= io.enq.bits.strb @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.strb <= io_deq_bits_MPORT.strb @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_41 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_42 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, resp : UInt<2>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_43 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}
    
    inst io_out_readAddress_q of Queue_38 @[Decoupled.scala 296:21]
    io_out_readAddress_q.clock <= clock
    io_out_readAddress_q.reset <= reset
    io_out_readAddress_q.io.enq.valid <= io.in.readAddress.valid @[Decoupled.scala 297:22]
    io_out_readAddress_q.io.enq.bits.qos <= io.in.readAddress.bits.qos @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.prot <= io.in.readAddress.bits.prot @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.cache <= io.in.readAddress.bits.cache @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.lock <= io.in.readAddress.bits.lock @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.burst <= io.in.readAddress.bits.burst @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.size <= io.in.readAddress.bits.size @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.len <= io.in.readAddress.bits.len @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.addr <= io.in.readAddress.bits.addr @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.id <= io.in.readAddress.bits.id @[Decoupled.scala 298:21]
    io.in.readAddress.ready <= io_out_readAddress_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.readAddress.bits.qos <= io_out_readAddress_q.io.deq.bits.qos @[Queue.scala 14:22]
    io.out.readAddress.bits.prot <= io_out_readAddress_q.io.deq.bits.prot @[Queue.scala 14:22]
    io.out.readAddress.bits.cache <= io_out_readAddress_q.io.deq.bits.cache @[Queue.scala 14:22]
    io.out.readAddress.bits.lock <= io_out_readAddress_q.io.deq.bits.lock @[Queue.scala 14:22]
    io.out.readAddress.bits.burst <= io_out_readAddress_q.io.deq.bits.burst @[Queue.scala 14:22]
    io.out.readAddress.bits.size <= io_out_readAddress_q.io.deq.bits.size @[Queue.scala 14:22]
    io.out.readAddress.bits.len <= io_out_readAddress_q.io.deq.bits.len @[Queue.scala 14:22]
    io.out.readAddress.bits.addr <= io_out_readAddress_q.io.deq.bits.addr @[Queue.scala 14:22]
    io.out.readAddress.bits.id <= io_out_readAddress_q.io.deq.bits.id @[Queue.scala 14:22]
    io.out.readAddress.valid <= io_out_readAddress_q.io.deq.valid @[Queue.scala 14:22]
    io_out_readAddress_q.io.deq.ready <= io.out.readAddress.ready @[Queue.scala 14:22]
    inst io_out_writeAddress_q of Queue_39 @[Decoupled.scala 296:21]
    io_out_writeAddress_q.clock <= clock
    io_out_writeAddress_q.reset <= reset
    io_out_writeAddress_q.io.enq.valid <= io.in.writeAddress.valid @[Decoupled.scala 297:22]
    io_out_writeAddress_q.io.enq.bits.qos <= io.in.writeAddress.bits.qos @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.prot <= io.in.writeAddress.bits.prot @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.cache <= io.in.writeAddress.bits.cache @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.lock <= io.in.writeAddress.bits.lock @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.burst <= io.in.writeAddress.bits.burst @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.size <= io.in.writeAddress.bits.size @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.len <= io.in.writeAddress.bits.len @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.addr <= io.in.writeAddress.bits.addr @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.id <= io.in.writeAddress.bits.id @[Decoupled.scala 298:21]
    io.in.writeAddress.ready <= io_out_writeAddress_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.writeAddress.bits.qos <= io_out_writeAddress_q.io.deq.bits.qos @[Queue.scala 15:23]
    io.out.writeAddress.bits.prot <= io_out_writeAddress_q.io.deq.bits.prot @[Queue.scala 15:23]
    io.out.writeAddress.bits.cache <= io_out_writeAddress_q.io.deq.bits.cache @[Queue.scala 15:23]
    io.out.writeAddress.bits.lock <= io_out_writeAddress_q.io.deq.bits.lock @[Queue.scala 15:23]
    io.out.writeAddress.bits.burst <= io_out_writeAddress_q.io.deq.bits.burst @[Queue.scala 15:23]
    io.out.writeAddress.bits.size <= io_out_writeAddress_q.io.deq.bits.size @[Queue.scala 15:23]
    io.out.writeAddress.bits.len <= io_out_writeAddress_q.io.deq.bits.len @[Queue.scala 15:23]
    io.out.writeAddress.bits.addr <= io_out_writeAddress_q.io.deq.bits.addr @[Queue.scala 15:23]
    io.out.writeAddress.bits.id <= io_out_writeAddress_q.io.deq.bits.id @[Queue.scala 15:23]
    io.out.writeAddress.valid <= io_out_writeAddress_q.io.deq.valid @[Queue.scala 15:23]
    io_out_writeAddress_q.io.deq.ready <= io.out.writeAddress.ready @[Queue.scala 15:23]
    inst io_out_writeData_q of Queue_40 @[Decoupled.scala 296:21]
    io_out_writeData_q.clock <= clock
    io_out_writeData_q.reset <= reset
    io_out_writeData_q.io.enq.valid <= io.in.writeData.valid @[Decoupled.scala 297:22]
    io_out_writeData_q.io.enq.bits.last <= io.in.writeData.bits.last @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.strb <= io.in.writeData.bits.strb @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.data <= io.in.writeData.bits.data @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.id <= io.in.writeData.bits.id @[Decoupled.scala 298:21]
    io.in.writeData.ready <= io_out_writeData_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.writeData.bits.last <= io_out_writeData_q.io.deq.bits.last @[Queue.scala 16:20]
    io.out.writeData.bits.strb <= io_out_writeData_q.io.deq.bits.strb @[Queue.scala 16:20]
    io.out.writeData.bits.data <= io_out_writeData_q.io.deq.bits.data @[Queue.scala 16:20]
    io.out.writeData.bits.id <= io_out_writeData_q.io.deq.bits.id @[Queue.scala 16:20]
    io.out.writeData.valid <= io_out_writeData_q.io.deq.valid @[Queue.scala 16:20]
    io_out_writeData_q.io.deq.ready <= io.out.writeData.ready @[Queue.scala 16:20]
    inst io_in_readData_q of Queue_41 @[Decoupled.scala 296:21]
    io_in_readData_q.clock <= clock
    io_in_readData_q.reset <= reset
    io_in_readData_q.io.enq.valid <= io.out.readData.valid @[Decoupled.scala 297:22]
    io_in_readData_q.io.enq.bits.last <= io.out.readData.bits.last @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.resp <= io.out.readData.bits.resp @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.data <= io.out.readData.bits.data @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.id <= io.out.readData.bits.id @[Decoupled.scala 298:21]
    io.out.readData.ready <= io_in_readData_q.io.enq.ready @[Decoupled.scala 299:17]
    io.in.readData.bits.last <= io_in_readData_q.io.deq.bits.last @[Queue.scala 17:18]
    io.in.readData.bits.resp <= io_in_readData_q.io.deq.bits.resp @[Queue.scala 17:18]
    io.in.readData.bits.data <= io_in_readData_q.io.deq.bits.data @[Queue.scala 17:18]
    io.in.readData.bits.id <= io_in_readData_q.io.deq.bits.id @[Queue.scala 17:18]
    io.in.readData.valid <= io_in_readData_q.io.deq.valid @[Queue.scala 17:18]
    io_in_readData_q.io.deq.ready <= io.in.readData.ready @[Queue.scala 17:18]
    inst io_in_writeResponse_q of Queue_42 @[Decoupled.scala 296:21]
    io_in_writeResponse_q.clock <= clock
    io_in_writeResponse_q.reset <= reset
    io_in_writeResponse_q.io.enq.valid <= io.out.writeResponse.valid @[Decoupled.scala 297:22]
    io_in_writeResponse_q.io.enq.bits.resp <= io.out.writeResponse.bits.resp @[Decoupled.scala 298:21]
    io_in_writeResponse_q.io.enq.bits.id <= io.out.writeResponse.bits.id @[Decoupled.scala 298:21]
    io.out.writeResponse.ready <= io_in_writeResponse_q.io.enq.ready @[Decoupled.scala 299:17]
    io.in.writeResponse.bits.resp <= io_in_writeResponse_q.io.deq.bits.resp @[Queue.scala 18:23]
    io.in.writeResponse.bits.id <= io_in_writeResponse_q.io.deq.bits.id @[Queue.scala 18:23]
    io.in.writeResponse.valid <= io_in_writeResponse_q.io.deq.valid @[Queue.scala 18:23]
    io_in_writeResponse_q.io.deq.ready <= io.in.writeResponse.ready @[Queue.scala 18:23]
    
  module Queue_44 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, count : UInt<2>}
    
    cmem ram : {write : UInt<1>, address : UInt<20>, size : UInt<20>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.address <= io.enq.bits.address @[Decoupled.scala 230:24]
      MPORT.write <= io.enq.bits.write @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.address <= io_deq_bits_MPORT.address @[Decoupled.scala 242:15]
    io.deq.bits.write <= io_deq_bits_MPORT.write @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module RequestSplitter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}}
    
    wire _sizeCounter_WIRE : UInt<20> @[package.scala 77:41]
    _sizeCounter_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    reg sizeCounter : UInt, clock with : (reset => (reset, _sizeCounter_WIRE)) @[RequestSplitter.scala 21:33]
    reg sizeCounterValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[RequestSplitter.scala 22:33]
    wire _addressOffset_WIRE : UInt<20> @[package.scala 77:41]
    _addressOffset_WIRE <= UInt<1>("h00") @[package.scala 77:41]
    reg addressOffset : UInt, clock with : (reset => (reset, _addressOffset_WIRE)) @[RequestSplitter.scala 23:33]
    node _address_T = add(io.in.bits.address, addressOffset) @[RequestSplitter.scala 24:42]
    node address = tail(_address_T, 1) @[RequestSplitter.scala 24:42]
    node _T = lt(io.in.bits.size, UInt<8>("h080")) @[RequestSplitter.scala 26:21]
    when _T : @[RequestSplitter.scala 26:34]
      io.out.bits.size <= io.in.bits.size @[RequestSplitter.scala 27:12]
      io.out.bits.address <= io.in.bits.address @[RequestSplitter.scala 27:12]
      io.out.bits.write <= io.in.bits.write @[RequestSplitter.scala 27:12]
      io.out.valid <= io.in.valid @[RequestSplitter.scala 27:12]
      io.in.ready <= io.out.ready @[RequestSplitter.scala 27:12]
      skip @[RequestSplitter.scala 26:34]
    else : @[RequestSplitter.scala 28:15]
      node _T_1 = lt(sizeCounter, UInt<8>("h080")) @[RequestSplitter.scala 29:42]
      node _T_2 = and(sizeCounterValid, _T_1) @[RequestSplitter.scala 29:27]
      when _T_2 : @[RequestSplitter.scala 29:55]
        wire io_out_bits_w : {write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 76:19]
        io_out_bits_w.address <= address @[MemControl.scala 77:17]
        io_out_bits_w.write <= io.in.bits.write @[MemControl.scala 78:15]
        io_out_bits_w.size <= sizeCounter @[MemControl.scala 79:14]
        io.out.bits.size <= io_out_bits_w.size @[RequestSplitter.scala 30:19]
        io.out.bits.address <= io_out_bits_w.address @[RequestSplitter.scala 30:19]
        io.out.bits.write <= io_out_bits_w.write @[RequestSplitter.scala 30:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 36:20]
        io.in.ready <= io.out.ready @[RequestSplitter.scala 37:16]
        node _T_3 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 38:21]
        when _T_3 : @[RequestSplitter.scala 38:38]
          sizeCounterValid <= UInt<1>("h00") @[RequestSplitter.scala 39:26]
          addressOffset <= UInt<1>("h00") @[RequestSplitter.scala 40:23]
          skip @[RequestSplitter.scala 38:38]
        skip @[RequestSplitter.scala 29:55]
      else : @[RequestSplitter.scala 42:17]
        wire io_out_bits_w_1 : {write : UInt<1>, address : UInt<20>, size : UInt<20>} @[MemControl.scala 76:19]
        io_out_bits_w_1.address <= address @[MemControl.scala 77:17]
        io_out_bits_w_1.write <= io.in.bits.write @[MemControl.scala 78:15]
        io_out_bits_w_1.size <= UInt<7>("h07f") @[MemControl.scala 79:14]
        io.out.bits.size <= io_out_bits_w_1.size @[RequestSplitter.scala 43:19]
        io.out.bits.address <= io_out_bits_w_1.address @[RequestSplitter.scala 43:19]
        io.out.bits.write <= io_out_bits_w_1.write @[RequestSplitter.scala 43:19]
        io.out.valid <= io.in.valid @[RequestSplitter.scala 49:20]
        io.in.ready <= UInt<1>("h00") @[RequestSplitter.scala 50:16]
        node _T_4 = and(io.in.valid, io.out.ready) @[RequestSplitter.scala 51:21]
        when _T_4 : @[RequestSplitter.scala 51:38]
          when sizeCounterValid : @[RequestSplitter.scala 52:32]
            node _sizeCounter_T = sub(sizeCounter, UInt<8>("h080")) @[RequestSplitter.scala 53:38]
            node _sizeCounter_T_1 = tail(_sizeCounter_T, 1) @[RequestSplitter.scala 53:38]
            sizeCounter <= _sizeCounter_T_1 @[RequestSplitter.scala 53:23]
            node _addressOffset_T = add(addressOffset, UInt<8>("h080")) @[RequestSplitter.scala 54:42]
            node _addressOffset_T_1 = tail(_addressOffset_T, 1) @[RequestSplitter.scala 54:42]
            addressOffset <= _addressOffset_T_1 @[RequestSplitter.scala 54:25]
            skip @[RequestSplitter.scala 52:32]
          else : @[RequestSplitter.scala 55:21]
            node _sizeCounter_T_2 = sub(io.in.bits.size, UInt<8>("h080")) @[RequestSplitter.scala 56:39]
            node _sizeCounter_T_3 = tail(_sizeCounter_T_2, 1) @[RequestSplitter.scala 56:39]
            sizeCounter <= _sizeCounter_T_3 @[RequestSplitter.scala 56:23]
            addressOffset <= UInt<8>("h080") @[RequestSplitter.scala 57:25]
            sizeCounterValid <= UInt<1>("h01") @[RequestSplitter.scala 58:28]
            skip @[RequestSplitter.scala 55:21]
          skip @[RequestSplitter.scala 51:38]
        skip @[RequestSplitter.scala 42:17]
      skip @[RequestSplitter.scala 28:15]
    
  module Queue_45 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, count : UInt<2>}
    
    cmem ram : Fixed<16><<8>>[8][2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT[0] <= io.enq.bits[0] @[Decoupled.scala 230:24]
      MPORT[1] <= io.enq.bits[1] @[Decoupled.scala 230:24]
      MPORT[2] <= io.enq.bits[2] @[Decoupled.scala 230:24]
      MPORT[3] <= io.enq.bits[3] @[Decoupled.scala 230:24]
      MPORT[4] <= io.enq.bits[4] @[Decoupled.scala 230:24]
      MPORT[5] <= io.enq.bits[5] @[Decoupled.scala 230:24]
      MPORT[6] <= io.enq.bits[6] @[Decoupled.scala 230:24]
      MPORT[7] <= io.enq.bits[7] @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits[0] <= io_deq_bits_MPORT[0] @[Decoupled.scala 242:15]
    io.deq.bits[1] <= io_deq_bits_MPORT[1] @[Decoupled.scala 242:15]
    io.deq.bits[2] <= io_deq_bits_MPORT[2] @[Decoupled.scala 242:15]
    io.deq.bits[3] <= io_deq_bits_MPORT[3] @[Decoupled.scala 242:15]
    io.deq.bits[4] <= io_deq_bits_MPORT[4] @[Decoupled.scala 242:15]
    io.deq.bits[5] <= io_deq_bits_MPORT[5] @[Decoupled.scala 242:15]
    io.deq.bits[6] <= io_deq_bits_MPORT[6] @[Decoupled.scala 242:15]
    io.deq.bits[7] <= io_deq_bits_MPORT[7] @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_46 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_47 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, resp : UInt<2>}[2] @[Decoupled.scala 218:16]
    reg enq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg deq_ptr_value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[enq_ptr_value], clock @[Decoupled.scala 230:8]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(enq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      enq_ptr_value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(deq_ptr_value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      deq_ptr_value <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[deq_ptr_value], clock @[Decoupled.scala 242:21]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(enq_ptr_value, deq_ptr_value) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module VectorSerializer_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}}
    
    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 79:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 79:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 79:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 79:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 79:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 79:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 79:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 79:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 79:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 79:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 79:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 79:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 79:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 79:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 79:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 79:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorSerializer.scala 37:30]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorSerializer.scala 37:30]
    reg bits : Fixed<16><<8>>[8], clock with : (reset => (reset, _bits_WIRE_8)) @[VectorSerializer.scala 37:22]
    reg valid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[VectorSerializer.scala 38:22]
    node _T = and(valid, io.out.ready) @[VectorSerializer.scala 40:48]
    reg ctr : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h00")
    when _T : @[Counter.scala 118:17]
      node wrap_wrap = eq(ctr, UInt<1>("h01")) @[Counter.scala 72:24]
      node _wrap_value_T = add(ctr, UInt<1>("h01")) @[Counter.scala 76:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 76:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 76:15]
      wrap <= wrap_wrap @[Counter.scala 118:24]
      skip @[Counter.scala 118:17]
    node _out_T = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_1 = add(_out_T, UInt<1>("h00")) @[VectorSerializer.scala 46:40]
    node _out_T_2 = tail(_out_T_1, 1) @[VectorSerializer.scala 46:40]
    node _out_T_3 = bits(_out_T_2, 2, 0)
    node _out_T_4 = asUInt(bits[_out_T_3]) @[VectorSerializer.scala 46:47]
    wire out_0 : UInt<16> @[Extend.scala 40:17]
    out_0 <= _out_T_4 @[Extend.scala 41:7]
    node _out_T_5 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_6 = add(_out_T_5, UInt<1>("h01")) @[VectorSerializer.scala 46:40]
    node _out_T_7 = tail(_out_T_6, 1) @[VectorSerializer.scala 46:40]
    node _out_T_8 = bits(_out_T_7, 2, 0)
    node _out_T_9 = asUInt(bits[_out_T_8]) @[VectorSerializer.scala 46:47]
    wire out_1 : UInt<16> @[Extend.scala 40:17]
    out_1 <= _out_T_9 @[Extend.scala 41:7]
    node _out_T_10 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_11 = add(_out_T_10, UInt<2>("h02")) @[VectorSerializer.scala 46:40]
    node _out_T_12 = tail(_out_T_11, 1) @[VectorSerializer.scala 46:40]
    node _out_T_13 = bits(_out_T_12, 2, 0)
    node _out_T_14 = asUInt(bits[_out_T_13]) @[VectorSerializer.scala 46:47]
    wire out_2 : UInt<16> @[Extend.scala 40:17]
    out_2 <= _out_T_14 @[Extend.scala 41:7]
    node _out_T_15 = mul(ctr, UInt<3>("h04")) @[VectorSerializer.scala 46:18]
    node _out_T_16 = add(_out_T_15, UInt<2>("h03")) @[VectorSerializer.scala 46:40]
    node _out_T_17 = tail(_out_T_16, 1) @[VectorSerializer.scala 46:40]
    node _out_T_18 = bits(_out_T_17, 2, 0)
    node _out_T_19 = asUInt(bits[_out_T_18]) @[VectorSerializer.scala 46:47]
    wire out_3 : UInt<16> @[Extend.scala 40:17]
    out_3 <= _out_T_19 @[Extend.scala 41:7]
    io.out.valid <= valid @[VectorSerializer.scala 50:16]
    node io_out_bits_lo = cat(out_1, out_0) @[Cat.scala 30:58]
    node io_out_bits_hi = cat(out_3, out_2) @[Cat.scala 30:58]
    node _io_out_bits_T = cat(io_out_bits_hi, io_out_bits_lo) @[Cat.scala 30:58]
    wire _io_out_bits_WIRE : UInt<64> @[VectorSerializer.scala 51:43]
    _io_out_bits_WIRE <= _io_out_bits_T @[VectorSerializer.scala 51:43]
    io.out.bits <= _io_out_bits_WIRE @[VectorSerializer.scala 51:15]
    node _io_in_ready_T = eq(valid, UInt<1>("h00")) @[VectorSerializer.scala 52:18]
    node _io_in_ready_T_1 = or(_io_in_ready_T, wrap) @[VectorSerializer.scala 52:25]
    io.in.ready <= _io_in_ready_T_1 @[VectorSerializer.scala 52:15]
    when io.in.ready : @[VectorSerializer.scala 54:21]
      when io.in.valid : @[VectorSerializer.scala 55:23]
        wire _WIRE : Fixed<16><<8>>[8] @[VectorSerializer.scala 56:34]
        node lo_lo_lo = asUInt(io.in.bits[0]) @[VectorSerializer.scala 56:34]
        node lo_lo_hi = asUInt(io.in.bits[1]) @[VectorSerializer.scala 56:34]
        node lo_hi_lo = asUInt(io.in.bits[2]) @[VectorSerializer.scala 56:34]
        node lo_hi_hi = asUInt(io.in.bits[3]) @[VectorSerializer.scala 56:34]
        node hi_lo_lo = asUInt(io.in.bits[4]) @[VectorSerializer.scala 56:34]
        node hi_lo_hi = asUInt(io.in.bits[5]) @[VectorSerializer.scala 56:34]
        node hi_hi_lo = asUInt(io.in.bits[6]) @[VectorSerializer.scala 56:34]
        node hi_hi_hi = asUInt(io.in.bits[7]) @[VectorSerializer.scala 56:34]
        node lo_lo = cat(lo_lo_hi, lo_lo_lo) @[VectorSerializer.scala 56:34]
        node lo_hi = cat(lo_hi_hi, lo_hi_lo) @[VectorSerializer.scala 56:34]
        node lo = cat(lo_hi, lo_lo) @[VectorSerializer.scala 56:34]
        node hi_lo = cat(hi_lo_hi, hi_lo_lo) @[VectorSerializer.scala 56:34]
        node hi_hi = cat(hi_hi_hi, hi_hi_lo) @[VectorSerializer.scala 56:34]
        node hi = cat(hi_hi, hi_lo) @[VectorSerializer.scala 56:34]
        node _T_1 = cat(hi, lo) @[VectorSerializer.scala 56:34]
        wire _WIRE_1 : UInt<128>
        _WIRE_1 <= _T_1
        node _T_2 = bits(_WIRE_1, 15, 0) @[VectorSerializer.scala 56:34]
        node _T_3 = asFixedPoint(_T_2, 8) @[VectorSerializer.scala 56:34]
        _WIRE[0] <= _T_3 @[VectorSerializer.scala 56:34]
        node _T_4 = bits(_WIRE_1, 31, 16) @[VectorSerializer.scala 56:34]
        node _T_5 = asFixedPoint(_T_4, 8) @[VectorSerializer.scala 56:34]
        _WIRE[1] <= _T_5 @[VectorSerializer.scala 56:34]
        node _T_6 = bits(_WIRE_1, 47, 32) @[VectorSerializer.scala 56:34]
        node _T_7 = asFixedPoint(_T_6, 8) @[VectorSerializer.scala 56:34]
        _WIRE[2] <= _T_7 @[VectorSerializer.scala 56:34]
        node _T_8 = bits(_WIRE_1, 63, 48) @[VectorSerializer.scala 56:34]
        node _T_9 = asFixedPoint(_T_8, 8) @[VectorSerializer.scala 56:34]
        _WIRE[3] <= _T_9 @[VectorSerializer.scala 56:34]
        node _T_10 = bits(_WIRE_1, 79, 64) @[VectorSerializer.scala 56:34]
        node _T_11 = asFixedPoint(_T_10, 8) @[VectorSerializer.scala 56:34]
        _WIRE[4] <= _T_11 @[VectorSerializer.scala 56:34]
        node _T_12 = bits(_WIRE_1, 95, 80) @[VectorSerializer.scala 56:34]
        node _T_13 = asFixedPoint(_T_12, 8) @[VectorSerializer.scala 56:34]
        _WIRE[5] <= _T_13 @[VectorSerializer.scala 56:34]
        node _T_14 = bits(_WIRE_1, 111, 96) @[VectorSerializer.scala 56:34]
        node _T_15 = asFixedPoint(_T_14, 8) @[VectorSerializer.scala 56:34]
        _WIRE[6] <= _T_15 @[VectorSerializer.scala 56:34]
        node _T_16 = bits(_WIRE_1, 127, 112) @[VectorSerializer.scala 56:34]
        node _T_17 = asFixedPoint(_T_16, 8) @[VectorSerializer.scala 56:34]
        _WIRE[7] <= _T_17 @[VectorSerializer.scala 56:34]
        bits[0] <= _WIRE[0] @[VectorSerializer.scala 56:12]
        bits[1] <= _WIRE[1] @[VectorSerializer.scala 56:12]
        bits[2] <= _WIRE[2] @[VectorSerializer.scala 56:12]
        bits[3] <= _WIRE[3] @[VectorSerializer.scala 56:12]
        bits[4] <= _WIRE[4] @[VectorSerializer.scala 56:12]
        bits[5] <= _WIRE[5] @[VectorSerializer.scala 56:12]
        bits[6] <= _WIRE[6] @[VectorSerializer.scala 56:12]
        bits[7] <= _WIRE[7] @[VectorSerializer.scala 56:12]
        valid <= UInt<1>("h01") @[VectorSerializer.scala 57:13]
        skip @[VectorSerializer.scala 55:23]
      else : @[VectorSerializer.scala 58:17]
        valid <= UInt<1>("h00") @[VectorSerializer.scala 59:13]
        skip @[VectorSerializer.scala 58:17]
      skip @[VectorSerializer.scala 54:21]
    
  module Counter_15 : 
    input clock : Clock
    input reset : Reset
    output io : {value : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip resetValue : UInt<1>}
    
    reg value : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Counter.scala 16:22]
    io.value.bits <= value @[Counter.scala 18:17]
    node _io_value_valid_T = eq(io.resetValue, UInt<1>("h00")) @[Counter.scala 19:21]
    io.value.valid <= _io_value_valid_T @[Counter.scala 19:18]
    when io.value.ready : @[Counter.scala 20:24]
      node _T = eq(value, UInt<8>("h0ff")) @[Counter.scala 21:16]
      when _T : @[Counter.scala 21:31]
        value <= UInt<1>("h00") @[Counter.scala 22:13]
        skip @[Counter.scala 21:31]
      else : @[Counter.scala 23:17]
        node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 24:22]
        node _value_T_1 = tail(_value_T, 1) @[Counter.scala 24:22]
        value <= _value_T_1 @[Counter.scala 24:13]
        skip @[Counter.scala 23:17]
      skip @[Counter.scala 20:24]
    when io.resetValue : @[Counter.scala 27:23]
      value <= UInt<1>("h00") @[Counter.scala 28:11]
      skip @[Counter.scala 27:23]
    
  module DataCounter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, flip len : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, last : UInt<1>}
    
    inst counter of Counter_15 @[Counter.scala 34:19]
    counter.clock <= clock
    counter.reset <= reset
    counter.io.resetValue <= UInt<1>("h00") @[Counter.scala 35:21]
    counter.io.value.ready <= UInt<1>("h00") @[Counter.scala 36:22]
    io.out.bits <= io.in.bits @[DataCounter.scala 25:15]
    node _io_out_valid_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 26:28]
    io.out.valid <= _io_out_valid_T @[DataCounter.scala 26:16]
    node _io_in_ready_T = and(io.len.valid, io.out.ready) @[DataCounter.scala 27:25]
    io.in.ready <= _io_in_ready_T @[DataCounter.scala 27:12]
    node _T = eq(counter.io.value.bits, io.len.bits) @[DataCounter.scala 29:30]
    when _T : @[DataCounter.scala 29:44]
      node _io_last_T = and(io.in.valid, io.len.valid) @[DataCounter.scala 30:25]
      io.last <= _io_last_T @[DataCounter.scala 30:13]
      node _io_len_ready_T = and(io.in.valid, io.out.ready) @[DataCounter.scala 31:27]
      io.len.ready <= _io_len_ready_T @[DataCounter.scala 31:15]
      node _counter_io_resetValue_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.resetValue <= _counter_io_resetValue_T @[DataCounter.scala 32:27]
      skip @[DataCounter.scala 29:44]
    else : @[DataCounter.scala 33:15]
      io.len.ready <= UInt<1>("h00") @[DataCounter.scala 34:15]
      io.last <= UInt<1>("h00") @[DataCounter.scala 35:13]
      node _counter_io_value_ready_T = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
      counter.io.value.ready <= _counter_io_value_ready_T @[DataCounter.scala 36:28]
      skip @[DataCounter.scala 33:15]
    
  module VectorDeserializer_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<64>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}
    
    wire _bits_WIRE : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_1 = asFixedPoint(_bits_T, 8) @[package.scala 79:56]
    _bits_WIRE <= _bits_T_1 @[package.scala 79:56]
    wire _bits_WIRE_1 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_2 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_3 = asFixedPoint(_bits_T_2, 8) @[package.scala 79:56]
    _bits_WIRE_1 <= _bits_T_3 @[package.scala 79:56]
    wire _bits_WIRE_2 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_4 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_5 = asFixedPoint(_bits_T_4, 8) @[package.scala 79:56]
    _bits_WIRE_2 <= _bits_T_5 @[package.scala 79:56]
    wire _bits_WIRE_3 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_6 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_7 = asFixedPoint(_bits_T_6, 8) @[package.scala 79:56]
    _bits_WIRE_3 <= _bits_T_7 @[package.scala 79:56]
    wire _bits_WIRE_4 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_8 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_9 = asFixedPoint(_bits_T_8, 8) @[package.scala 79:56]
    _bits_WIRE_4 <= _bits_T_9 @[package.scala 79:56]
    wire _bits_WIRE_5 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_10 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_11 = asFixedPoint(_bits_T_10, 8) @[package.scala 79:56]
    _bits_WIRE_5 <= _bits_T_11 @[package.scala 79:56]
    wire _bits_WIRE_6 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_12 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_13 = asFixedPoint(_bits_T_12, 8) @[package.scala 79:56]
    _bits_WIRE_6 <= _bits_T_13 @[package.scala 79:56]
    wire _bits_WIRE_7 : Fixed<16><<8>> @[package.scala 79:56]
    node _bits_T_14 = asUInt(asFixedPoint(UInt<1>("h00"), 8)) @[package.scala 79:56]
    node _bits_T_15 = asFixedPoint(_bits_T_14, 8) @[package.scala 79:56]
    _bits_WIRE_7 <= _bits_T_15 @[package.scala 79:56]
    wire _bits_WIRE_8 : Fixed<16><<8>>[8] @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[0] <= _bits_WIRE @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[1] <= _bits_WIRE_1 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[2] <= _bits_WIRE_2 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[3] <= _bits_WIRE_3 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[4] <= _bits_WIRE_4 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[5] <= _bits_WIRE_5 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[6] <= _bits_WIRE_6 @[VectorDeserializer.scala 41:32]
    _bits_WIRE_8[7] <= _bits_WIRE_7 @[VectorDeserializer.scala 41:32]
    reg bits : Fixed<16><<8>>[8], clock with : (reset => (reset, _bits_WIRE_8)) @[VectorDeserializer.scala 41:24]
    reg valid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[VectorDeserializer.scala 42:24]
    node _T = and(io.in.ready, io.in.valid) @[Decoupled.scala 40:37]
    reg ctr : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    wire wrap : UInt<1>
    wrap <= UInt<1>("h00")
    when _T : @[Counter.scala 118:17]
      node wrap_wrap = eq(ctr, UInt<1>("h01")) @[Counter.scala 72:24]
      node _wrap_value_T = add(ctr, UInt<1>("h01")) @[Counter.scala 76:24]
      node _wrap_value_T_1 = tail(_wrap_value_T, 1) @[Counter.scala 76:24]
      ctr <= _wrap_value_T_1 @[Counter.scala 76:15]
      wrap <= wrap_wrap @[Counter.scala 118:24]
      skip @[Counter.scala 118:17]
    io.out.valid <= valid @[VectorDeserializer.scala 47:18]
    io.out.bits[0] <= bits[0] @[VectorDeserializer.scala 48:17]
    io.out.bits[1] <= bits[1] @[VectorDeserializer.scala 48:17]
    io.out.bits[2] <= bits[2] @[VectorDeserializer.scala 48:17]
    io.out.bits[3] <= bits[3] @[VectorDeserializer.scala 48:17]
    io.out.bits[4] <= bits[4] @[VectorDeserializer.scala 48:17]
    io.out.bits[5] <= bits[5] @[VectorDeserializer.scala 48:17]
    io.out.bits[6] <= bits[6] @[VectorDeserializer.scala 48:17]
    io.out.bits[7] <= bits[7] @[VectorDeserializer.scala 48:17]
    node _io_in_ready_T = eq(valid, UInt<1>("h00")) @[VectorDeserializer.scala 50:20]
    node _io_in_ready_T_1 = or(_io_in_ready_T, io.out.ready) @[VectorDeserializer.scala 50:27]
    io.in.ready <= _io_in_ready_T_1 @[VectorDeserializer.scala 50:17]
    node _T_1 = and(io.in.ready, io.in.valid) @[Decoupled.scala 40:37]
    when _T_1 : @[VectorDeserializer.scala 52:24]
      node _T_2 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_3 = add(_T_2, UInt<1>("h00")) @[VectorDeserializer.scala 54:40]
      node _T_4 = tail(_T_3, 1) @[VectorDeserializer.scala 54:40]
      node _T_5 = bits(_T_4, 2, 0)
      node _bits_T_16 = bits(io.in.bits, 15, 0) @[VectorDeserializer.scala 55:30]
      wire bits_w : UInt<16> @[Extend.scala 40:17]
      bits_w <= _bits_T_16 @[Extend.scala 41:7]
      wire _bits_WIRE_9 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_17 = asFixedPoint(bits_w, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_9 <= _bits_T_17 @[VectorDeserializer.scala 37:57]
      bits[_T_5] <= _bits_WIRE_9 @[VectorDeserializer.scala 54:47]
      node _T_6 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_7 = add(_T_6, UInt<1>("h01")) @[VectorDeserializer.scala 54:40]
      node _T_8 = tail(_T_7, 1) @[VectorDeserializer.scala 54:40]
      node _T_9 = bits(_T_8, 2, 0)
      node _bits_T_18 = bits(io.in.bits, 31, 16) @[VectorDeserializer.scala 55:30]
      wire bits_w_1 : UInt<16> @[Extend.scala 40:17]
      bits_w_1 <= _bits_T_18 @[Extend.scala 41:7]
      wire _bits_WIRE_10 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_19 = asFixedPoint(bits_w_1, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_10 <= _bits_T_19 @[VectorDeserializer.scala 37:57]
      bits[_T_9] <= _bits_WIRE_10 @[VectorDeserializer.scala 54:47]
      node _T_10 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_11 = add(_T_10, UInt<2>("h02")) @[VectorDeserializer.scala 54:40]
      node _T_12 = tail(_T_11, 1) @[VectorDeserializer.scala 54:40]
      node _T_13 = bits(_T_12, 2, 0)
      node _bits_T_20 = bits(io.in.bits, 47, 32) @[VectorDeserializer.scala 55:30]
      wire bits_w_2 : UInt<16> @[Extend.scala 40:17]
      bits_w_2 <= _bits_T_20 @[Extend.scala 41:7]
      wire _bits_WIRE_11 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_21 = asFixedPoint(bits_w_2, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_11 <= _bits_T_21 @[VectorDeserializer.scala 37:57]
      bits[_T_13] <= _bits_WIRE_11 @[VectorDeserializer.scala 54:47]
      node _T_14 = mul(ctr, UInt<3>("h04")) @[VectorDeserializer.scala 54:18]
      node _T_15 = add(_T_14, UInt<2>("h03")) @[VectorDeserializer.scala 54:40]
      node _T_16 = tail(_T_15, 1) @[VectorDeserializer.scala 54:40]
      node _T_17 = bits(_T_16, 2, 0)
      node _bits_T_22 = bits(io.in.bits, 63, 48) @[VectorDeserializer.scala 55:30]
      wire bits_w_3 : UInt<16> @[Extend.scala 40:17]
      bits_w_3 <= _bits_T_22 @[Extend.scala 41:7]
      wire _bits_WIRE_12 : Fixed<16><<8>> @[VectorDeserializer.scala 37:57]
      node _bits_T_23 = asFixedPoint(bits_w_3, 8) @[VectorDeserializer.scala 37:57]
      _bits_WIRE_12 <= _bits_T_23 @[VectorDeserializer.scala 37:57]
      bits[_T_17] <= _bits_WIRE_12 @[VectorDeserializer.scala 54:47]
      valid <= wrap @[VectorDeserializer.scala 61:13]
      skip @[VectorDeserializer.scala 52:24]
    node _T_18 = and(io.out.ready, io.out.valid) @[Decoupled.scala 40:37]
    when _T_18 : @[VectorDeserializer.scala 63:25]
      valid <= UInt<1>("h00") @[VectorDeserializer.scala 64:13]
      skip @[VectorDeserializer.scala 63:25]
    
  module MultiEnqueue_21 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>}, out : {flip ready : UInt<1>, valid : UInt<1>}[2]}
    
    reg enq_0 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    reg enq_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[MultiEnqueue.scala 16:47]
    node _allEnqueued_T = or(io.out[0].ready, enq_0) @[MultiEnqueue.scala 22:34]
    node _allEnqueued_T_1 = or(io.out[1].ready, enq_1) @[MultiEnqueue.scala 22:34]
    node allEnqueued = and(_allEnqueued_T, _allEnqueued_T_1) @[MultiEnqueue.scala 24:15]
    node _io_out_0_valid_T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_0_valid_T_1 = and(io.in.valid, _io_out_0_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[0].valid <= _io_out_0_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_0 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T = eq(enq_0, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T : @[MultiEnqueue.scala 31:21]
        node _enq_0_T = and(io.out[0].valid, io.out[0].ready) @[MultiEnqueue.scala 32:35]
        enq_0 <= _enq_0_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    node _io_out_1_valid_T = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 27:39]
    node _io_out_1_valid_T_1 = and(io.in.valid, _io_out_1_valid_T) @[MultiEnqueue.scala 27:36]
    io.out[1].valid <= _io_out_1_valid_T_1 @[MultiEnqueue.scala 27:21]
    when allEnqueued : @[MultiEnqueue.scala 28:23]
      enq_1 <= UInt<1>("h00") @[MultiEnqueue.scala 29:14]
      skip @[MultiEnqueue.scala 28:23]
    else : @[MultiEnqueue.scala 30:17]
      node _T_1 = eq(enq_1, UInt<1>("h00")) @[MultiEnqueue.scala 31:12]
      when _T_1 : @[MultiEnqueue.scala 31:21]
        node _enq_1_T = and(io.out[1].valid, io.out[1].ready) @[MultiEnqueue.scala 32:35]
        enq_1 <= _enq_1_T @[MultiEnqueue.scala 32:16]
        skip @[MultiEnqueue.scala 31:21]
      skip @[MultiEnqueue.scala 30:17]
    io.in.ready <= allEnqueued @[MultiEnqueue.scala 37:15]
    
  module Converter_1 : 
    input clock : Clock
    input reset : Reset
    output io : {mem : {flip control : {flip ready : UInt<1>, valid : UInt<1>, bits : {write : UInt<1>, address : UInt<20>, size : UInt<20>}}, dataIn : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}, flip dataOut : {flip ready : UInt<1>, valid : UInt<1>, bits : Fixed<16><<8>>[8]}}, axi : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, flip addressOffset : UInt<32>, flip cacheBehavior : UInt<4>, flip timeout : UInt<1>, flip tracepoint : UInt<1>, flip programCounter : UInt<32>}
    
    inst control_q of Queue_44 @[Converter.scala 66:25]
    control_q.clock <= clock
    control_q.reset <= reset
    control_q.io.enq.bits.size <= io.mem.control.bits.size @[Converter.scala 66:25]
    control_q.io.enq.bits.address <= io.mem.control.bits.address @[Converter.scala 66:25]
    control_q.io.enq.bits.write <= io.mem.control.bits.write @[Converter.scala 66:25]
    control_q.io.enq.valid <= io.mem.control.valid @[Converter.scala 66:25]
    io.mem.control.ready <= control_q.io.enq.ready @[Converter.scala 66:25]
    inst control_splitter of RequestSplitter_1 @[RequestSplitter.scala 69:26]
    control_splitter.clock <= clock
    control_splitter.reset <= reset
    control_splitter.io.in.bits.size <= control_q.io.deq.bits.size @[RequestSplitter.scala 70:20]
    control_splitter.io.in.bits.address <= control_q.io.deq.bits.address @[RequestSplitter.scala 70:20]
    control_splitter.io.in.bits.write <= control_q.io.deq.bits.write @[RequestSplitter.scala 70:20]
    control_splitter.io.in.valid <= control_q.io.deq.valid @[RequestSplitter.scala 70:20]
    control_q.io.deq.ready <= control_splitter.io.in.ready @[RequestSplitter.scala 70:20]
    inst dataOut of Queue_45 @[Converter.scala 68:41]
    dataOut.clock <= clock
    dataOut.reset <= reset
    dataOut.io.enq.bits[0] <= io.mem.dataOut.bits[0] @[Converter.scala 68:41]
    dataOut.io.enq.bits[1] <= io.mem.dataOut.bits[1] @[Converter.scala 68:41]
    dataOut.io.enq.bits[2] <= io.mem.dataOut.bits[2] @[Converter.scala 68:41]
    dataOut.io.enq.bits[3] <= io.mem.dataOut.bits[3] @[Converter.scala 68:41]
    dataOut.io.enq.bits[4] <= io.mem.dataOut.bits[4] @[Converter.scala 68:41]
    dataOut.io.enq.bits[5] <= io.mem.dataOut.bits[5] @[Converter.scala 68:41]
    dataOut.io.enq.bits[6] <= io.mem.dataOut.bits[6] @[Converter.scala 68:41]
    dataOut.io.enq.bits[7] <= io.mem.dataOut.bits[7] @[Converter.scala 68:41]
    dataOut.io.enq.valid <= io.mem.dataOut.valid @[Converter.scala 68:41]
    io.mem.dataOut.ready <= dataOut.io.enq.ready @[Converter.scala 68:41]
    inst readData of Queue_46 @[Converter.scala 69:41]
    readData.clock <= clock
    readData.reset <= reset
    readData.io.enq.bits.last <= io.axi.readData.bits.last @[Converter.scala 69:41]
    readData.io.enq.bits.resp <= io.axi.readData.bits.resp @[Converter.scala 69:41]
    readData.io.enq.bits.data <= io.axi.readData.bits.data @[Converter.scala 69:41]
    readData.io.enq.bits.id <= io.axi.readData.bits.id @[Converter.scala 69:41]
    readData.io.enq.valid <= io.axi.readData.valid @[Converter.scala 69:41]
    io.axi.readData.ready <= readData.io.enq.ready @[Converter.scala 69:41]
    inst writeResponse of Queue_47 @[Converter.scala 70:41]
    writeResponse.clock <= clock
    writeResponse.reset <= reset
    writeResponse.io.enq.bits.resp <= io.axi.writeResponse.bits.resp @[Converter.scala 70:41]
    writeResponse.io.enq.bits.id <= io.axi.writeResponse.bits.id @[Converter.scala 70:41]
    writeResponse.io.enq.valid <= io.axi.writeResponse.valid @[Converter.scala 70:41]
    io.axi.writeResponse.ready <= writeResponse.io.enq.ready @[Converter.scala 70:41]
    node address = mul(control_splitter.io.out.bits.address, UInt<5>("h010")) @[Converter.scala 79:26]
    node _size_T = add(control_splitter.io.out.bits.size, UInt<1>("h01")) @[Converter.scala 82:24]
    node _size_T_1 = tail(_size_T, 1) @[Converter.scala 82:24]
    node _size_T_2 = mul(_size_T_1, UInt<2>("h02")) @[Converter.scala 82:31]
    node _size_T_3 = sub(_size_T_2, UInt<1>("h01")) @[Converter.scala 82:68]
    node size = tail(_size_T_3, 1) @[Converter.scala 82:68]
    inst ser of VectorSerializer_1 @[Converter.scala 90:19]
    ser.clock <= clock
    ser.reset <= reset
    ser.io.in.bits[0] <= dataOut.io.deq.bits[0] @[Converter.scala 98:13]
    ser.io.in.bits[1] <= dataOut.io.deq.bits[1] @[Converter.scala 98:13]
    ser.io.in.bits[2] <= dataOut.io.deq.bits[2] @[Converter.scala 98:13]
    ser.io.in.bits[3] <= dataOut.io.deq.bits[3] @[Converter.scala 98:13]
    ser.io.in.bits[4] <= dataOut.io.deq.bits[4] @[Converter.scala 98:13]
    ser.io.in.bits[5] <= dataOut.io.deq.bits[5] @[Converter.scala 98:13]
    ser.io.in.bits[6] <= dataOut.io.deq.bits[6] @[Converter.scala 98:13]
    ser.io.in.bits[7] <= dataOut.io.deq.bits[7] @[Converter.scala 98:13]
    ser.io.in.valid <= dataOut.io.deq.valid @[Converter.scala 98:13]
    dataOut.io.deq.ready <= ser.io.in.ready @[Converter.scala 98:13]
    inst serCounter of DataCounter_1 @[Converter.scala 100:26]
    serCounter.clock <= clock
    serCounter.reset <= reset
    serCounter.io.in.bits <= ser.io.out.bits @[Converter.scala 103:20]
    serCounter.io.in.valid <= ser.io.out.valid @[Converter.scala 103:20]
    ser.io.out.ready <= serCounter.io.in.ready @[Converter.scala 103:20]
    serCounter.io.len.bits <= size @[Converter.scala 104:26]
    serCounter.io.len.valid <= UInt<1>("h00") @[Converter.scala 105:27]
    inst des of VectorDeserializer_1 @[Converter.scala 109:19]
    des.clock <= clock
    des.reset <= reset
    io.mem.dataIn.bits[0] <= des.io.out.bits[0] @[Converter.scala 117:17]
    io.mem.dataIn.bits[1] <= des.io.out.bits[1] @[Converter.scala 117:17]
    io.mem.dataIn.bits[2] <= des.io.out.bits[2] @[Converter.scala 117:17]
    io.mem.dataIn.bits[3] <= des.io.out.bits[3] @[Converter.scala 117:17]
    io.mem.dataIn.bits[4] <= des.io.out.bits[4] @[Converter.scala 117:17]
    io.mem.dataIn.bits[5] <= des.io.out.bits[5] @[Converter.scala 117:17]
    io.mem.dataIn.bits[6] <= des.io.out.bits[6] @[Converter.scala 117:17]
    io.mem.dataIn.bits[7] <= des.io.out.bits[7] @[Converter.scala 117:17]
    io.mem.dataIn.valid <= des.io.out.valid @[Converter.scala 117:17]
    des.io.out.ready <= io.mem.dataIn.ready @[Converter.scala 117:17]
    reg writeResponseCount : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Converter.scala 124:35]
    reg readResponseCount : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[Converter.scala 125:35]
    node _canWrite_T = eq(readResponseCount, UInt<1>("h00")) @[Converter.scala 127:24]
    node _canWrite_T_1 = lt(writeResponseCount, UInt<8>("h0ff")) @[Converter.scala 127:56]
    node canWrite = and(_canWrite_T, _canWrite_T_1) @[Converter.scala 127:33]
    node _canRead_T = eq(writeResponseCount, UInt<1>("h00")) @[Converter.scala 129:25]
    node _canRead_T_1 = lt(readResponseCount, UInt<8>("h0ff")) @[Converter.scala 129:56]
    node canRead = and(_canRead_T, _canRead_T_1) @[Converter.scala 129:34]
    node writeRequested = and(io.axi.writeAddress.ready, io.axi.writeAddress.valid) @[Converter.scala 130:50]
    node writeResponded = and(writeResponse.io.deq.ready, writeResponse.io.deq.valid) @[Converter.scala 131:44]
    node readRequested = and(io.axi.readAddress.ready, io.axi.readAddress.valid) @[Converter.scala 132:49]
    node _readResponded_T = and(readData.io.deq.ready, readData.io.deq.valid) @[Converter.scala 133:39]
    node readResponded = and(_readResponded_T, readData.io.deq.bits.last) @[Converter.scala 133:57]
    when writeRequested : @[Converter.scala 134:24]
      when writeResponded : @[Converter.scala 135:26]
        skip @[Converter.scala 135:26]
      else : @[Converter.scala 137:17]
        node _T = lt(writeResponseCount, UInt<8>("h0ff")) @[Converter.scala 138:31]
        when _T : @[Converter.scala 138:62]
          node _writeResponseCount_T = add(writeResponseCount, UInt<1>("h01")) @[Converter.scala 139:50]
          node _writeResponseCount_T_1 = tail(_writeResponseCount_T, 1) @[Converter.scala 139:50]
          writeResponseCount <= _writeResponseCount_T_1 @[Converter.scala 139:28]
          skip @[Converter.scala 138:62]
        skip @[Converter.scala 137:17]
      skip @[Converter.scala 134:24]
    else : @[Converter.scala 142:15]
      node _T_1 = gt(writeResponseCount, UInt<1>("h00")) @[Converter.scala 143:47]
      node _T_2 = and(writeResponded, _T_1) @[Converter.scala 143:25]
      when _T_2 : @[Converter.scala 143:54]
        node _writeResponseCount_T_2 = sub(writeResponseCount, UInt<1>("h01")) @[Converter.scala 144:48]
        node _writeResponseCount_T_3 = tail(_writeResponseCount_T_2, 1) @[Converter.scala 144:48]
        writeResponseCount <= _writeResponseCount_T_3 @[Converter.scala 144:26]
        skip @[Converter.scala 143:54]
      else : @[Converter.scala 145:17]
        skip @[Converter.scala 145:17]
      skip @[Converter.scala 142:15]
    when readRequested : @[Converter.scala 149:23]
      when readResponded : @[Converter.scala 150:25]
        skip @[Converter.scala 150:25]
      else : @[Converter.scala 152:17]
        node _T_3 = lt(readResponseCount, UInt<8>("h0ff")) @[Converter.scala 153:30]
        when _T_3 : @[Converter.scala 153:61]
          node _readResponseCount_T = add(readResponseCount, UInt<1>("h01")) @[Converter.scala 154:48]
          node _readResponseCount_T_1 = tail(_readResponseCount_T, 1) @[Converter.scala 154:48]
          readResponseCount <= _readResponseCount_T_1 @[Converter.scala 154:27]
          skip @[Converter.scala 153:61]
        skip @[Converter.scala 152:17]
      skip @[Converter.scala 149:23]
    else : @[Converter.scala 157:15]
      node _T_4 = gt(readResponseCount, UInt<1>("h00")) @[Converter.scala 158:45]
      node _T_5 = and(readResponded, _T_4) @[Converter.scala 158:24]
      when _T_5 : @[Converter.scala 158:52]
        node _readResponseCount_T_2 = sub(readResponseCount, UInt<1>("h01")) @[Converter.scala 159:46]
        node _readResponseCount_T_3 = tail(_readResponseCount_T_2, 1) @[Converter.scala 159:46]
        readResponseCount <= _readResponseCount_T_3 @[Converter.scala 159:25]
        skip @[Converter.scala 158:52]
      else : @[Converter.scala 160:17]
        skip @[Converter.scala 160:17]
      skip @[Converter.scala 157:15]
    io.axi.writeAddress.bits.id <= UInt<1>("h00") @[Address.scala 43:8]
    io.axi.writeAddress.bits.size <= UInt<2>("h03") @[Address.scala 47:10]
    io.axi.writeAddress.bits.burst <= UInt<1>("h01") @[Address.scala 51:11]
    io.axi.writeAddress.bits.lock <= UInt<1>("h00") @[Address.scala 55:10]
    io.axi.writeAddress.bits.cache <= UInt<1>("h00") @[Address.scala 56:11]
    io.axi.writeAddress.bits.prot <= UInt<1>("h00") @[Address.scala 57:10]
    io.axi.writeAddress.bits.qos <= UInt<1>("h00") @[Address.scala 58:9]
    node _T_6 = add(address, io.addressOffset) @[Converter.scala 169:15]
    node _T_7 = tail(_T_6, 1) @[Converter.scala 169:15]
    io.axi.writeAddress.bits.addr <= _T_7 @[Address.scala 27:10]
    io.axi.writeAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.writeAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.writeAddress.valid <= UInt<1>("h00") @[Converter.scala 173:29]
    io.axi.writeData.bits.id <= UInt<1>("h00") @[WriteData.scala 31:8]
    io.axi.writeData.bits.strb <= UInt<8>("h0ff") @[WriteData.scala 39:14]
    io.axi.writeData.bits.data <= serCounter.io.out.bits @[WriteData.scala 20:15]
    io.axi.writeData.bits.last <= serCounter.io.last @[WriteData.scala 21:15]
    io.axi.writeData.valid <= UInt<1>("h00") @[Converter.scala 179:26]
    io.axi.writeData.valid <= serCounter.io.out.valid @[Converter.scala 180:26]
    serCounter.io.out.ready <= io.axi.writeData.ready @[Converter.scala 181:16]
    writeResponse.io.deq.ready <= UInt<1>("h01") @[Converter.scala 185:23]
    io.axi.readAddress.bits.id <= UInt<1>("h00") @[Address.scala 43:8]
    io.axi.readAddress.bits.size <= UInt<2>("h03") @[Address.scala 47:10]
    io.axi.readAddress.bits.burst <= UInt<1>("h01") @[Address.scala 51:11]
    io.axi.readAddress.bits.lock <= UInt<1>("h00") @[Address.scala 55:10]
    io.axi.readAddress.bits.cache <= UInt<1>("h00") @[Address.scala 56:11]
    io.axi.readAddress.bits.prot <= UInt<1>("h00") @[Address.scala 57:10]
    io.axi.readAddress.bits.qos <= UInt<1>("h00") @[Address.scala 58:9]
    node _T_8 = add(address, io.addressOffset) @[Converter.scala 191:15]
    node _T_9 = tail(_T_8, 1) @[Converter.scala 191:15]
    io.axi.readAddress.bits.addr <= _T_9 @[Address.scala 27:10]
    io.axi.readAddress.bits.len <= size @[Address.scala 28:9]
    io.axi.readAddress.bits.cache <= io.cacheBehavior @[Address.scala 30:34]
    io.axi.readAddress.valid <= UInt<1>("h00") @[Converter.scala 195:28]
    des.io.in.bits <= readData.io.deq.bits.data @[Converter.scala 200:18]
    des.io.in.valid <= readData.io.deq.valid @[Converter.scala 201:19]
    readData.io.deq.ready <= des.io.in.ready @[Converter.scala 202:18]
    inst writeEnqueue of MultiEnqueue_21 @[MultiEnqueue.scala 160:43]
    writeEnqueue.clock <= clock
    writeEnqueue.reset <= reset
    writeEnqueue.io.in.valid <= UInt<1>("h00") @[MultiEnqueue.scala 40:17]
    writeEnqueue.io.out[0].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    writeEnqueue.io.out[1].ready <= UInt<1>("h00") @[MultiEnqueue.scala 42:18]
    when control_splitter.io.out.bits.write : @[Converter.scala 208:28]
      node _writeEnqueue_io_in_valid_T = and(control_splitter.io.out.valid, canWrite) @[Converter.scala 209:47]
      writeEnqueue.io.in.valid <= _writeEnqueue_io_in_valid_T @[Converter.scala 209:30]
      control_splitter.io.out.ready <= writeEnqueue.io.in.ready @[Converter.scala 210:19]
      writeEnqueue.io.out[0].ready <= io.axi.writeAddress.ready @[Converter.scala 212:34]
      io.axi.writeAddress.valid <= writeEnqueue.io.out[0].valid @[Converter.scala 213:31]
      writeEnqueue.io.out[1].ready <= serCounter.io.len.ready @[Converter.scala 214:34]
      serCounter.io.len.valid <= writeEnqueue.io.out[1].valid @[Converter.scala 215:29]
      skip @[Converter.scala 208:28]
    else : @[Converter.scala 216:15]
      node _io_axi_readAddress_valid_T = and(control_splitter.io.out.valid, canRead) @[Converter.scala 217:47]
      io.axi.readAddress.valid <= _io_axi_readAddress_valid_T @[Converter.scala 217:30]
      node _splitter_io_out_ready_T = and(io.axi.readAddress.ready, canRead) @[Converter.scala 218:47]
      control_splitter.io.out.ready <= _splitter_io_out_ready_T @[Converter.scala 218:19]
      skip @[Converter.scala 216:15]
    
  module Queue_48 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.qos <= io.enq.bits.qos @[Decoupled.scala 230:24]
      MPORT.prot <= io.enq.bits.prot @[Decoupled.scala 230:24]
      MPORT.cache <= io.enq.bits.cache @[Decoupled.scala 230:24]
      MPORT.lock <= io.enq.bits.lock @[Decoupled.scala 230:24]
      MPORT.burst <= io.enq.bits.burst @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.len <= io.enq.bits.len @[Decoupled.scala 230:24]
      MPORT.addr <= io.enq.bits.addr @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.qos <= io_deq_bits_MPORT.qos @[Decoupled.scala 242:15]
    io.deq.bits.prot <= io_deq_bits_MPORT.prot @[Decoupled.scala 242:15]
    io.deq.bits.cache <= io_deq_bits_MPORT.cache @[Decoupled.scala 242:15]
    io.deq.bits.lock <= io_deq_bits_MPORT.lock @[Decoupled.scala 242:15]
    io.deq.bits.burst <= io_deq_bits_MPORT.burst @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.len <= io_deq_bits_MPORT.len @[Decoupled.scala 242:15]
    io.deq.bits.addr <= io_deq_bits_MPORT.addr @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_49 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.qos <= io.enq.bits.qos @[Decoupled.scala 230:24]
      MPORT.prot <= io.enq.bits.prot @[Decoupled.scala 230:24]
      MPORT.cache <= io.enq.bits.cache @[Decoupled.scala 230:24]
      MPORT.lock <= io.enq.bits.lock @[Decoupled.scala 230:24]
      MPORT.burst <= io.enq.bits.burst @[Decoupled.scala 230:24]
      MPORT.size <= io.enq.bits.size @[Decoupled.scala 230:24]
      MPORT.len <= io.enq.bits.len @[Decoupled.scala 230:24]
      MPORT.addr <= io.enq.bits.addr @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.qos <= io_deq_bits_MPORT.qos @[Decoupled.scala 242:15]
    io.deq.bits.prot <= io_deq_bits_MPORT.prot @[Decoupled.scala 242:15]
    io.deq.bits.cache <= io_deq_bits_MPORT.cache @[Decoupled.scala 242:15]
    io.deq.bits.lock <= io_deq_bits_MPORT.lock @[Decoupled.scala 242:15]
    io.deq.bits.burst <= io_deq_bits_MPORT.burst @[Decoupled.scala 242:15]
    io.deq.bits.size <= io_deq_bits_MPORT.size @[Decoupled.scala 242:15]
    io.deq.bits.len <= io_deq_bits_MPORT.len @[Decoupled.scala 242:15]
    io.deq.bits.addr <= io_deq_bits_MPORT.addr @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_50 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.strb <= io.enq.bits.strb @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.strb <= io_deq_bits_MPORT.strb @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_51 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.last <= io.enq.bits.last @[Decoupled.scala 230:24]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.data <= io.enq.bits.data @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.last <= io_deq_bits_MPORT.last @[Decoupled.scala 242:15]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.data <= io_deq_bits_MPORT.data @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_52 : 
    input clock : Clock
    input reset : Reset
    output io : {flip enq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, deq : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, count : UInt<2>}
    
    cmem ram : {id : UInt<6>, resp : UInt<2>}[2] @[Decoupled.scala 218:16]
    reg value : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg value_1 : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Counter.scala 60:40]
    reg maybe_full : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[Decoupled.scala 221:27]
    node ptr_match = eq(value, value_1) @[Decoupled.scala 223:33]
    node _empty_T = eq(maybe_full, UInt<1>("h00")) @[Decoupled.scala 224:28]
    node empty = and(ptr_match, _empty_T) @[Decoupled.scala 224:25]
    node full = and(ptr_match, maybe_full) @[Decoupled.scala 225:24]
    node _do_enq_T = and(io.enq.ready, io.enq.valid) @[Decoupled.scala 40:37]
    wire do_enq : UInt<1>
    do_enq <= _do_enq_T
    node _do_deq_T = and(io.deq.ready, io.deq.valid) @[Decoupled.scala 40:37]
    wire do_deq : UInt<1>
    do_deq <= _do_deq_T
    when do_enq : @[Decoupled.scala 229:17]
      infer mport MPORT = ram[value], clock @[Decoupled.scala 230:8]
      MPORT.resp <= io.enq.bits.resp @[Decoupled.scala 230:24]
      MPORT.id <= io.enq.bits.id @[Decoupled.scala 230:24]
      node wrap = eq(value, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T = add(value, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_1 = tail(_value_T, 1) @[Counter.scala 76:24]
      value <= _value_T_1 @[Counter.scala 76:15]
      skip @[Decoupled.scala 229:17]
    when do_deq : @[Decoupled.scala 233:17]
      node wrap_1 = eq(value_1, UInt<1>("h01")) @[Counter.scala 72:24]
      node _value_T_2 = add(value_1, UInt<1>("h01")) @[Counter.scala 76:24]
      node _value_T_3 = tail(_value_T_2, 1) @[Counter.scala 76:24]
      value_1 <= _value_T_3 @[Counter.scala 76:15]
      skip @[Decoupled.scala 233:17]
    node _T = neq(do_enq, do_deq) @[Decoupled.scala 236:16]
    when _T : @[Decoupled.scala 236:28]
      maybe_full <= do_enq @[Decoupled.scala 237:16]
      skip @[Decoupled.scala 236:28]
    node _io_deq_valid_T = eq(empty, UInt<1>("h00")) @[Decoupled.scala 240:19]
    io.deq.valid <= _io_deq_valid_T @[Decoupled.scala 240:16]
    node _io_enq_ready_T = eq(full, UInt<1>("h00")) @[Decoupled.scala 241:19]
    io.enq.ready <= _io_enq_ready_T @[Decoupled.scala 241:16]
    infer mport io_deq_bits_MPORT = ram[value_1], clock @[Decoupled.scala 242:21]
    io.deq.bits.resp <= io_deq_bits_MPORT.resp @[Decoupled.scala 242:15]
    io.deq.bits.id <= io_deq_bits_MPORT.id @[Decoupled.scala 242:15]
    node _ptr_diff_T = sub(value, value_1) @[Decoupled.scala 257:32]
    node ptr_diff = tail(_ptr_diff_T, 1) @[Decoupled.scala 257:32]
    node _io_count_T = and(maybe_full, ptr_match) @[Decoupled.scala 259:32]
    node _io_count_T_1 = mux(_io_count_T, UInt<2>("h02"), UInt<1>("h00")) @[Decoupled.scala 259:20]
    node _io_count_T_2 = or(_io_count_T_1, ptr_diff) @[Decoupled.scala 259:62]
    io.count <= _io_count_T_2 @[Decoupled.scala 259:14]
    
  module Queue_53 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}, out : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}}
    
    inst io_out_readAddress_q of Queue_48 @[Decoupled.scala 296:21]
    io_out_readAddress_q.clock <= clock
    io_out_readAddress_q.reset <= reset
    io_out_readAddress_q.io.enq.valid <= io.in.readAddress.valid @[Decoupled.scala 297:22]
    io_out_readAddress_q.io.enq.bits.qos <= io.in.readAddress.bits.qos @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.prot <= io.in.readAddress.bits.prot @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.cache <= io.in.readAddress.bits.cache @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.lock <= io.in.readAddress.bits.lock @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.burst <= io.in.readAddress.bits.burst @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.size <= io.in.readAddress.bits.size @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.len <= io.in.readAddress.bits.len @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.addr <= io.in.readAddress.bits.addr @[Decoupled.scala 298:21]
    io_out_readAddress_q.io.enq.bits.id <= io.in.readAddress.bits.id @[Decoupled.scala 298:21]
    io.in.readAddress.ready <= io_out_readAddress_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.readAddress.bits.qos <= io_out_readAddress_q.io.deq.bits.qos @[Queue.scala 14:22]
    io.out.readAddress.bits.prot <= io_out_readAddress_q.io.deq.bits.prot @[Queue.scala 14:22]
    io.out.readAddress.bits.cache <= io_out_readAddress_q.io.deq.bits.cache @[Queue.scala 14:22]
    io.out.readAddress.bits.lock <= io_out_readAddress_q.io.deq.bits.lock @[Queue.scala 14:22]
    io.out.readAddress.bits.burst <= io_out_readAddress_q.io.deq.bits.burst @[Queue.scala 14:22]
    io.out.readAddress.bits.size <= io_out_readAddress_q.io.deq.bits.size @[Queue.scala 14:22]
    io.out.readAddress.bits.len <= io_out_readAddress_q.io.deq.bits.len @[Queue.scala 14:22]
    io.out.readAddress.bits.addr <= io_out_readAddress_q.io.deq.bits.addr @[Queue.scala 14:22]
    io.out.readAddress.bits.id <= io_out_readAddress_q.io.deq.bits.id @[Queue.scala 14:22]
    io.out.readAddress.valid <= io_out_readAddress_q.io.deq.valid @[Queue.scala 14:22]
    io_out_readAddress_q.io.deq.ready <= io.out.readAddress.ready @[Queue.scala 14:22]
    inst io_out_writeAddress_q of Queue_49 @[Decoupled.scala 296:21]
    io_out_writeAddress_q.clock <= clock
    io_out_writeAddress_q.reset <= reset
    io_out_writeAddress_q.io.enq.valid <= io.in.writeAddress.valid @[Decoupled.scala 297:22]
    io_out_writeAddress_q.io.enq.bits.qos <= io.in.writeAddress.bits.qos @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.prot <= io.in.writeAddress.bits.prot @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.cache <= io.in.writeAddress.bits.cache @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.lock <= io.in.writeAddress.bits.lock @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.burst <= io.in.writeAddress.bits.burst @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.size <= io.in.writeAddress.bits.size @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.len <= io.in.writeAddress.bits.len @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.addr <= io.in.writeAddress.bits.addr @[Decoupled.scala 298:21]
    io_out_writeAddress_q.io.enq.bits.id <= io.in.writeAddress.bits.id @[Decoupled.scala 298:21]
    io.in.writeAddress.ready <= io_out_writeAddress_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.writeAddress.bits.qos <= io_out_writeAddress_q.io.deq.bits.qos @[Queue.scala 15:23]
    io.out.writeAddress.bits.prot <= io_out_writeAddress_q.io.deq.bits.prot @[Queue.scala 15:23]
    io.out.writeAddress.bits.cache <= io_out_writeAddress_q.io.deq.bits.cache @[Queue.scala 15:23]
    io.out.writeAddress.bits.lock <= io_out_writeAddress_q.io.deq.bits.lock @[Queue.scala 15:23]
    io.out.writeAddress.bits.burst <= io_out_writeAddress_q.io.deq.bits.burst @[Queue.scala 15:23]
    io.out.writeAddress.bits.size <= io_out_writeAddress_q.io.deq.bits.size @[Queue.scala 15:23]
    io.out.writeAddress.bits.len <= io_out_writeAddress_q.io.deq.bits.len @[Queue.scala 15:23]
    io.out.writeAddress.bits.addr <= io_out_writeAddress_q.io.deq.bits.addr @[Queue.scala 15:23]
    io.out.writeAddress.bits.id <= io_out_writeAddress_q.io.deq.bits.id @[Queue.scala 15:23]
    io.out.writeAddress.valid <= io_out_writeAddress_q.io.deq.valid @[Queue.scala 15:23]
    io_out_writeAddress_q.io.deq.ready <= io.out.writeAddress.ready @[Queue.scala 15:23]
    inst io_out_writeData_q of Queue_50 @[Decoupled.scala 296:21]
    io_out_writeData_q.clock <= clock
    io_out_writeData_q.reset <= reset
    io_out_writeData_q.io.enq.valid <= io.in.writeData.valid @[Decoupled.scala 297:22]
    io_out_writeData_q.io.enq.bits.last <= io.in.writeData.bits.last @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.strb <= io.in.writeData.bits.strb @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.data <= io.in.writeData.bits.data @[Decoupled.scala 298:21]
    io_out_writeData_q.io.enq.bits.id <= io.in.writeData.bits.id @[Decoupled.scala 298:21]
    io.in.writeData.ready <= io_out_writeData_q.io.enq.ready @[Decoupled.scala 299:17]
    io.out.writeData.bits.last <= io_out_writeData_q.io.deq.bits.last @[Queue.scala 16:20]
    io.out.writeData.bits.strb <= io_out_writeData_q.io.deq.bits.strb @[Queue.scala 16:20]
    io.out.writeData.bits.data <= io_out_writeData_q.io.deq.bits.data @[Queue.scala 16:20]
    io.out.writeData.bits.id <= io_out_writeData_q.io.deq.bits.id @[Queue.scala 16:20]
    io.out.writeData.valid <= io_out_writeData_q.io.deq.valid @[Queue.scala 16:20]
    io_out_writeData_q.io.deq.ready <= io.out.writeData.ready @[Queue.scala 16:20]
    inst io_in_readData_q of Queue_51 @[Decoupled.scala 296:21]
    io_in_readData_q.clock <= clock
    io_in_readData_q.reset <= reset
    io_in_readData_q.io.enq.valid <= io.out.readData.valid @[Decoupled.scala 297:22]
    io_in_readData_q.io.enq.bits.last <= io.out.readData.bits.last @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.resp <= io.out.readData.bits.resp @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.data <= io.out.readData.bits.data @[Decoupled.scala 298:21]
    io_in_readData_q.io.enq.bits.id <= io.out.readData.bits.id @[Decoupled.scala 298:21]
    io.out.readData.ready <= io_in_readData_q.io.enq.ready @[Decoupled.scala 299:17]
    io.in.readData.bits.last <= io_in_readData_q.io.deq.bits.last @[Queue.scala 17:18]
    io.in.readData.bits.resp <= io_in_readData_q.io.deq.bits.resp @[Queue.scala 17:18]
    io.in.readData.bits.data <= io_in_readData_q.io.deq.bits.data @[Queue.scala 17:18]
    io.in.readData.bits.id <= io_in_readData_q.io.deq.bits.id @[Queue.scala 17:18]
    io.in.readData.valid <= io_in_readData_q.io.deq.valid @[Queue.scala 17:18]
    io_in_readData_q.io.deq.ready <= io.in.readData.ready @[Queue.scala 17:18]
    inst io_in_writeResponse_q of Queue_52 @[Decoupled.scala 296:21]
    io_in_writeResponse_q.clock <= clock
    io_in_writeResponse_q.reset <= reset
    io_in_writeResponse_q.io.enq.valid <= io.out.writeResponse.valid @[Decoupled.scala 297:22]
    io_in_writeResponse_q.io.enq.bits.resp <= io.out.writeResponse.bits.resp @[Decoupled.scala 298:21]
    io_in_writeResponse_q.io.enq.bits.id <= io.out.writeResponse.bits.id @[Decoupled.scala 298:21]
    io.out.writeResponse.ready <= io_in_writeResponse_q.io.enq.ready @[Decoupled.scala 299:17]
    io.in.writeResponse.bits.resp <= io_in_writeResponse_q.io.deq.bits.resp @[Queue.scala 18:23]
    io.in.writeResponse.bits.id <= io_in_writeResponse_q.io.deq.bits.id @[Queue.scala 18:23]
    io.in.writeResponse.valid <= io_in_writeResponse_q.io.deq.valid @[Queue.scala 18:23]
    io_in_writeResponse_q.io.deq.ready <= io.in.writeResponse.ready @[Queue.scala 18:23]
    
  module AXIWrapperTCU : 
    input clock : Clock
    input reset : UInt<1>
    input instruction : {flip ready : UInt<1>, valid : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}
    output status : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {opcode : UInt<4>, flags : UInt<4>, arguments : UInt<48>}}}
    output dram0 : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    output dram1 : {writeAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, writeData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, strb : UInt<8>, last : UInt<1>}}, flip writeResponse : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, resp : UInt<2>}}, readAddress : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, addr : UInt<32>, len : UInt<8>, size : UInt<3>, burst : UInt<2>, lock : UInt<2>, cache : UInt<4>, prot : UInt<3>, qos : UInt<4>}}, flip readData : {flip ready : UInt<1>, valid : UInt<1>, bits : {id : UInt<6>, data : UInt<64>, resp : UInt<2>, last : UInt<1>}}}
    output error : UInt<1>
    output sample : {flip ready : UInt<1>, valid : UInt<1>, bits : {last : UInt<1>, bits : {flags : {instruction : {ready : UInt<1>, valid : UInt<1>}, memPortA : {ready : UInt<1>, valid : UInt<1>}, memPortB : {ready : UInt<1>, valid : UInt<1>}, dram0 : {ready : UInt<1>, valid : UInt<1>}, dram1 : {ready : UInt<1>, valid : UInt<1>}, dataflow : {ready : UInt<1>, valid : UInt<1>}, acc : {ready : UInt<1>, valid : UInt<1>}, array : {ready : UInt<1>, valid : UInt<1>}}, programCounter : UInt<32>}}}
    
    inst tcu of TCU @[AXIWrapperTCU.scala 32:19]
    tcu.clock <= clock
    tcu.reset <= reset
    tcu.io.instruction.bits.arguments <= instruction.bits.arguments @[AXIWrapperTCU.scala 47:22]
    tcu.io.instruction.bits.flags <= instruction.bits.flags @[AXIWrapperTCU.scala 47:22]
    tcu.io.instruction.bits.opcode <= instruction.bits.opcode @[AXIWrapperTCU.scala 47:22]
    tcu.io.instruction.valid <= instruction.valid @[AXIWrapperTCU.scala 47:22]
    instruction.ready <= tcu.io.instruction.ready @[AXIWrapperTCU.scala 47:22]
    status.bits.bits.arguments <= tcu.io.status.bits.bits.arguments @[AXIWrapperTCU.scala 48:10]
    status.bits.bits.flags <= tcu.io.status.bits.bits.flags @[AXIWrapperTCU.scala 48:10]
    status.bits.bits.opcode <= tcu.io.status.bits.bits.opcode @[AXIWrapperTCU.scala 48:10]
    status.bits.last <= tcu.io.status.bits.last @[AXIWrapperTCU.scala 48:10]
    status.valid <= tcu.io.status.valid @[AXIWrapperTCU.scala 48:10]
    tcu.io.status.ready <= status.ready @[AXIWrapperTCU.scala 48:10]
    error <= tcu.io.error @[AXIWrapperTCU.scala 49:9]
    sample.bits.bits.programCounter <= tcu.io.sample.bits.bits.programCounter @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.array.valid <= tcu.io.sample.bits.bits.flags.array.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.array.ready <= tcu.io.sample.bits.bits.flags.array.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.acc.valid <= tcu.io.sample.bits.bits.flags.acc.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.acc.ready <= tcu.io.sample.bits.bits.flags.acc.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dataflow.valid <= tcu.io.sample.bits.bits.flags.dataflow.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dataflow.ready <= tcu.io.sample.bits.bits.flags.dataflow.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dram1.valid <= tcu.io.sample.bits.bits.flags.dram1.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dram1.ready <= tcu.io.sample.bits.bits.flags.dram1.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dram0.valid <= tcu.io.sample.bits.bits.flags.dram0.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.dram0.ready <= tcu.io.sample.bits.bits.flags.dram0.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.memPortB.valid <= tcu.io.sample.bits.bits.flags.memPortB.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.memPortB.ready <= tcu.io.sample.bits.bits.flags.memPortB.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.memPortA.valid <= tcu.io.sample.bits.bits.flags.memPortA.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.memPortA.ready <= tcu.io.sample.bits.bits.flags.memPortA.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.instruction.valid <= tcu.io.sample.bits.bits.flags.instruction.valid @[AXIWrapperTCU.scala 50:10]
    sample.bits.bits.flags.instruction.ready <= tcu.io.sample.bits.bits.flags.instruction.ready @[AXIWrapperTCU.scala 50:10]
    sample.bits.last <= tcu.io.sample.bits.last @[AXIWrapperTCU.scala 50:10]
    sample.valid <= tcu.io.sample.valid @[AXIWrapperTCU.scala 50:10]
    tcu.io.sample.ready <= sample.ready @[AXIWrapperTCU.scala 50:10]
    inst dram0BoundarySplitter of MemBoundarySplitter @[AXIWrapperTCU.scala 56:37]
    dram0BoundarySplitter.clock <= clock
    dram0BoundarySplitter.reset <= reset
    dram0BoundarySplitter.io.out.readData.bits.last <= dram0.readData.bits.last @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readData.bits.resp <= dram0.readData.bits.resp @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readData.bits.data <= dram0.readData.bits.data @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readData.bits.id <= dram0.readData.bits.id @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readData.valid <= dram0.readData.valid @[AXIWrapperTCU.scala 59:9]
    dram0.readData.ready <= dram0BoundarySplitter.io.out.readData.ready @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.qos <= dram0BoundarySplitter.io.out.readAddress.bits.qos @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.prot <= dram0BoundarySplitter.io.out.readAddress.bits.prot @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.cache <= dram0BoundarySplitter.io.out.readAddress.bits.cache @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.lock <= dram0BoundarySplitter.io.out.readAddress.bits.lock @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.burst <= dram0BoundarySplitter.io.out.readAddress.bits.burst @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.size <= dram0BoundarySplitter.io.out.readAddress.bits.size @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.len <= dram0BoundarySplitter.io.out.readAddress.bits.len @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.addr <= dram0BoundarySplitter.io.out.readAddress.bits.addr @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.bits.id <= dram0BoundarySplitter.io.out.readAddress.bits.id @[AXIWrapperTCU.scala 59:9]
    dram0.readAddress.valid <= dram0BoundarySplitter.io.out.readAddress.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.readAddress.ready <= dram0.readAddress.ready @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeResponse.bits.resp <= dram0.writeResponse.bits.resp @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeResponse.bits.id <= dram0.writeResponse.bits.id @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeResponse.valid <= dram0.writeResponse.valid @[AXIWrapperTCU.scala 59:9]
    dram0.writeResponse.ready <= dram0BoundarySplitter.io.out.writeResponse.ready @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.bits.last <= dram0BoundarySplitter.io.out.writeData.bits.last @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.bits.strb <= dram0BoundarySplitter.io.out.writeData.bits.strb @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.bits.data <= dram0BoundarySplitter.io.out.writeData.bits.data @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.bits.id <= dram0BoundarySplitter.io.out.writeData.bits.id @[AXIWrapperTCU.scala 59:9]
    dram0.writeData.valid <= dram0BoundarySplitter.io.out.writeData.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeData.ready <= dram0.writeData.ready @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.qos <= dram0BoundarySplitter.io.out.writeAddress.bits.qos @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.prot <= dram0BoundarySplitter.io.out.writeAddress.bits.prot @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.cache <= dram0BoundarySplitter.io.out.writeAddress.bits.cache @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.lock <= dram0BoundarySplitter.io.out.writeAddress.bits.lock @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.burst <= dram0BoundarySplitter.io.out.writeAddress.bits.burst @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.size <= dram0BoundarySplitter.io.out.writeAddress.bits.size @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.len <= dram0BoundarySplitter.io.out.writeAddress.bits.len @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.addr <= dram0BoundarySplitter.io.out.writeAddress.bits.addr @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.bits.id <= dram0BoundarySplitter.io.out.writeAddress.bits.id @[AXIWrapperTCU.scala 59:9]
    dram0.writeAddress.valid <= dram0BoundarySplitter.io.out.writeAddress.valid @[AXIWrapperTCU.scala 59:9]
    dram0BoundarySplitter.io.out.writeAddress.ready <= dram0.writeAddress.ready @[AXIWrapperTCU.scala 59:9]
    inst dram1BoundarySplitter of MemBoundarySplitter_1 @[AXIWrapperTCU.scala 60:37]
    dram1BoundarySplitter.clock <= clock
    dram1BoundarySplitter.reset <= reset
    dram1BoundarySplitter.io.out.readData.bits.last <= dram1.readData.bits.last @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readData.bits.resp <= dram1.readData.bits.resp @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readData.bits.data <= dram1.readData.bits.data @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readData.bits.id <= dram1.readData.bits.id @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readData.valid <= dram1.readData.valid @[AXIWrapperTCU.scala 63:9]
    dram1.readData.ready <= dram1BoundarySplitter.io.out.readData.ready @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.qos <= dram1BoundarySplitter.io.out.readAddress.bits.qos @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.prot <= dram1BoundarySplitter.io.out.readAddress.bits.prot @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.cache <= dram1BoundarySplitter.io.out.readAddress.bits.cache @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.lock <= dram1BoundarySplitter.io.out.readAddress.bits.lock @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.burst <= dram1BoundarySplitter.io.out.readAddress.bits.burst @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.size <= dram1BoundarySplitter.io.out.readAddress.bits.size @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.len <= dram1BoundarySplitter.io.out.readAddress.bits.len @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.addr <= dram1BoundarySplitter.io.out.readAddress.bits.addr @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.bits.id <= dram1BoundarySplitter.io.out.readAddress.bits.id @[AXIWrapperTCU.scala 63:9]
    dram1.readAddress.valid <= dram1BoundarySplitter.io.out.readAddress.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.readAddress.ready <= dram1.readAddress.ready @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeResponse.bits.resp <= dram1.writeResponse.bits.resp @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeResponse.bits.id <= dram1.writeResponse.bits.id @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeResponse.valid <= dram1.writeResponse.valid @[AXIWrapperTCU.scala 63:9]
    dram1.writeResponse.ready <= dram1BoundarySplitter.io.out.writeResponse.ready @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.bits.last <= dram1BoundarySplitter.io.out.writeData.bits.last @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.bits.strb <= dram1BoundarySplitter.io.out.writeData.bits.strb @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.bits.data <= dram1BoundarySplitter.io.out.writeData.bits.data @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.bits.id <= dram1BoundarySplitter.io.out.writeData.bits.id @[AXIWrapperTCU.scala 63:9]
    dram1.writeData.valid <= dram1BoundarySplitter.io.out.writeData.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeData.ready <= dram1.writeData.ready @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.qos <= dram1BoundarySplitter.io.out.writeAddress.bits.qos @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.prot <= dram1BoundarySplitter.io.out.writeAddress.bits.prot @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.cache <= dram1BoundarySplitter.io.out.writeAddress.bits.cache @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.lock <= dram1BoundarySplitter.io.out.writeAddress.bits.lock @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.burst <= dram1BoundarySplitter.io.out.writeAddress.bits.burst @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.size <= dram1BoundarySplitter.io.out.writeAddress.bits.size @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.len <= dram1BoundarySplitter.io.out.writeAddress.bits.len @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.addr <= dram1BoundarySplitter.io.out.writeAddress.bits.addr @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.bits.id <= dram1BoundarySplitter.io.out.writeAddress.bits.id @[AXIWrapperTCU.scala 63:9]
    dram1.writeAddress.valid <= dram1BoundarySplitter.io.out.writeAddress.valid @[AXIWrapperTCU.scala 63:9]
    dram1BoundarySplitter.io.out.writeAddress.ready <= dram1.writeAddress.ready @[AXIWrapperTCU.scala 63:9]
    inst dram0Converter of Converter @[AXIWrapperTCU.scala 65:30]
    dram0Converter.clock <= clock
    dram0Converter.reset <= reset
    inst dram0BoundarySplitter_io_in_q of Queue_43 @[Queue.scala 23:19]
    dram0BoundarySplitter_io_in_q.clock <= clock
    dram0BoundarySplitter_io_in_q.reset <= reset
    dram0Converter.io.axi.readData.bits.last <= dram0BoundarySplitter_io_in_q.io.in.readData.bits.last @[Queue.scala 24:13]
    dram0Converter.io.axi.readData.bits.resp <= dram0BoundarySplitter_io_in_q.io.in.readData.bits.resp @[Queue.scala 24:13]
    dram0Converter.io.axi.readData.bits.data <= dram0BoundarySplitter_io_in_q.io.in.readData.bits.data @[Queue.scala 24:13]
    dram0Converter.io.axi.readData.bits.id <= dram0BoundarySplitter_io_in_q.io.in.readData.bits.id @[Queue.scala 24:13]
    dram0Converter.io.axi.readData.valid <= dram0BoundarySplitter_io_in_q.io.in.readData.valid @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readData.ready <= dram0Converter.io.axi.readData.ready @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.qos <= dram0Converter.io.axi.readAddress.bits.qos @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.prot <= dram0Converter.io.axi.readAddress.bits.prot @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.cache <= dram0Converter.io.axi.readAddress.bits.cache @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.lock <= dram0Converter.io.axi.readAddress.bits.lock @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.burst <= dram0Converter.io.axi.readAddress.bits.burst @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.size <= dram0Converter.io.axi.readAddress.bits.size @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.len <= dram0Converter.io.axi.readAddress.bits.len @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.addr <= dram0Converter.io.axi.readAddress.bits.addr @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.bits.id <= dram0Converter.io.axi.readAddress.bits.id @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.readAddress.valid <= dram0Converter.io.axi.readAddress.valid @[Queue.scala 24:13]
    dram0Converter.io.axi.readAddress.ready <= dram0BoundarySplitter_io_in_q.io.in.readAddress.ready @[Queue.scala 24:13]
    dram0Converter.io.axi.writeResponse.bits.resp <= dram0BoundarySplitter_io_in_q.io.in.writeResponse.bits.resp @[Queue.scala 24:13]
    dram0Converter.io.axi.writeResponse.bits.id <= dram0BoundarySplitter_io_in_q.io.in.writeResponse.bits.id @[Queue.scala 24:13]
    dram0Converter.io.axi.writeResponse.valid <= dram0BoundarySplitter_io_in_q.io.in.writeResponse.valid @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeResponse.ready <= dram0Converter.io.axi.writeResponse.ready @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeData.bits.last <= dram0Converter.io.axi.writeData.bits.last @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeData.bits.strb <= dram0Converter.io.axi.writeData.bits.strb @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeData.bits.data <= dram0Converter.io.axi.writeData.bits.data @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeData.bits.id <= dram0Converter.io.axi.writeData.bits.id @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeData.valid <= dram0Converter.io.axi.writeData.valid @[Queue.scala 24:13]
    dram0Converter.io.axi.writeData.ready <= dram0BoundarySplitter_io_in_q.io.in.writeData.ready @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.qos <= dram0Converter.io.axi.writeAddress.bits.qos @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.prot <= dram0Converter.io.axi.writeAddress.bits.prot @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.cache <= dram0Converter.io.axi.writeAddress.bits.cache @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.lock <= dram0Converter.io.axi.writeAddress.bits.lock @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.burst <= dram0Converter.io.axi.writeAddress.bits.burst @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.size <= dram0Converter.io.axi.writeAddress.bits.size @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.len <= dram0Converter.io.axi.writeAddress.bits.len @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.addr <= dram0Converter.io.axi.writeAddress.bits.addr @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.bits.id <= dram0Converter.io.axi.writeAddress.bits.id @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.in.writeAddress.valid <= dram0Converter.io.axi.writeAddress.valid @[Queue.scala 24:13]
    dram0Converter.io.axi.writeAddress.ready <= dram0BoundarySplitter_io_in_q.io.in.writeAddress.ready @[Queue.scala 24:13]
    dram0BoundarySplitter_io_in_q.io.out.readData.bits.last <= dram0BoundarySplitter.io.in.readData.bits.last @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.readData.bits.resp <= dram0BoundarySplitter.io.in.readData.bits.resp @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.readData.bits.data <= dram0BoundarySplitter.io.in.readData.bits.data @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.readData.bits.id <= dram0BoundarySplitter.io.in.readData.bits.id @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.readData.valid <= dram0BoundarySplitter.io.in.readData.valid @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readData.ready <= dram0BoundarySplitter_io_in_q.io.out.readData.ready @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.qos <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.qos @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.prot <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.prot @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.cache <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.cache @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.lock <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.lock @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.burst <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.burst @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.size <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.size @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.len <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.len @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.addr <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.addr @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.bits.id <= dram0BoundarySplitter_io_in_q.io.out.readAddress.bits.id @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.readAddress.valid <= dram0BoundarySplitter_io_in_q.io.out.readAddress.valid @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.readAddress.ready <= dram0BoundarySplitter.io.in.readAddress.ready @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.writeResponse.bits.resp <= dram0BoundarySplitter.io.in.writeResponse.bits.resp @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.writeResponse.bits.id <= dram0BoundarySplitter.io.in.writeResponse.bits.id @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.writeResponse.valid <= dram0BoundarySplitter.io.in.writeResponse.valid @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeResponse.ready <= dram0BoundarySplitter_io_in_q.io.out.writeResponse.ready @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeData.bits.last <= dram0BoundarySplitter_io_in_q.io.out.writeData.bits.last @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeData.bits.strb <= dram0BoundarySplitter_io_in_q.io.out.writeData.bits.strb @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeData.bits.data <= dram0BoundarySplitter_io_in_q.io.out.writeData.bits.data @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeData.bits.id <= dram0BoundarySplitter_io_in_q.io.out.writeData.bits.id @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeData.valid <= dram0BoundarySplitter_io_in_q.io.out.writeData.valid @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.writeData.ready <= dram0BoundarySplitter.io.in.writeData.ready @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.qos <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.qos @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.prot <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.prot @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.cache <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.cache @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.lock <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.lock @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.burst <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.burst @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.size <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.size @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.len <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.len @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.addr <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.addr @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.bits.id <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.bits.id @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter.io.in.writeAddress.valid <= dram0BoundarySplitter_io_in_q.io.out.writeAddress.valid @[AXIWrapperTCU.scala 74:31]
    dram0BoundarySplitter_io_in_q.io.out.writeAddress.ready <= dram0BoundarySplitter.io.in.writeAddress.ready @[AXIWrapperTCU.scala 74:31]
    dram0Converter.io.mem.dataOut.bits[0] <= tcu.io.dram0.dataOut.bits[0] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[1] <= tcu.io.dram0.dataOut.bits[1] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[2] <= tcu.io.dram0.dataOut.bits[2] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[3] <= tcu.io.dram0.dataOut.bits[3] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[4] <= tcu.io.dram0.dataOut.bits[4] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[5] <= tcu.io.dram0.dataOut.bits[5] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[6] <= tcu.io.dram0.dataOut.bits[6] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.bits[7] <= tcu.io.dram0.dataOut.bits[7] @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataOut.valid <= tcu.io.dram0.dataOut.valid @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataOut.ready <= dram0Converter.io.mem.dataOut.ready @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[0] <= dram0Converter.io.mem.dataIn.bits[0] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[1] <= dram0Converter.io.mem.dataIn.bits[1] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[2] <= dram0Converter.io.mem.dataIn.bits[2] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[3] <= dram0Converter.io.mem.dataIn.bits[3] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[4] <= dram0Converter.io.mem.dataIn.bits[4] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[5] <= dram0Converter.io.mem.dataIn.bits[5] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[6] <= dram0Converter.io.mem.dataIn.bits[6] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.bits[7] <= dram0Converter.io.mem.dataIn.bits[7] @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.dataIn.valid <= dram0Converter.io.mem.dataIn.valid @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.dataIn.ready <= tcu.io.dram0.dataIn.ready @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.control.bits.size <= tcu.io.dram0.control.bits.size @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.control.bits.address <= tcu.io.dram0.control.bits.address @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.control.bits.write <= tcu.io.dram0.control.bits.write @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.mem.control.valid <= tcu.io.dram0.control.valid @[AXIWrapperTCU.scala 75:25]
    tcu.io.dram0.control.ready <= dram0Converter.io.mem.control.ready @[AXIWrapperTCU.scala 75:25]
    dram0Converter.io.addressOffset <= tcu.io.config.dram0AddressOffset @[AXIWrapperTCU.scala 76:35]
    dram0Converter.io.cacheBehavior <= tcu.io.config.dram0CacheBehaviour @[AXIWrapperTCU.scala 77:35]
    dram0Converter.io.timeout <= tcu.io.timeout @[AXIWrapperTCU.scala 78:29]
    dram0Converter.io.tracepoint <= tcu.io.tracepoint @[AXIWrapperTCU.scala 79:32]
    dram0Converter.io.programCounter <= tcu.io.programCounter @[AXIWrapperTCU.scala 80:36]
    inst dram1Converter of Converter_1 @[AXIWrapperTCU.scala 82:30]
    dram1Converter.clock <= clock
    dram1Converter.reset <= reset
    inst dram1BoundarySplitter_io_in_q of Queue_53 @[Queue.scala 23:19]
    dram1BoundarySplitter_io_in_q.clock <= clock
    dram1BoundarySplitter_io_in_q.reset <= reset
    dram1Converter.io.axi.readData.bits.last <= dram1BoundarySplitter_io_in_q.io.in.readData.bits.last @[Queue.scala 24:13]
    dram1Converter.io.axi.readData.bits.resp <= dram1BoundarySplitter_io_in_q.io.in.readData.bits.resp @[Queue.scala 24:13]
    dram1Converter.io.axi.readData.bits.data <= dram1BoundarySplitter_io_in_q.io.in.readData.bits.data @[Queue.scala 24:13]
    dram1Converter.io.axi.readData.bits.id <= dram1BoundarySplitter_io_in_q.io.in.readData.bits.id @[Queue.scala 24:13]
    dram1Converter.io.axi.readData.valid <= dram1BoundarySplitter_io_in_q.io.in.readData.valid @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readData.ready <= dram1Converter.io.axi.readData.ready @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.qos <= dram1Converter.io.axi.readAddress.bits.qos @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.prot <= dram1Converter.io.axi.readAddress.bits.prot @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.cache <= dram1Converter.io.axi.readAddress.bits.cache @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.lock <= dram1Converter.io.axi.readAddress.bits.lock @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.burst <= dram1Converter.io.axi.readAddress.bits.burst @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.size <= dram1Converter.io.axi.readAddress.bits.size @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.len <= dram1Converter.io.axi.readAddress.bits.len @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.addr <= dram1Converter.io.axi.readAddress.bits.addr @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.bits.id <= dram1Converter.io.axi.readAddress.bits.id @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.readAddress.valid <= dram1Converter.io.axi.readAddress.valid @[Queue.scala 24:13]
    dram1Converter.io.axi.readAddress.ready <= dram1BoundarySplitter_io_in_q.io.in.readAddress.ready @[Queue.scala 24:13]
    dram1Converter.io.axi.writeResponse.bits.resp <= dram1BoundarySplitter_io_in_q.io.in.writeResponse.bits.resp @[Queue.scala 24:13]
    dram1Converter.io.axi.writeResponse.bits.id <= dram1BoundarySplitter_io_in_q.io.in.writeResponse.bits.id @[Queue.scala 24:13]
    dram1Converter.io.axi.writeResponse.valid <= dram1BoundarySplitter_io_in_q.io.in.writeResponse.valid @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeResponse.ready <= dram1Converter.io.axi.writeResponse.ready @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeData.bits.last <= dram1Converter.io.axi.writeData.bits.last @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeData.bits.strb <= dram1Converter.io.axi.writeData.bits.strb @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeData.bits.data <= dram1Converter.io.axi.writeData.bits.data @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeData.bits.id <= dram1Converter.io.axi.writeData.bits.id @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeData.valid <= dram1Converter.io.axi.writeData.valid @[Queue.scala 24:13]
    dram1Converter.io.axi.writeData.ready <= dram1BoundarySplitter_io_in_q.io.in.writeData.ready @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.qos <= dram1Converter.io.axi.writeAddress.bits.qos @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.prot <= dram1Converter.io.axi.writeAddress.bits.prot @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.cache <= dram1Converter.io.axi.writeAddress.bits.cache @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.lock <= dram1Converter.io.axi.writeAddress.bits.lock @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.burst <= dram1Converter.io.axi.writeAddress.bits.burst @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.size <= dram1Converter.io.axi.writeAddress.bits.size @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.len <= dram1Converter.io.axi.writeAddress.bits.len @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.addr <= dram1Converter.io.axi.writeAddress.bits.addr @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.bits.id <= dram1Converter.io.axi.writeAddress.bits.id @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.in.writeAddress.valid <= dram1Converter.io.axi.writeAddress.valid @[Queue.scala 24:13]
    dram1Converter.io.axi.writeAddress.ready <= dram1BoundarySplitter_io_in_q.io.in.writeAddress.ready @[Queue.scala 24:13]
    dram1BoundarySplitter_io_in_q.io.out.readData.bits.last <= dram1BoundarySplitter.io.in.readData.bits.last @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.readData.bits.resp <= dram1BoundarySplitter.io.in.readData.bits.resp @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.readData.bits.data <= dram1BoundarySplitter.io.in.readData.bits.data @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.readData.bits.id <= dram1BoundarySplitter.io.in.readData.bits.id @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.readData.valid <= dram1BoundarySplitter.io.in.readData.valid @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readData.ready <= dram1BoundarySplitter_io_in_q.io.out.readData.ready @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.qos <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.qos @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.prot <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.prot @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.cache <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.cache @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.lock <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.lock @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.burst <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.burst @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.size <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.size @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.len <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.len @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.addr <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.addr @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.bits.id <= dram1BoundarySplitter_io_in_q.io.out.readAddress.bits.id @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.readAddress.valid <= dram1BoundarySplitter_io_in_q.io.out.readAddress.valid @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.readAddress.ready <= dram1BoundarySplitter.io.in.readAddress.ready @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.writeResponse.bits.resp <= dram1BoundarySplitter.io.in.writeResponse.bits.resp @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.writeResponse.bits.id <= dram1BoundarySplitter.io.in.writeResponse.bits.id @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.writeResponse.valid <= dram1BoundarySplitter.io.in.writeResponse.valid @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeResponse.ready <= dram1BoundarySplitter_io_in_q.io.out.writeResponse.ready @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeData.bits.last <= dram1BoundarySplitter_io_in_q.io.out.writeData.bits.last @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeData.bits.strb <= dram1BoundarySplitter_io_in_q.io.out.writeData.bits.strb @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeData.bits.data <= dram1BoundarySplitter_io_in_q.io.out.writeData.bits.data @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeData.bits.id <= dram1BoundarySplitter_io_in_q.io.out.writeData.bits.id @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeData.valid <= dram1BoundarySplitter_io_in_q.io.out.writeData.valid @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.writeData.ready <= dram1BoundarySplitter.io.in.writeData.ready @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.qos <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.qos @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.prot <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.prot @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.cache <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.cache @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.lock <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.lock @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.burst <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.burst @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.size <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.size @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.len <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.len @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.addr <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.addr @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.bits.id <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.bits.id @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter.io.in.writeAddress.valid <= dram1BoundarySplitter_io_in_q.io.out.writeAddress.valid @[AXIWrapperTCU.scala 91:31]
    dram1BoundarySplitter_io_in_q.io.out.writeAddress.ready <= dram1BoundarySplitter.io.in.writeAddress.ready @[AXIWrapperTCU.scala 91:31]
    dram1Converter.io.mem.dataOut.bits[0] <= tcu.io.dram1.dataOut.bits[0] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[1] <= tcu.io.dram1.dataOut.bits[1] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[2] <= tcu.io.dram1.dataOut.bits[2] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[3] <= tcu.io.dram1.dataOut.bits[3] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[4] <= tcu.io.dram1.dataOut.bits[4] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[5] <= tcu.io.dram1.dataOut.bits[5] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[6] <= tcu.io.dram1.dataOut.bits[6] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.bits[7] <= tcu.io.dram1.dataOut.bits[7] @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataOut.valid <= tcu.io.dram1.dataOut.valid @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataOut.ready <= dram1Converter.io.mem.dataOut.ready @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[0] <= dram1Converter.io.mem.dataIn.bits[0] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[1] <= dram1Converter.io.mem.dataIn.bits[1] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[2] <= dram1Converter.io.mem.dataIn.bits[2] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[3] <= dram1Converter.io.mem.dataIn.bits[3] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[4] <= dram1Converter.io.mem.dataIn.bits[4] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[5] <= dram1Converter.io.mem.dataIn.bits[5] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[6] <= dram1Converter.io.mem.dataIn.bits[6] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.bits[7] <= dram1Converter.io.mem.dataIn.bits[7] @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.dataIn.valid <= dram1Converter.io.mem.dataIn.valid @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.dataIn.ready <= tcu.io.dram1.dataIn.ready @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.control.bits.size <= tcu.io.dram1.control.bits.size @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.control.bits.address <= tcu.io.dram1.control.bits.address @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.control.bits.write <= tcu.io.dram1.control.bits.write @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.mem.control.valid <= tcu.io.dram1.control.valid @[AXIWrapperTCU.scala 92:25]
    tcu.io.dram1.control.ready <= dram1Converter.io.mem.control.ready @[AXIWrapperTCU.scala 92:25]
    dram1Converter.io.addressOffset <= tcu.io.config.dram1AddressOffset @[AXIWrapperTCU.scala 93:35]
    dram1Converter.io.cacheBehavior <= tcu.io.config.dram1CacheBehaviour @[AXIWrapperTCU.scala 94:35]
    dram1Converter.io.timeout <= tcu.io.timeout @[AXIWrapperTCU.scala 95:29]
    dram1Converter.io.tracepoint <= tcu.io.tracepoint @[AXIWrapperTCU.scala 96:32]
    dram1Converter.io.programCounter <= tcu.io.programCounter @[AXIWrapperTCU.scala 97:36]
    
